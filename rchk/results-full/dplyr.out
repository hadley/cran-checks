Package dplyr version 0.8.1
Package built using 76619/R 3.7.0; x86_64-pc-linux-gnu; 2019-05-30 22:34:12 UTC; unix   
Checked with rchk version e904af503d348d9704682081216d92ba35f57e07
More information at https://github.com/kalibera/cran-checks/blob/master/rchk/PROTECT.md


Function Rcpp::Armor<SEXPREC*>::init(SEXPREC*)
  [PB] has possible protection stack imbalance Rcpp/include/Rcpp/protection/Armor.h:47

Function Rcpp::Armor<SEXPREC*>::~Armor()
  [PB] has negative depth Rcpp/include/Rcpp/protection/Armor.h:41
  [UP] attempt to unprotect more items (1) than protected (0), results will be incomplete Rcpp/include/Rcpp/protection/Armor.h:41
  [PB] has possible protection stack imbalance Rcpp/include/Rcpp/protection/Armor.h:42

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> dplyr::summarise_grouped<dplyr::GroupedDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %31 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %29 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %30 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> dplyr::summarise_grouped<dplyr::NaturalDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %29 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %30 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %28 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> dplyr::summarise_grouped<dplyr::RowwiseDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %28 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %29 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %30 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> mutate_grouped<dplyr::GroupedDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %25 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> mutate_grouped<dplyr::NaturalDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> mutate_grouped<dplyr::RowwiseDataFrame>(Rcpp::DataFrame_Impl<Rcpp::PreserveStorage> const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::Environment_Impl<Rcpp::PreserveStorage>::namespace_env(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::Language_Impl<Rcpp::PreserveStorage>::Language_Impl<SEXPREC*, Rcpp::traits::named_object<SEXPREC*> >(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, SEXPREC* const&, Rcpp::traits::named_object<SEXPREC*> const&)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::Rcpp_protect(SEXPREC*)
  [PB] has possible protection stack imbalance Rcpp/include/Rcpp/protection/Shield.h:25

Function Rcpp::Rcpp_unprotect(int)
  [PB] has an unsupported form of unprotect with a variable results will be incomplete Rcpp/include/Rcpp/protection/Shield.h:31
  [UP] unsupported form of unprotect, unprotecting all variables, results will be incomplete Rcpp/include/Rcpp/protection/Shield.h:31

Function Rcpp::internal::convert_using_rfunction(SEXPREC*, char const*)
  [UP] ignoring variable <unnamed var:   %9 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function Rcpp::sugar::IndexHash<16>::add_value(int)
  [UP] ignoring variable val as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 10>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 10>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 13>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 13>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 14>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<10, 14>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 10>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 10>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 13>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 13>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 14>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<13, 14>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<14, 13>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<14, 13>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<14, 14>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<14, 14>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<15, 15>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<15, 15>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<16, 16>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<16, 16>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<24, 24>::subset<boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> > >(boost::unordered::iterator_detail::c_iterator<boost::unordered::detail::ptr_node<int> >, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::DualVector<24, 24>::subset<std::__1::__wrap_iter<int const*> >(std::__1::__wrap_iter<int const*>, int)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::arrange_template<dplyr::GroupedDataFrame>(dplyr::GroupedDataFrame const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::arrange_template<dplyr::NaturalDataFrame>(dplyr::NaturalDataFrame const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::arrange_template<dplyr::RowwiseDataFrame>(dplyr::RowwiseDataFrame const&, dplyr::QuosureList const&, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::column_subset_matrix_impl<16, Rcpp::Vector<13, Rcpp::PreserveStorage> >(Rcpp::Matrix<16, Rcpp::PreserveStorage> const&, Rcpp::Vector<13, Rcpp::PreserveStorage> const&, Rcpp::traits::integral_constant<bool, true>)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::column_subset_matrix_impl<19, Rcpp::Vector<13, Rcpp::PreserveStorage> >(Rcpp::Matrix<19, Rcpp::PreserveStorage> const&, Rcpp::Vector<13, Rcpp::PreserveStorage> const&, Rcpp::traits::integral_constant<bool, true>)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::hybrid::match<dplyr::GroupedDataFrame>(SEXPREC*, dplyr::GroupedDataFrame const&, dplyr::DataMask<dplyr::GroupedDataFrame> const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %13 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::hybrid::match<dplyr::NaturalDataFrame>(SEXPREC*, dplyr::NaturalDataFrame const&, dplyr::DataMask<dplyr::NaturalDataFrame> const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %13 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function SEXPREC* dplyr::hybrid::match<dplyr::RowwiseDataFrame>(SEXPREC*, dplyr::RowwiseDataFrame const&, dplyr::DataMask<dplyr::RowwiseDataFrame> const&, SEXPREC*, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %13 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_anti_join_impl
  [UP] ignoring variable <unnamed var:   %32 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_arrange_impl
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_between
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_bind_rows_
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_cbind_all
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %18 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_combine_all
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %18 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_compatible_data_frame
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_compatible_data_frame_nonames
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_cumall
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_cumany
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_cummean
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_dfloc
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_distinct_impl
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %27 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_equal_data_frame
  [UP] ignoring variable <unnamed var:   %29 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_filter_impl
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %21 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_flatten_bindable
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %18 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_full_join_impl
  [UP] ignoring variable <unnamed var:   %38 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_group_data_grouped_df
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_group_size_grouped_cpp
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_group_split_impl
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_grouped_df_impl
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_grouped_indices_grouped_df_impl
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_hybrid_impl
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_hybrids
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_inner_join_impl
  [UP] ignoring variable <unnamed var:   %38 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_intersect_data_frame
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_is_data_pronoun
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_is_maybe_shared
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_is_variable_reference
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_left_join_impl
  [UP] ignoring variable <unnamed var:   %38 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_loc
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_materialize_binding
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %21 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_maybe_shared_columns
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_mutate_impl
  [UP] ignoring variable <unnamed var:   %23 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %24 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_n_distinct_multi
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_nest_join_impl
  [UP] ignoring variable <unnamed var:   %35 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_plfloc
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_quo_is_data_pronoun
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_quo_is_variable_reference
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_regroup
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %21 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_right_join_impl
  [UP] ignoring variable <unnamed var:   %38 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_select_impl
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_semi_join_impl
  [UP] ignoring variable <unnamed var:   %32 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_setdiff_data_frame
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_slice_impl
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %21 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_strings_addresses
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_summarise_impl
  [UP] ignoring variable <unnamed var:   %26 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %27 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_test_comparisons
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_test_length_wrap
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_test_matches
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_ungroup_grouped_df
  [UP] ignoring variable <unnamed var:   %17 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function _dplyr_union_data_frame
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function boost::hash<SEXPREC*>::operator()(SEXPREC*) const
  [UP] ignoring variable v as it has address taken, results will be incomplete 

Function dplyr::CharacterVectorOrderer::CharacterVectorOrderer(Rcpp::Vector<16, Rcpp::PreserveStorage> const&)
  [UP] ignoring variable previous as it has address taken, results will be incomplete 
  [UP] ignoring variable s as it has address taken, results will be incomplete 

Function dplyr::Collecter_Impl<19>::Collecter_Impl(int)
  [UP] ignoring variable <unnamed var:   %5 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::ColumnBinding<dplyr::GroupedDataFrame>::detach(SEXPREC*, SEXPREC*)
  [UP] ignoring variable mask_active as it has address taken, results will be incomplete 

Function dplyr::ColumnBinding<dplyr::NaturalDataFrame>::detach(SEXPREC*, SEXPREC*)
  [UP] ignoring variable mask_active as it has address taken, results will be incomplete 

Function dplyr::ColumnBinding<dplyr::RowwiseDataFrame>::detach(SEXPREC*, SEXPREC*)
  [UP] ignoring variable mask_active as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<10, dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<10, dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<13, dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<13, dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<14, dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<14, dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<15, dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<15, dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<16, dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::DelayedProcessor<16, dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::DelayedProcessor(int, Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&, SEXPREC*, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorCollecter::FactorCollecter(int, SEXPREC*)
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorCollecter::collect_factor(SlicingIndex const&, SEXPREC*)
  [UP] ignoring variable x as it has address taken, results will be incomplete 

Function dplyr::FactorCollecter::has_same_levels_as(SEXPREC*) const
  [UP] ignoring variable <unnamed var:   %12 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::FactorDelayedProcessor(SEXPREC*, int, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %15 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::try_handle(Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&)
  [UP] ignoring variable <unnamed var:   %9 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::GroupedDataFrame> >::update_levels(Rcpp::Vector<16, Rcpp::PreserveStorage> const&)
  [UP] ignoring variable s as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::FactorDelayedProcessor(SEXPREC*, int, dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %15 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::try_handle(Rcpp::RObject_Impl<Rcpp::PreserveStorage> const&)
  [UP] ignoring variable <unnamed var:   %9 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::FactorDelayedProcessor<dplyr::GroupedCallReducer<dplyr::RowwiseDataFrame> >::update_levels(Rcpp::Vector<16, Rcpp::PreserveStorage> const&)
  [UP] ignoring variable s as it has address taken, results will be incomplete 

Function dplyr::GroupSliceIndices<dplyr::GroupedDataFrame>::process()
  [UP] ignoring variable <unnamed var:   %3 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::GroupSliceIndices<dplyr::NaturalDataFrame>::process()
  [UP] ignoring variable <unnamed var:   %3 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::MutateCallProxy<dplyr::GroupedDataFrame>::evaluate()
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::MutateCallProxy<dplyr::RowwiseDataFrame>::evaluate()
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::POSIXctCollecter::update_tz(SEXPREC*)
  [UP] ignoring variable <unnamed var:   %9 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::POSIXctJoinVisitor<false>::POSIXctJoinVisitor(Column const&, Column const&)
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::POSIXctJoinVisitor<true>::POSIXctJoinVisitor(Column const&, Column const&)
  [UP] ignoring variable <unnamed var:   %14 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::SymbolMap::find(dplyr::SymbolString const&) const
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::SymbolMap::has(dplyr::SymbolString const&) const
  [UP] ignoring variable <unnamed var:   %6 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::SymbolMap::insert(dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %28 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::SymbolMap::rm(dplyr::SymbolString const&)
  [UP] ignoring variable <unnamed var:   %8 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::get_date_classes()
  [UP] ignoring variable <unnamed var:   %2 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::GroupedDataFrame>::handle_function(SEXPREC*)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::GroupedDataFrame>::handle_symbol_match(dplyr::hybrid::FindFunData&)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::GroupedDataFrame>::handle_symbol_workaround(SEXPREC*)
  [UP] ignoring variable head as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::NaturalDataFrame>::handle_function(SEXPREC*)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::NaturalDataFrame>::handle_symbol_match(dplyr::hybrid::FindFunData&)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::NaturalDataFrame>::handle_symbol_workaround(SEXPREC*)
  [UP] ignoring variable head as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::RowwiseDataFrame>::handle_function(SEXPREC*)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::RowwiseDataFrame>::handle_symbol_match(dplyr::hybrid::FindFunData&)
  [UP] ignoring variable f as it has address taken, results will be incomplete 

Function dplyr::hybrid::Expression<dplyr::RowwiseDataFrame>::handle_symbol_workaround(SEXPREC*)
  [UP] ignoring variable head as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::GroupedDataFrame, 16>::fill(GroupedSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable value as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::GroupedDataFrame, 19>::fill(GroupedSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable value as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::NaturalDataFrame, 16>::fill(NaturalSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable value as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::NaturalDataFrame, 19>::fill(NaturalSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable value as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::RowwiseDataFrame, 16>::fill(RowwiseSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable value as it has address taken, results will be incomplete 

Function dplyr::hybrid::internal::In_Column_Column<dplyr::RowwiseDataFrame, 19>::fill(RowwiseSlicingIndex const&, Rcpp::Vector<10, Rcpp::PreserveStorage>&) const
  [UP] ignoring variable value as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %16 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function dplyr::r_match(SEXPREC*, SEXPREC*, SEXPREC*)
  [UP] ignoring variable incomparables as it has address taken, results will be incomplete 
  [UP] ignoring variable x as it has address taken, results will be incomplete 
  [UP] ignoring variable y as it has address taken, results will be incomplete 

Function group_split_impl(dplyr::GroupedDataFrame const&, bool, SEXPREC*, bool)
  [UP] ignoring variable <unnamed var:   %29 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
  [UP] ignoring variable name as it has address taken, results will be incomplete 
  [UP] ignoring variable <unnamed var:   %20 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 

Function void Rcpp::Vector<16, Rcpp::PreserveStorage>::push_back<Rcpp::String>(Rcpp::String const&)
  [UP] ignoring variable <unnamed var:   %5 = alloca %struct.SEXPREC*, align 8> as it has address taken, results will be incomplete 
