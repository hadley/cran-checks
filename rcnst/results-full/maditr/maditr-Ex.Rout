
R Under development (unstable) (2021-02-17 r80023) -- "Unsuffered Consequences"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "maditr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('maditr')

To select columns from data: take(mtcars, am, vs, mpg)

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("coalesce")
> ### * coalesce
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coalesce
> ### Title: Return first non-missing element
> ### Aliases: coalesce
> 
> ### ** Examples
> 
> # examples from dplyr
> x = sample(c(1:5, NA, NA, NA))
> coalesce(x, 0L)
[1] 1 4 0 2 0 3 0 5
> 
> y = c(1, 2, NA, NA, 5)
> z = c(NA, NA, 3, 4, 5)
> coalesce(y, z)
[1] 1 2 3 4 5
> 
> 
> 
> cleanEx()
> nameEx("dcast")
> ### * dcast
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dcast
> ### Title: Convert data between wide and long forms.
> ### Aliases: dcast melt guess
> 
> ### ** Examples
> 
> # examples from 'tidyr' package
> stocks = data.frame(
+     time = as.Date('2009-01-01') + 0:9,
+     X = rnorm(10, 0, 1),
+     Y = rnorm(10, 0, 2),
+     Z = rnorm(10, 0, 4)
+ )
> stocksm = stocks %>%
+     melt(id.vars = "time", variable.name = "stock", value.name = "price")
> stocksm %>% dcast(time ~ stock)
Using 'price' as value column. Use 'value.var' to override
          time          X           Y          Z
 1: 2009-01-01 -0.6264538  3.02356234  3.6759095
 2: 2009-01-02  0.1836433  0.77968647  3.1285452
 3: 2009-01-03 -0.8356286 -1.24248116  0.2982599
 4: 2009-01-04  1.5952808 -4.42939977 -7.9574068
 5: 2009-01-05  0.3295078  2.24986184  2.4793030
 6: 2009-01-06 -0.8204684 -0.08986722 -0.2245150
 7: 2009-01-07  0.4874291 -0.03238053 -0.6231820
 8: 2009-01-08  0.7383247  1.88767242 -5.8830095
 9: 2009-01-09  0.5757814  1.64244239 -1.9126002
10: 2009-01-10 -0.3053884  1.18780264  1.6717662
> stocksm %>% dcast(stock ~ time)
Using 'price' as value column. Use 'value.var' to override
   stock 2009-01-01 2009-01-02 2009-01-03 2009-01-04 2009-01-05  2009-01-06
1:     X -0.6264538  0.1836433 -0.8356286   1.595281  0.3295078 -0.82046838
2:     Y  3.0235623  0.7796865 -1.2424812  -4.429400  2.2498618 -0.08986722
3:     Z  3.6759095  3.1285452  0.2982599  -7.957407  2.4793030 -0.22451496
    2009-01-07 2009-01-08 2009-01-09 2009-01-10
1:  0.48742905  0.7383247  0.5757814 -0.3053884
2: -0.03238053  1.8876724  1.6424424  1.1878026
3: -0.62318203 -5.8830095 -1.9126002  1.6717662
> 
> # dcast and melt are complements
> df = data.frame(x = c("a", "b"), y = c(3, 4), z = c(5, 6))
> df %>%
+     dcast(z ~ x, value.var = "y") %>%
+     melt(id.vars = "z", variable.name = "x", value.name = "y", na.rm = TRUE)
   z x y
1: 5 a 3
2: 6 b 4
> 
> 
> 
> cleanEx()
> nameEx("dt_count")
> ### * dt_count
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dt_count
> ### Title: Additional useful functions
> ### Aliases: dt_count dt_add_count dt_top_n
> 
> ### ** Examples
> 
> 
> data(mtcars)
> 
> # dt_count
> dt_count(mtcars, am, vs)
   am vs  n
1:  1  0  6
2:  1  1  7
3:  0  1  7
4:  0  0 12
> dt_add_count(mtcars, am, vs, name = "am_vs")[] # [] for autoprinting
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb am_vs
 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4     6
 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4     6
 3: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1     7
 4: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1     7
 5: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2    12
 6: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1     7
 7: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4    12
 8: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2     7
 9: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2     7
10: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4     7
11: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4     7
12: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3    12
13: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3    12
14: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3    12
15: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4    12
16: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4    12
17: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4    12
18: 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1     7
19: 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2     7
20: 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1     7
21: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1     7
22: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2    12
23: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2    12
24: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4    12
25: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2    12
26: 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1     7
27: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2     6
28: 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2     7
29: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4     6
30: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6     6
31: 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8     6
32: 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2     7
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb am_vs
> 
> # dt_top_n
> dt_top_n(mtcars, 2, by  = list(am, vs))
   am vs  mpg cyl  disp  hp drat    wt  qsec gear carb
1:  1  0 15.0   8 301.0 335 3.54 3.570 14.60    5    8
2:  1  0 19.7   6 145.0 175 3.62 2.770 15.50    5    6
3:  0  0 14.3   8 360.0 245 3.21 3.570 15.84    3    4
4:  0  0 10.4   8 472.0 205 2.93 5.250 17.98    3    4
5:  0  1 19.2   6 167.6 123 3.92 3.440 18.30    4    4
6:  0  1 17.8   6 167.6 123 3.92 3.440 18.90    4    4
7:  1  1 30.4   4  75.7  52 4.93 1.615 18.52    4    2
8:  1  1 30.4   4  95.1 113 3.77 1.513 16.90    5    2
> dt_top_n(mtcars, 2, order_by = mpg, by  = list(am, vs))
   am vs  mpg cyl  disp  hp drat    wt  qsec gear carb
1:  1  1 33.9   4  71.1  65 4.22 1.835 19.90    4    1
2:  1  1 32.4   4  78.7  66 4.08 2.200 19.47    4    1
3:  1  0 26.0   4 120.3  91 4.43 2.140 16.70    5    2
4:  1  0 21.0   6 160.0 110 3.90 2.620 16.46    4    4
5:  0  1 24.4   4 146.7  62 3.69 3.190 20.00    4    2
6:  0  1 22.8   4 140.8  95 3.92 3.150 22.90    4    2
7:  0  0 19.2   8 400.0 175 3.08 3.845 17.05    3    2
8:  0  0 18.7   8 360.0 175 3.15 3.440 17.02    3    2
> 
> 
> 
> cleanEx()
> nameEx("dt_left_join")
> ### * dt_left_join
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dt_left_join
> ### Title: Join two data.frames by common columns.
> ### Aliases: dt_left_join dt_right_join dt_inner_join dt_full_join
> ###   dt_semi_join dt_anti_join
> 
> ### ** Examples
> 
> workers = fread("
+     name company
+     Nick Acme
+     John Ajax
+     Daniela Ajax
+ ")
> 
> positions = fread("
+     name position
+     John designer
+     Daniela engineer
+     Cathie manager
+ ")
> 
> workers %>% dt_inner_join(positions)
dt_inner_join: joining, by = "name"
      name company position
1:    John    Ajax designer
2: Daniela    Ajax engineer
> workers %>% dt_left_join(positions)
dt_left_join: joining, by = "name"
      name company position
1:    Nick    Acme     <NA>
2:    John    Ajax designer
3: Daniela    Ajax engineer
> workers %>% dt_right_join(positions)
dt_right_join: joining, by = "name"
      name company position
1:    John    Ajax designer
2: Daniela    Ajax engineer
3:  Cathie    <NA>  manager
> workers %>% dt_full_join(positions)
dt_full_join: joining, by = "name"
      name company position
1:    Nick    Acme     <NA>
2:    John    Ajax designer
3: Daniela    Ajax engineer
4:  Cathie    <NA>  manager
> 
> # filtering joins
> workers %>% dt_anti_join(positions)
dt_anti_join: joining, by = "name"
   name company
1: Nick    Acme
> workers %>% dt_semi_join(positions)
dt_semi_join: joining, by = "name"
      name company
1:    John    Ajax
2: Daniela    Ajax
> 
> # To suppress the message, supply 'by' argument
> workers %>% dt_left_join(positions, by = "name")
      name company position
1:    Nick    Acme     <NA>
2:    John    Ajax designer
3: Daniela    Ajax engineer
> 
> # Use a named 'by' if the join variables have different names
> positions2 = setNames(positions, c("worker", "position")) # rename first column in 'positions'
> workers %>% dt_inner_join(positions2, by = c("name" = "worker"))
      name company position
1:    John    Ajax designer
2: Daniela    Ajax engineer
> 
> 
> 
> cleanEx()
> nameEx("dt_mutate")
> ### * dt_mutate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dt_mutate
> ### Title: 'dplyr'-like interface for data.table.
> ### Aliases: dt_mutate dt_summarize dt_summarize_all dt_summarise
> ###   dt_summarise_all dt_select dt_filter dt_arrange
> 
> ### ** Examples
> 
> # examples from 'dplyr'
> # newly created variables are available immediately
> mtcars  %>%
+     dt_mutate(
+         cyl2 = cyl * 2,
+         cyl4 = cyl2 * 2
+     ) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb cyl2 cyl4
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   12   24
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   12   24
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    8   16
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   12   24
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   16   32
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   12   24
> 
> 
> # you can also use dt_mutate() to remove variables and
> # modify existing variables
> mtcars %>%
+     dt_mutate(
+         mpg = NULL,
+         disp = disp * 0.0163871 # convert to litres
+     ) %>%
+     head()
   cyl     disp  hp drat    wt  qsec vs am gear carb
1:   6 2.621936 110 3.90 2.620 16.46  0  1    4    4
2:   6 2.621936 110 3.90 2.875 17.02  0  1    4    4
3:   4 1.769807  93 3.85 2.320 18.61  1  1    4    1
4:   6 4.227872 110 3.08 3.215 19.44  1  0    3    1
5:   8 5.899356 175 3.15 3.440 17.02  0  0    3    2
6:   6 3.687098 105 2.76 3.460 20.22  1  0    3    1
> 
> 
> # window functions are useful for grouped mutates
> mtcars %>%
+     dt_mutate(
+         rank = rank(-mpg, ties.method = "min"),
+         keyby = cyl) %>%
+     print()
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb rank
 1: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1    8
 2: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2    7
 3: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2    8
 4: 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1    2
 5: 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2    3
 6: 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1    1
 7: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1   10
 8: 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1    5
 9: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2    6
10: 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2    3
11: 21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2   11
12: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4    2
13: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4    2
14: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1    1
15: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1    6
16: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4    5
17: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4    7
18: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6    4
19: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2    2
20: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4   11
21: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3    4
22: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3    3
23: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3    7
24: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4   13
25: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4   13
26: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4   10
27: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2    6
28: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2    7
29: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4   12
30: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2    1
31: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4    5
32: 15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8    9
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb rank
> 
> 
> # You can drop variables by setting them to NULL
> mtcars %>% dt_mutate(cyl = NULL) %>% head()
    mpg disp  hp drat    wt  qsec vs am gear carb
1: 21.0  160 110 3.90 2.620 16.46  0  1    4    4
2: 21.0  160 110 3.90 2.875 17.02  0  1    4    4
3: 22.8  108  93 3.85 2.320 18.61  1  1    4    1
4: 21.4  258 110 3.08 3.215 19.44  1  0    3    1
5: 18.7  360 175 3.15 3.440 17.02  0  0    3    2
6: 18.1  225 105 2.76 3.460 20.22  1  0    3    1
> 
> # A summary applied without by returns a single row
> mtcars %>%
+     dt_summarise(mean = mean(disp), n = .N)
       mean  n
1: 230.7219 32
> 
> # Usually, you'll want to group first
> mtcars %>%
+     dt_summarise(mean = mean(disp), n = .N, by = cyl)
   cyl     mean  n
1:   6 183.3143  7
2:   4 105.1364 11
3:   8 353.1000 14
> 
> 
> # Multiple 'by' - variables
> mtcars %>%
+     dt_summarise(cyl_n = .N, by = list(cyl, vs))
   cyl vs cyl_n
1:   6  0     3
2:   4  1    10
3:   6  1     4
4:   8  0    14
5:   4  0     1
> 
> # Newly created summaries immediately
> # doesn't overwrite existing variables
> mtcars %>%
+     dt_summarise(disp = mean(disp),
+                   sd = sd(disp),
+                   by = cyl)
   cyl     disp       sd
1:   6 183.3143 41.56246
2:   4 105.1364 26.87159
3:   8 353.1000 67.77132
> 
> # You can group by expressions:
> mtcars %>%
+     dt_summarise_all(mean, by = list(vsam = vs + am))
   vsam      mpg      cyl     disp        hp     drat       wt     qsec
1:    1 20.28462 5.692308 189.4692 138.46154 3.738462 3.038846 18.04231
2:    2 28.37143 4.000000  89.8000  80.57143 4.148571 2.028286 18.70000
3:    0 15.05000 8.000000 357.6167 194.16667 3.120833 4.104083 17.14250
       gear     carb
1: 4.076923 3.307692
2: 4.142857 1.428571
3: 3.000000 3.083333
> 
> # filter by condition
> mtcars %>%
+     dt_filter(am==0)
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
 1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
 2: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
 3: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
 4: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
 5: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
 6: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
 7: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
 8: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
 9: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
10: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
11: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
12: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
13: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
14: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
15: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
16: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
17: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
18: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
19: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
> 
> # filter by compound condition
> mtcars %>%
+     dt_filter(am==0,  mpg>mean(mpg))
    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
2: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
3: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
4: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
> 
> 
> # select
> mtcars %>% dt_select(vs:carb, cyl)
    vs am gear carb cyl
 1:  0  1    4    4   6
 2:  0  1    4    4   6
 3:  1  1    4    1   4
 4:  1  0    3    1   6
 5:  0  0    3    2   8
 6:  1  0    3    1   6
 7:  0  0    3    4   8
 8:  1  0    4    2   4
 9:  1  0    4    2   4
10:  1  0    4    4   6
11:  1  0    4    4   6
12:  0  0    3    3   8
13:  0  0    3    3   8
14:  0  0    3    3   8
15:  0  0    3    4   8
16:  0  0    3    4   8
17:  0  0    3    4   8
18:  1  1    4    1   4
19:  1  1    4    2   4
20:  1  1    4    1   4
21:  1  0    3    1   4
22:  0  0    3    2   8
23:  0  0    3    2   8
24:  0  0    3    4   8
25:  0  0    3    2   8
26:  1  1    4    1   4
27:  0  1    5    2   4
28:  1  1    5    2   4
29:  0  1    5    4   8
30:  0  1    5    6   6
31:  0  1    5    8   8
32:  1  1    4    2   4
    vs am gear carb cyl
> mtcars %>% dt_select(-am, -cyl)
     mpg  disp  hp drat    wt  qsec vs gear carb
 1: 21.0 160.0 110 3.90 2.620 16.46  0    4    4
 2: 21.0 160.0 110 3.90 2.875 17.02  0    4    4
 3: 22.8 108.0  93 3.85 2.320 18.61  1    4    1
 4: 21.4 258.0 110 3.08 3.215 19.44  1    3    1
 5: 18.7 360.0 175 3.15 3.440 17.02  0    3    2
 6: 18.1 225.0 105 2.76 3.460 20.22  1    3    1
 7: 14.3 360.0 245 3.21 3.570 15.84  0    3    4
 8: 24.4 146.7  62 3.69 3.190 20.00  1    4    2
 9: 22.8 140.8  95 3.92 3.150 22.90  1    4    2
10: 19.2 167.6 123 3.92 3.440 18.30  1    4    4
11: 17.8 167.6 123 3.92 3.440 18.90  1    4    4
12: 16.4 275.8 180 3.07 4.070 17.40  0    3    3
13: 17.3 275.8 180 3.07 3.730 17.60  0    3    3
14: 15.2 275.8 180 3.07 3.780 18.00  0    3    3
15: 10.4 472.0 205 2.93 5.250 17.98  0    3    4
16: 10.4 460.0 215 3.00 5.424 17.82  0    3    4
17: 14.7 440.0 230 3.23 5.345 17.42  0    3    4
18: 32.4  78.7  66 4.08 2.200 19.47  1    4    1
19: 30.4  75.7  52 4.93 1.615 18.52  1    4    2
20: 33.9  71.1  65 4.22 1.835 19.90  1    4    1
21: 21.5 120.1  97 3.70 2.465 20.01  1    3    1
22: 15.5 318.0 150 2.76 3.520 16.87  0    3    2
23: 15.2 304.0 150 3.15 3.435 17.30  0    3    2
24: 13.3 350.0 245 3.73 3.840 15.41  0    3    4
25: 19.2 400.0 175 3.08 3.845 17.05  0    3    2
26: 27.3  79.0  66 4.08 1.935 18.90  1    4    1
27: 26.0 120.3  91 4.43 2.140 16.70  0    5    2
28: 30.4  95.1 113 3.77 1.513 16.90  1    5    2
29: 15.8 351.0 264 4.22 3.170 14.50  0    5    4
30: 19.7 145.0 175 3.62 2.770 15.50  0    5    6
31: 15.0 301.0 335 3.54 3.570 14.60  0    5    8
32: 21.4 121.0 109 4.11 2.780 18.60  1    4    2
     mpg  disp  hp drat    wt  qsec vs gear carb
> 
> # regular expression pattern
> dt_select(iris, "^Petal") # variables which start from 'Petal'
     Petal.Length Petal.Width
  1:          1.4         0.2
  2:          1.4         0.2
  3:          1.3         0.2
  4:          1.5         0.2
  5:          1.4         0.2
 ---                         
146:          5.2         2.3
147:          5.0         1.9
148:          5.2         2.0
149:          5.4         2.3
150:          5.1         1.8
> dt_select(iris, "Width$") # variables which end with 'Width'
     Sepal.Width Petal.Width
  1:         3.5         0.2
  2:         3.0         0.2
  3:         3.2         0.2
  4:         3.1         0.2
  5:         3.6         0.2
 ---                        
146:         3.0         2.3
147:         2.5         1.9
148:         3.0         2.0
149:         3.4         2.3
150:         3.0         1.8
> # move Species variable to the front.
> # pattern "^." matches all variables
> dt_select(iris, Species, "^.")
       Species Sepal.Length Sepal.Width Petal.Length Petal.Width
  1:    setosa          5.1         3.5          1.4         0.2
  2:    setosa          4.9         3.0          1.4         0.2
  3:    setosa          4.7         3.2          1.3         0.2
  4:    setosa          4.6         3.1          1.5         0.2
  5:    setosa          5.0         3.6          1.4         0.2
 ---                                                            
146: virginica          6.7         3.0          5.2         2.3
147: virginica          6.3         2.5          5.0         1.9
148: virginica          6.5         3.0          5.2         2.0
149: virginica          6.2         3.4          5.4         2.3
150: virginica          5.9         3.0          5.1         1.8
> # pattern "^.*i" means "contains 'i'"
> dt_select(iris, "^.*i")
     Sepal.Width Petal.Width   Species
  1:         3.5         0.2    setosa
  2:         3.0         0.2    setosa
  3:         3.2         0.2    setosa
  4:         3.1         0.2    setosa
  5:         3.6         0.2    setosa
 ---                                  
146:         3.0         2.3 virginica
147:         2.5         1.9 virginica
148:         3.0         2.0 virginica
149:         3.4         2.3 virginica
150:         3.0         1.8 virginica
> dt_select(iris, 1:4) # numeric indexing - all variables except Species
     Sepal.Length Sepal.Width Petal.Length Petal.Width
  1:          5.1         3.5          1.4         0.2
  2:          4.9         3.0          1.4         0.2
  3:          4.7         3.2          1.3         0.2
  4:          4.6         3.1          1.5         0.2
  5:          5.0         3.6          1.4         0.2
 ---                                                  
146:          6.7         3.0          5.2         2.3
147:          6.3         2.5          5.0         1.9
148:          6.5         3.0          5.2         2.0
149:          6.2         3.4          5.4         2.3
150:          5.9         3.0          5.1         1.8
> 
> # sorting
> dt_arrange(mtcars, cyl, disp)
> dt_arrange(mtcars, -disp)
> 
> 
> 
> cleanEx()
> nameEx("let_if")
> ### * let_if
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: let_if
> ### Title: Modify, aggregate, select or filter data.frame/data.table
> ### Aliases: let_if take_if take let let.data.frame sort_by let_all
> ###   take_all
> 
> ### ** Examples
> 
> # examples form 'dplyr' package
> data(mtcars)
> 
> # Newly created variables are available immediately
> mtcars %>%
+     let(
+         cyl2 = cyl * 2,
+         cyl4 = cyl2 * 2
+     ) %>% head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb cyl2 cyl4
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   12   24
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   12   24
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    8   16
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   12   24
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   16   32
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   12   24
> 
> # You can also use let() to remove variables and
> # modify existing variables
> mtcars %>%
+     let(
+         mpg = NULL,
+         disp = disp * 0.0163871 # convert to litres
+     ) %>% head()
   cyl     disp  hp drat    wt  qsec vs am gear carb
1:   6 2.621936 110 3.90 2.620 16.46  0  1    4    4
2:   6 2.621936 110 3.90 2.875 17.02  0  1    4    4
3:   4 1.769807  93 3.85 2.320 18.61  1  1    4    1
4:   6 4.227872 110 3.08 3.215 19.44  1  0    3    1
5:   8 5.899356 175 3.15 3.440 17.02  0  0    3    2
6:   6 3.687098 105 2.76 3.460 20.22  1  0    3    1
> 
> 
> # window functions are useful for grouped computations
> mtcars %>%
+     let(rank = rank(-mpg, ties.method = "min"),
+         by = cyl) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb rank
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4    2
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4    2
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    8
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1    1
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2    2
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1    6
> 
> # You can drop variables by setting them to NULL
> mtcars %>% let(cyl = NULL) %>% head()
    mpg disp  hp drat    wt  qsec vs am gear carb
1: 21.0  160 110 3.90 2.620 16.46  0  1    4    4
2: 21.0  160 110 3.90 2.875 17.02  0  1    4    4
3: 22.8  108  93 3.85 2.320 18.61  1  1    4    1
4: 21.4  258 110 3.08 3.215 19.44  1  0    3    1
5: 18.7  360 175 3.15 3.440 17.02  0  0    3    2
6: 18.1  225 105 2.76 3.460 20.22  1  0    3    1
> 
> # keeps all existing variables
> mtcars %>%
+     let(displ_l = disp / 61.0237) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb  displ_l
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 2.621932
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 2.621932
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 1.769804
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 4.227866
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 5.899347
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 3.687092
> 
> # keeps only the variables you create
> mtcars %>%
+     take(displ_l = disp / 61.0237)
     displ_l
 1: 2.621932
 2: 2.621932
 3: 1.769804
 4: 4.227866
 5: 5.899347
 6: 3.687092
 7: 5.899347
 8: 2.403984
 9: 2.307300
10: 2.746474
11: 2.746474
12: 4.519556
13: 4.519556
14: 4.519556
15: 7.734700
16: 7.538055
17: 7.210313
18: 1.289663
19: 1.240502
20: 1.165121
21: 1.968088
22: 5.211090
23: 4.981671
24: 5.735477
25: 6.554830
26: 1.294579
27: 1.971365
28: 1.558411
29: 5.751864
30: 2.376126
31: 4.932510
32: 1.982836
     displ_l
> 
> 
> # can refer to both contextual variables and variable names:
> var = 100
> mtcars %>%
+     let(cyl = cyl * var) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb
1: 21.0 600  160 110 3.90 2.620 16.46  0  1    4    4
2: 21.0 600  160 110 3.90 2.875 17.02  0  1    4    4
3: 22.8 400  108  93 3.85 2.320 18.61  1  1    4    1
4: 21.4 600  258 110 3.08 3.215 19.44  1  0    3    1
5: 18.7 800  360 175 3.15 3.440 17.02  0  0    3    2
6: 18.1 600  225 105 2.76 3.460 20.22  1  0    3    1
> 
> # filter by condition
> mtcars %>%
+     take_if(am==0)
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
 1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
 2: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
 3: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
 4: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
 5: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
 6: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
 7: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
 8: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
 9: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
10: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
11: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
12: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
13: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
14: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
15: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
16: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
17: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
18: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
19: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
> 
> # filter by compound condition
> mtcars %>%
+     take_if(am==0 & mpg>mean(mpg))
    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
2: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
3: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
4: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
> 
> 
> # A 'take' with summary functions applied without 'by' argument returns an aggregated data
> mtcars %>%
+     take(mean = mean(disp), n = .N)
       mean  n
1: 230.7219 32
> 
> # Usually, you'll want to group first
> mtcars %>%
+     take(mean = mean(disp), n = .N, by = cyl)
   cyl     mean  n
1:   6 183.3143  7
2:   4 105.1364 11
3:   8 353.1000 14
> 
> # You can group by expressions:
> mtcars %>%
+     take_all(mean, by = list(vsam = vs + am))
   vsam      mpg      cyl     disp        hp     drat       wt     qsec
1:    1 20.28462 5.692308 189.4692 138.46154 3.738462 3.038846 18.04231
2:    2 28.37143 4.000000  89.8000  80.57143 4.148571 2.028286 18.70000
3:    0 15.05000 8.000000 357.6167 194.16667 3.120833 4.104083 17.14250
       gear     carb
1: 4.076923 3.307692
2: 4.142857 1.428571
3: 3.000000 3.083333
> 
> # modify all non-grouping variables in-place
> mtcars %>%
+     let_all((.x - mean(.x))/sd(.x), by = am) %>%
+     head()
          mpg        cyl       disp         hp       drat         wt       qsec
1: -0.5501185  0.5945745  0.1888587 -0.2004008 -0.4120299  0.3387459 -0.5021316
2: -0.5501185  0.5945745  0.1888587 -0.2004008 -0.4120299  0.7520483 -0.1896942
3: -0.2582189 -0.6936702 -0.4074443 -0.4026317 -0.5493732 -0.1474922  0.6974050
4:  1.1091990 -0.6133196 -0.2938955 -0.9323843 -0.5259081 -0.7124963  0.7176592
5:  0.4049674  0.6814663  0.6319326  0.2733692 -0.3474750 -0.4230701 -0.6641654
6:  0.2484716 -0.6133196 -0.5934281 -1.0251346 -1.3416023 -0.3973433  1.1630407
           vs am       gear       carb
1: -1.0377490  1 -0.7595545  0.4944600
2: -1.0377490  1 -0.7595545  0.4944600
3:  0.8894992  1 -0.7595545 -0.8829642
4:  1.2743862  0 -0.5026247 -1.5141438
5: -0.7433919  0 -0.5026247 -0.6423641
6:  1.2743862  0 -0.5026247 -1.5141438
> 
> # modify all non-grouping variables to new variables
> mtcars %>%
+     let_all(scaled = (.x - mean(.x))/sd(.x), by = am) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_scaled cyl_scaled
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 -0.5501185  0.5945745
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 -0.5501185  0.5945745
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 -0.2582189 -0.6936702
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1  1.1091990 -0.6133196
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2  0.4049674  0.6814663
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1  0.2484716 -0.6133196
   disp_scaled  hp_scaled drat_scaled  wt_scaled qsec_scaled  vs_scaled
1:   0.1888587 -0.2004008  -0.4120299  0.3387459  -0.5021316 -1.0377490
2:   0.1888587 -0.2004008  -0.4120299  0.7520483  -0.1896942 -1.0377490
3:  -0.4074443 -0.4026317  -0.5493732 -0.1474922   0.6974050  0.8894992
4:  -0.2938955 -0.9323843  -0.5259081 -0.7124963   0.7176592  1.2743862
5:   0.6319326  0.2733692  -0.3474750 -0.4230701  -0.6641654 -0.7433919
6:  -0.5934281 -1.0251346  -1.3416023 -0.3973433   1.1630407  1.2743862
   gear_scaled carb_scaled
1:  -0.7595545   0.4944600
2:  -0.7595545   0.4944600
3:  -0.7595545  -0.8829642
4:  -0.5026247  -1.5141438
5:  -0.5026247  -0.6423641
6:  -0.5026247  -1.5141438
> 
> # conditionally modify all variables
> iris %>%
+     let_all(mean = if(is.numeric(.x)) mean(.x)) %>%
+     head()
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_mean
1:          5.1         3.5          1.4         0.2  setosa          5.843333
2:          4.9         3.0          1.4         0.2  setosa          5.843333
3:          4.7         3.2          1.3         0.2  setosa          5.843333
4:          4.6         3.1          1.5         0.2  setosa          5.843333
5:          5.0         3.6          1.4         0.2  setosa          5.843333
6:          5.4         3.9          1.7         0.4  setosa          5.843333
   Sepal.Width_mean Petal.Length_mean Petal.Width_mean
1:         3.057333             3.758         1.199333
2:         3.057333             3.758         1.199333
3:         3.057333             3.758         1.199333
4:         3.057333             3.758         1.199333
5:         3.057333             3.758         1.199333
6:         3.057333             3.758         1.199333
> 
> # modify all variables conditionally on name
> iris %>%
+     let_all(
+         mean = if(startsWith(.name, "Sepal")) mean(.x),
+         median = if(startsWith(.name, "Petal")) median(.x),
+         by = Species
+     ) %>%
+     head()
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_mean
1:          5.1         3.5          1.4         0.2  setosa             5.006
2:          4.9         3.0          1.4         0.2  setosa             5.006
3:          4.7         3.2          1.3         0.2  setosa             5.006
4:          4.6         3.1          1.5         0.2  setosa             5.006
5:          5.0         3.6          1.4         0.2  setosa             5.006
6:          5.4         3.9          1.7         0.4  setosa             5.006
   Sepal.Width_mean Petal.Length_median Petal.Width_median
1:            3.428                 1.5                0.2
2:            3.428                 1.5                0.2
3:            3.428                 1.5                0.2
4:            3.428                 1.5                0.2
5:            3.428                 1.5                0.2
6:            3.428                 1.5                0.2
> 
> # aggregation with 'take_all'
> mtcars %>%
+     take_all(mean = mean(.x), sd = sd(.x), n = .N, by = am)
   am mpg_mean cyl_mean disp_mean  hp_mean drat_mean  wt_mean qsec_mean
1:  1 24.39231 5.076923  143.5308 126.8462  4.050000 2.411000  17.36000
2:  0 17.14737 6.947368  290.3789 160.2632  3.286316 3.768895  18.18316
     vs_mean gear_mean carb_mean   mpg_sd   cyl_sd   disp_sd    hp_sd   drat_sd
1: 0.5384615  4.384615  2.923077 6.166504 1.552500  87.20399 84.06232 0.3640513
2: 0.3684211  3.210526  2.736842 3.833966 1.544657 110.17165 53.90820 0.3923039
       wt_sd  qsec_sd     vs_sd   gear_sd  carb_sd mpg_n cyl_n disp_n hp_n
1: 0.6169816 1.792359 0.5188745 0.5063697 2.177978    13    13     13   13
2: 0.7774001 1.751308 0.4955946 0.4188539 1.147079    19    19     19   19
   drat_n wt_n qsec_n vs_n gear_n carb_n
1:     13   13     13   13     13     13
2:     19   19     19   19     19     19
> 
> # conditionally aggregate all variables
> iris %>%
+     take_all(mean = if(is.numeric(.x)) mean(.x))
   Sepal.Length_mean Sepal.Width_mean Petal.Length_mean Petal.Width_mean
1:          5.843333         3.057333             3.758         1.199333
> 
> # aggregate all variables conditionally on name
> iris %>%
+     take_all(
+         mean = if(startsWith(.name, "Sepal")) mean(.x),
+         median = if(startsWith(.name, "Petal")) median(.x),
+         by = Species
+     )
      Species Sepal.Length_mean Sepal.Width_mean Petal.Length_median
1:     setosa             5.006            3.428                1.50
2: versicolor             5.936            2.770                4.35
3:  virginica             6.588            2.974                5.55
   Petal.Width_median
1:                0.2
2:                1.3
3:                2.0
> 
> # parametric evaluation:
> var = quote(mean(cyl))
> mtcars %>%
+     let(mean_cyl = eval(var)) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mean_cyl
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   6.1875
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   6.1875
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   6.1875
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   6.1875
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   6.1875
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   6.1875
> take(mtcars, eval(var))
   eval(var)
1:    6.1875
> 
> # all together
> new_var = "mean_cyl"
> mtcars %>%
+     let((new_var) := eval(var)) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mean_cyl
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   6.1875
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   6.1875
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   6.1875
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   6.1875
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   6.1875
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   6.1875
> take(mtcars, (new_var) := eval(var))
   mean_cyl
1:   6.1875
> 
> ########################################
> 
> # examples from data.table
> dat = data.table(
+     x=rep(c("b","a","c"), each=3),
+     y=c(1,3,6),
+     v=1:9
+ )
> 
> # basic row subset operations
> take_if(dat, 2)                         # 2nd row
   x y v
1: b 3 2
> take_if(dat, 3:2)                       # 3rd and 2nd row
   x y v
1: b 6 3
2: b 3 2
> take_if(dat, order(x))                  # no need for order(dat$x)
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
4: b 1 1
5: b 3 2
6: b 6 3
7: c 1 7
8: c 3 8
9: c 6 9
> take_if(dat, y>2)                       # all rows where dat$y > 2
   x y v
1: b 3 2
2: b 6 3
3: a 3 5
4: a 6 6
5: c 3 8
6: c 6 9
> take_if(dat, y>2 & v>5)                 # compound logical expressions
   x y v
1: a 6 6
2: c 3 8
3: c 6 9
> take_if(dat, !2:4)                      # all rows other than 2:4
   x y v
1: b 1 1
2: a 3 5
3: a 6 6
4: c 1 7
5: c 3 8
6: c 6 9
> take_if(dat, -(2:4))                    # same
   x y v
1: b 1 1
2: a 3 5
3: a 6 6
4: c 1 7
5: c 3 8
6: c 6 9
> 
> # select|compute columns
> take(dat, v)                  # v column (as data.table)
   v
1: 1
2: 2
3: 3
4: 4
5: 5
6: 6
7: 7
8: 8
9: 9
> take(dat, sum(v))             # return data.table with sum of v (column autonamed 'sum(v)')
   sum(v)
1:     45
> take(dat, sv = sum(v))        # same, but column named "sv"
   sv
1: 45
> take(dat, v, v*2)             # return two column data.table, v and v*2
   v v * 2
1: 1     2
2: 2     4
3: 3     6
4: 4     8
5: 5    10
6: 6    12
7: 7    14
8: 8    16
9: 9    18
> 
> # subset rows and select|compute
> take_if(dat, 2:3, sum(v))      # sum(v) over rows 2 and 3
   sum(v)
1:      5
> take_if(dat, 2:3, sv = sum(v)) # same, but return data.table with column sv
   sv
1:  5
> 
> # grouping operations
> take(dat, sum(v), by = x)             # ad hoc by, order of groups preserved in result
   x sum(v)
1: b      6
2: a     15
3: c     24
> take(dat, sum(v), keyby = x)          # same, but order the result on by cols
   x sum(v)
1: a     15
2: b      6
3: c     24
> 
> 
> # all together now
> take_if(dat, x!="a", sum(v), by=x)                       # get sum(v) by "x" for each x != "a"
   x sum(v)
1: b      6
2: c     24
> 
> # more on special symbols, see also ?"data.table::special-symbols"
> take_if(dat, .N)                           # last row
   x y v
1: c 6 9
> take(dat, .N)                              # total number of rows in DT
   .N
1:  9
> take(dat, .N, by=x)                        # number of rows in each group
   x .N
1: b  3
2: a  3
3: c  3
> 
> take(dat, .I[1], by=x)                     # row number in DT corresponding to each group
   x .I[1]
1: b     1
2: a     4
3: c     7
> 
> 
> # add/update/delete by reference
> # [] at the end of expression is for autoprinting
> let(dat, grp = .GRP, by=x)[]          # add a group counter column
   x y v grp
1: b 1 1   1
2: b 3 2   1
3: b 6 3   1
4: a 1 4   2
5: a 3 5   2
6: a 6 6   2
7: c 1 7   3
8: c 3 8   3
9: c 6 9   3
> let(dat, z = 42L)[]                   # add new column by reference
   x y v grp  z
1: b 1 1   1 42
2: b 3 2   1 42
3: b 6 3   1 42
4: a 1 4   2 42
5: a 3 5   2 42
6: a 6 6   2 42
7: c 1 7   3 42
8: c 3 8   3 42
9: c 6 9   3 42
> let(dat, z = NULL)[]                  # remove column by reference
   x y v grp
1: b 1 1   1
2: b 3 2   1
3: b 6 3   1
4: a 1 4   2
5: a 3 5   2
6: a 6 6   2
7: c 1 7   3
8: c 3 8   3
9: c 6 9   3
> let_if(dat, x=="a", v = 42L)[]        # subassign to existing v column by reference
   x y  v grp
1: b 1  1   1
2: b 3  2   1
3: b 6  3   1
4: a 1 42   2
5: a 3 42   2
6: a 6 42   2
7: c 1  7   3
8: c 3  8   3
9: c 6  9   3
> let_if(dat, x=="b", v2 = 84L)[]       # subassign to new column by reference (NA padded)
   x y  v grp v2
1: b 1  1   1 84
2: b 3  2   1 84
3: b 6  3   1 84
4: a 1 42   2 NA
5: a 3 42   2 NA
6: a 6 42   2 NA
7: c 1  7   3 NA
8: c 3  8   3 NA
9: c 6  9   3 NA
> 
> let(dat, m = mean(v), by=x)[]         # add new column by reference by group
   x y  v grp v2  m
1: b 1  1   1 84  2
2: b 3  2   1 84  2
3: b 6  3   1 84  2
4: a 1 42   2 NA 42
5: a 3 42   2 NA 42
6: a 6 42   2 NA 42
7: c 1  7   3 NA  8
8: c 3  8   3 NA  8
9: c 6  9   3 NA  8
> 
> # advanced usage
> dat = data.table(x=rep(c("b","a","c"), each=3),
+                  v=c(1,1,1,2,2,1,1,2,2),
+                  y=c(1,3,6),
+                  a=1:9,
+                  b=9:1)
> 
> take(dat, sum(v), by=list(y%%2))              # expressions in by
   y sum(v)
1: 1      9
2: 0      4
> take(dat, sum(v), by=list(bool = y%%2))       # same, using a named list to change by column name
   bool sum(v)
1:    1      9
2:    0      4
> take_all(dat, sum, by=x)                      # sum of all (other) columns for each group
   x v  y  a  b
1: b 3 10  6 24
2: a 5 10 15 15
3: c 5 10 24  6
> take(dat,
+      MySum=sum(v),
+      MyMin=min(v),
+      MyMax=max(v),
+      by = list(x, y%%2)               # by 2 expressions
+ )
   x y MySum MyMin MyMax
1: b 1     2     1     1
2: b 0     1     1     1
3: a 1     4     2     2
4: a 0     1     1     1
5: c 1     3     1     2
6: c 0     2     2     2
> 
> take(dat, seq = min(a):max(b), by=x)  # j is not limited to just aggregations
    x seq
 1: b   1
 2: b   2
 3: b   3
 4: b   4
 5: b   5
 6: b   6
 7: b   7
 8: b   8
 9: b   9
10: a   4
11: a   5
12: a   6
13: c   7
14: c   6
15: c   5
16: c   4
17: c   3
> dat %>%
+     take(V1 = sum(v), by=x) %>%
+     take_if(V1<20)                    # compound query
   x V1
1: b  3
2: a  5
3: c  5
> 
> dat %>%
+     take(V1 = sum(v), by=x) %>%
+     sort_by(-V1) %>%                  # ordering results
+     head()
   x V1
1: a  5
2: c  5
3: b  3
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("maditr")
> ### * maditr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maditr
> ### Title: maditr: Pipe-Style Interface for 'data.table'
> ### Aliases: maditr
> 
> ### ** Examples
> 
> # examples form 'dplyr' package
> data(mtcars)
> 
> # Newly created variables are available immediately
> mtcars %>%
+     let(
+         cyl2 = cyl * 2,
+         cyl4 = cyl2 * 2
+     ) %>% head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb cyl2 cyl4
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   12   24
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   12   24
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    8   16
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   12   24
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   16   32
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   12   24
> 
> # You can also use let() to remove variables and
> # modify existing variables
> mtcars %>%
+     let(
+         mpg = NULL,
+         disp = disp * 0.0163871 # convert to litres
+     ) %>% head()
   cyl     disp  hp drat    wt  qsec vs am gear carb
1:   6 2.621936 110 3.90 2.620 16.46  0  1    4    4
2:   6 2.621936 110 3.90 2.875 17.02  0  1    4    4
3:   4 1.769807  93 3.85 2.320 18.61  1  1    4    1
4:   6 4.227872 110 3.08 3.215 19.44  1  0    3    1
5:   8 5.899356 175 3.15 3.440 17.02  0  0    3    2
6:   6 3.687098 105 2.76 3.460 20.22  1  0    3    1
> 
> 
> # window functions are useful for grouped computations
> mtcars %>%
+     let(rank = rank(-mpg, ties.method = "min"),
+         by = cyl) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb rank
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4    2
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4    2
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1    8
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1    1
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2    2
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1    6
> 
> # You can drop variables by setting them to NULL
> mtcars %>% let(cyl = NULL) %>% head()
    mpg disp  hp drat    wt  qsec vs am gear carb
1: 21.0  160 110 3.90 2.620 16.46  0  1    4    4
2: 21.0  160 110 3.90 2.875 17.02  0  1    4    4
3: 22.8  108  93 3.85 2.320 18.61  1  1    4    1
4: 21.4  258 110 3.08 3.215 19.44  1  0    3    1
5: 18.7  360 175 3.15 3.440 17.02  0  0    3    2
6: 18.1  225 105 2.76 3.460 20.22  1  0    3    1
> 
> # keeps all existing variables
> mtcars %>%
+     let(displ_l = disp / 61.0237) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb  displ_l
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 2.621932
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 2.621932
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 1.769804
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 4.227866
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 5.899347
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 3.687092
> 
> # keeps only the variables you create
> mtcars %>%
+     take(displ_l = disp / 61.0237)
     displ_l
 1: 2.621932
 2: 2.621932
 3: 1.769804
 4: 4.227866
 5: 5.899347
 6: 3.687092
 7: 5.899347
 8: 2.403984
 9: 2.307300
10: 2.746474
11: 2.746474
12: 4.519556
13: 4.519556
14: 4.519556
15: 7.734700
16: 7.538055
17: 7.210313
18: 1.289663
19: 1.240502
20: 1.165121
21: 1.968088
22: 5.211090
23: 4.981671
24: 5.735477
25: 6.554830
26: 1.294579
27: 1.971365
28: 1.558411
29: 5.751864
30: 2.376126
31: 4.932510
32: 1.982836
     displ_l
> 
> 
> # can refer to both contextual variables and variable names:
> var = 100
> mtcars %>%
+     let(cyl = cyl * var) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb
1: 21.0 600  160 110 3.90 2.620 16.46  0  1    4    4
2: 21.0 600  160 110 3.90 2.875 17.02  0  1    4    4
3: 22.8 400  108  93 3.85 2.320 18.61  1  1    4    1
4: 21.4 600  258 110 3.08 3.215 19.44  1  0    3    1
5: 18.7 800  360 175 3.15 3.440 17.02  0  0    3    2
6: 18.1 600  225 105 2.76 3.460 20.22  1  0    3    1
> 
> # filter by condition
> mtcars %>%
+     take_if(am==0)
     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
 1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
 2: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
 3: 18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
 4: 14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
 5: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
 6: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
 7: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
 8: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
 9: 16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
10: 17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
11: 15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
12: 10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
13: 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
14: 14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
15: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
16: 15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
17: 15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
18: 13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
19: 19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
> 
> # filter by compound condition
> mtcars %>%
+     take_if(am==0 & mpg>mean(mpg))
    mpg cyl  disp  hp drat    wt  qsec vs am gear carb
1: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
2: 24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
3: 22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
4: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
> 
> 
> # A 'take' with summary functions applied without 'by' argument returns an aggregated data
> mtcars %>%
+     take(mean = mean(disp), n = .N)
       mean  n
1: 230.7219 32
> 
> # Usually, you'll want to group first
> mtcars %>%
+     take(mean = mean(disp), n = .N, by = cyl)
   cyl     mean  n
1:   6 183.3143  7
2:   4 105.1364 11
3:   8 353.1000 14
> 
> # You can group by expressions:
> mtcars %>%
+     take_all(mean, by = list(vsam = vs + am))
   vsam      mpg      cyl     disp        hp     drat       wt     qsec
1:    1 20.28462 5.692308 189.4692 138.46154 3.738462 3.038846 18.04231
2:    2 28.37143 4.000000  89.8000  80.57143 4.148571 2.028286 18.70000
3:    0 15.05000 8.000000 357.6167 194.16667 3.120833 4.104083 17.14250
       gear     carb
1: 4.076923 3.307692
2: 4.142857 1.428571
3: 3.000000 3.083333
> 
> # modify all non-grouping variables in-place
> mtcars %>%
+     let_all((.x - mean(.x))/sd(.x), by = am) %>%
+     head()
          mpg        cyl       disp         hp       drat         wt       qsec
1: -0.5501185  0.5945745  0.1888587 -0.2004008 -0.4120299  0.3387459 -0.5021316
2: -0.5501185  0.5945745  0.1888587 -0.2004008 -0.4120299  0.7520483 -0.1896942
3: -0.2582189 -0.6936702 -0.4074443 -0.4026317 -0.5493732 -0.1474922  0.6974050
4:  1.1091990 -0.6133196 -0.2938955 -0.9323843 -0.5259081 -0.7124963  0.7176592
5:  0.4049674  0.6814663  0.6319326  0.2733692 -0.3474750 -0.4230701 -0.6641654
6:  0.2484716 -0.6133196 -0.5934281 -1.0251346 -1.3416023 -0.3973433  1.1630407
           vs am       gear       carb
1: -1.0377490  1 -0.7595545  0.4944600
2: -1.0377490  1 -0.7595545  0.4944600
3:  0.8894992  1 -0.7595545 -0.8829642
4:  1.2743862  0 -0.5026247 -1.5141438
5: -0.7433919  0 -0.5026247 -0.6423641
6:  1.2743862  0 -0.5026247 -1.5141438
> 
> # modify all non-grouping variables to new variables
> mtcars %>%
+     let_all(scaled = (.x - mean(.x))/sd(.x), by = am) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mpg_scaled cyl_scaled
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 -0.5501185  0.5945745
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 -0.5501185  0.5945745
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 -0.2582189 -0.6936702
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1  1.1091990 -0.6133196
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2  0.4049674  0.6814663
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1  0.2484716 -0.6133196
   disp_scaled  hp_scaled drat_scaled  wt_scaled qsec_scaled  vs_scaled
1:   0.1888587 -0.2004008  -0.4120299  0.3387459  -0.5021316 -1.0377490
2:   0.1888587 -0.2004008  -0.4120299  0.7520483  -0.1896942 -1.0377490
3:  -0.4074443 -0.4026317  -0.5493732 -0.1474922   0.6974050  0.8894992
4:  -0.2938955 -0.9323843  -0.5259081 -0.7124963   0.7176592  1.2743862
5:   0.6319326  0.2733692  -0.3474750 -0.4230701  -0.6641654 -0.7433919
6:  -0.5934281 -1.0251346  -1.3416023 -0.3973433   1.1630407  1.2743862
   gear_scaled carb_scaled
1:  -0.7595545   0.4944600
2:  -0.7595545   0.4944600
3:  -0.7595545  -0.8829642
4:  -0.5026247  -1.5141438
5:  -0.5026247  -0.6423641
6:  -0.5026247  -1.5141438
> 
> # conditionally modify all variables
> iris %>%
+     let_all(mean = if(is.numeric(.x)) mean(.x)) %>%
+     head()
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_mean
1:          5.1         3.5          1.4         0.2  setosa          5.843333
2:          4.9         3.0          1.4         0.2  setosa          5.843333
3:          4.7         3.2          1.3         0.2  setosa          5.843333
4:          4.6         3.1          1.5         0.2  setosa          5.843333
5:          5.0         3.6          1.4         0.2  setosa          5.843333
6:          5.4         3.9          1.7         0.4  setosa          5.843333
   Sepal.Width_mean Petal.Length_mean Petal.Width_mean
1:         3.057333             3.758         1.199333
2:         3.057333             3.758         1.199333
3:         3.057333             3.758         1.199333
4:         3.057333             3.758         1.199333
5:         3.057333             3.758         1.199333
6:         3.057333             3.758         1.199333
> 
> # modify all variables conditionally on name
> iris %>%
+     let_all(
+         mean = if(startsWith(.name, "Sepal")) mean(.x),
+         median = if(startsWith(.name, "Petal")) median(.x),
+         by = Species
+     ) %>%
+     head()
   Sepal.Length Sepal.Width Petal.Length Petal.Width Species Sepal.Length_mean
1:          5.1         3.5          1.4         0.2  setosa             5.006
2:          4.9         3.0          1.4         0.2  setosa             5.006
3:          4.7         3.2          1.3         0.2  setosa             5.006
4:          4.6         3.1          1.5         0.2  setosa             5.006
5:          5.0         3.6          1.4         0.2  setosa             5.006
6:          5.4         3.9          1.7         0.4  setosa             5.006
   Sepal.Width_mean Petal.Length_median Petal.Width_median
1:            3.428                 1.5                0.2
2:            3.428                 1.5                0.2
3:            3.428                 1.5                0.2
4:            3.428                 1.5                0.2
5:            3.428                 1.5                0.2
6:            3.428                 1.5                0.2
> 
> # aggregation with 'take_all'
> mtcars %>%
+     take_all(mean = mean(.x), sd = sd(.x), n = .N, by = am)
   am mpg_mean cyl_mean disp_mean  hp_mean drat_mean  wt_mean qsec_mean
1:  1 24.39231 5.076923  143.5308 126.8462  4.050000 2.411000  17.36000
2:  0 17.14737 6.947368  290.3789 160.2632  3.286316 3.768895  18.18316
     vs_mean gear_mean carb_mean   mpg_sd   cyl_sd   disp_sd    hp_sd   drat_sd
1: 0.5384615  4.384615  2.923077 6.166504 1.552500  87.20399 84.06232 0.3640513
2: 0.3684211  3.210526  2.736842 3.833966 1.544657 110.17165 53.90820 0.3923039
       wt_sd  qsec_sd     vs_sd   gear_sd  carb_sd mpg_n cyl_n disp_n hp_n
1: 0.6169816 1.792359 0.5188745 0.5063697 2.177978    13    13     13   13
2: 0.7774001 1.751308 0.4955946 0.4188539 1.147079    19    19     19   19
   drat_n wt_n qsec_n vs_n gear_n carb_n
1:     13   13     13   13     13     13
2:     19   19     19   19     19     19
> 
> # conditionally aggregate all variables
> iris %>%
+     take_all(mean = if(is.numeric(.x)) mean(.x))
   Sepal.Length_mean Sepal.Width_mean Petal.Length_mean Petal.Width_mean
1:          5.843333         3.057333             3.758         1.199333
> 
> # aggregate all variables conditionally on name
> iris %>%
+     take_all(
+         mean = if(startsWith(.name, "Sepal")) mean(.x),
+         median = if(startsWith(.name, "Petal")) median(.x),
+         by = Species
+     )
      Species Sepal.Length_mean Sepal.Width_mean Petal.Length_median
1:     setosa             5.006            3.428                1.50
2: versicolor             5.936            2.770                4.35
3:  virginica             6.588            2.974                5.55
   Petal.Width_median
1:                0.2
2:                1.3
3:                2.0
> 
> # parametric evaluation:
> var = quote(mean(cyl))
> mtcars %>%
+     let(mean_cyl = eval(var)) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mean_cyl
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   6.1875
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   6.1875
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   6.1875
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   6.1875
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   6.1875
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   6.1875
> take(mtcars, eval(var))
   eval(var)
1:    6.1875
> 
> # all together
> new_var = "mean_cyl"
> mtcars %>%
+     let((new_var) := eval(var)) %>%
+     head()
    mpg cyl disp  hp drat    wt  qsec vs am gear carb mean_cyl
1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4   6.1875
2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4   6.1875
3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1   6.1875
4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1   6.1875
5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2   6.1875
6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1   6.1875
> take(mtcars, (new_var) := eval(var))
   mean_cyl
1:   6.1875
> 
> 
> 
> 
> cleanEx()
> nameEx("query_if")
> ### * query_if
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: query_if
> ### Title: One-to-one interface for data.table '[' method
> ### Aliases: query_if query
> 
> ### ** Examples
> 
> # examples from data.table
> dat = data.table(x=rep(c("b","a","c"),each=3), y=c(1,3,6), v=1:9)
> dat
   x y v
1: b 1 1
2: b 3 2
3: b 6 3
4: a 1 4
5: a 3 5
6: a 6 6
7: c 1 7
8: c 3 8
9: c 6 9
> # basic row subset operations
> query_if(dat, 2)                        # 2nd row
   x y v
1: b 3 2
> query_if(dat, 3:2)                        # 3rd and 2nd row
   x y v
1: b 6 3
2: b 3 2
> query_if(dat, order(x))                   # no need for order(dat$x)
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
4: b 1 1
5: b 3 2
6: b 6 3
7: c 1 7
8: c 3 8
9: c 6 9
> query_if(dat, y>2)                        # all rows where dat$y > 2
   x y v
1: b 3 2
2: b 6 3
3: a 3 5
4: a 6 6
5: c 3 8
6: c 6 9
> query_if(dat, y>2 & v>5)                  # compound logical expressions
   x y v
1: a 6 6
2: c 3 8
3: c 6 9
> query_if(dat, !2:4)                       # all rows other than 2:4
   x y v
1: b 1 1
2: a 3 5
3: a 6 6
4: c 1 7
5: c 3 8
6: c 6 9
> query_if(dat, -(2:4))                     # same
   x y v
1: b 1 1
2: a 3 5
3: a 6 6
4: c 1 7
5: c 3 8
6: c 6 9
> 
> # select|compute columns data.table way
> query(dat, v)                        # v column (as vector)
[1] 1 2 3 4 5 6 7 8 9
> query(dat, list(v))                  # v column (as data.table)
   v
1: 1
2: 2
3: 3
4: 4
5: 5
6: 6
7: 7
8: 8
9: 9
> query(dat, sum(v))                   # sum of column v, returned as vector
[1] 45
> query(dat, list(sum(v)))             # same, but return data.table (column autonamed V1)
   V1
1: 45
> query(dat, list(v, v*2))             # return two column data.table, v and v*2
   v V2
1: 1  2
2: 2  4
3: 3  6
4: 4  8
5: 5 10
6: 6 12
7: 7 14
8: 8 16
9: 9 18
> 
> # subset rows and select|compute data.table way
> query_if(dat, 2:3, sum(v))                # sum(v) over rows 2 and 3, return vector
[1] 5
> query_if(dat, 2:3, list(sum(v)))             # same, but return data.table with column V1
   V1
1:  5
> query_if(dat, 2:3, list(sv=sum(v)))          # same, but return data.table with column sv
   sv
1:  5
> query_if(dat, 2:5, cat(v, "\n"))          # just for j's side effect
2 3 4 5 
NULL
> 
> # select columns the data.frame way
> query(dat, 2, with=FALSE)            # 2nd column, returns a data.table always
   y
1: 1
2: 3
3: 6
4: 1
5: 3
6: 6
7: 1
8: 3
9: 6
> colNum = 2
> query(dat, colNum, with=FALSE)       # same, equivalent to DT[, .SD, .SDcols=colNum]
   y
1: 1
2: 3
3: 6
4: 1
5: 3
6: 6
7: 1
8: 3
9: 6
> 
> # grouping operations - j and by
> query(dat, sum(v), by=x)             # ad hoc by, order of groups preserved in result
   x V1
1: b  6
2: a 15
3: c 24
> query(dat, sum(v), keyby=x)          # same, but order the result on by cols
   x V1
1: a 15
2: b  6
3: c 24
> query(dat, sum(v), by=x) %>%
+     query_if(order(x))               # same but by chaining expressions together
   x V1
1: a 15
2: b  6
3: c 24
> 
> # fast ad hoc row subsets (subsets as joins)
> # same as x == "a" but uses binary search (fast)
> query_if(dat, "a", on="x")
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
> # same, for convenience, no need to quote every column
> query_if(dat, "a", on=list(x))
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
> query_if(dat, .("a"), on="x")                          # same
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
> # same, single "==" internally optimised to use binary search (fast)
> query_if(dat, x=="a")
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
> # not yet optimized, currently vector scan subset
> query_if(dat, x!="b" | y!=3)
   x y v
1: b 1 1
2: b 6 3
3: a 1 4
4: a 3 5
5: a 6 6
6: c 1 7
7: c 3 8
8: c 6 9
> # join on columns x,y of 'dat'; uses binary search (fast)
> query_if(dat, .("b", 3), on=c("x", "y"))
   x y v
1: b 3 2
> query_if(dat, .("b", 3), on=list(x, y))                # same, but using on=list()
   x y v
1: b 3 2
> query_if(dat, .("b", 1:2), on=c("x", "y"))             # no match returns NA
   x y  v
1: b 1  1
2: b 2 NA
> query_if(dat, .("b", 1:2), on=.(x, y), nomatch=0)      # no match row is not returned
   x y v
1: b 1 1
> # locf, nomatch row gets rolled by previous row
> query_if(dat, .("b", 1:2), on=c("x", "y"), roll=Inf)
   x y v
1: b 1 1
2: b 2 1
> query_if(dat, .("b", 1:2), on=.(x, y), roll=-Inf)      # nocb, nomatch row gets rolled by next row
   x y v
1: b 1 1
2: b 2 2
> # on rows where dat$x=="b", calculate sum(v*y)
> query_if(dat, "b", sum(v*y), on="x")
[1] 25
> 
> # all together now
> query_if(dat, x!="a", sum(v), by=x)                    # get sum(v) by "x" for each i != "a"
   x V1
1: b  6
2: c 24
> query_if(dat, !"a", sum(v), by=.EACHI, on="x")         # same, but using subsets-as-joins
   x V1
1: b  6
2: c 24
> query_if(dat, c("b","c"), sum(v), by=.EACHI, on="x")   # same
   x V1
1: b  6
2: c 24
> query_if(dat, c("b","c"), sum(v), by=.EACHI, on=.(x))  # same, using on=.()
   x V1
1: b  6
2: c 24
> 
> # joins as subsets
> X = data.table(x=c("c","b"), v=8:7, foo=c(4,2))
> X
   x v foo
1: c 8   4
2: b 7   2
> 
> query_if(dat, X, on="x")                         # right join
   x y v i.v foo
1: c 1 7   8   4
2: c 3 8   8   4
3: c 6 9   8   4
4: b 1 1   7   2
5: b 3 2   7   2
6: b 6 3   7   2
> query_if(X, dat, on="x")                         # left join
   x  v foo y i.v
1: b  7   2 1   1
2: b  7   2 3   2
3: b  7   2 6   3
4: a NA  NA 1   4
5: a NA  NA 3   5
6: a NA  NA 6   6
7: c  8   4 1   7
8: c  8   4 3   8
9: c  8   4 6   9
> query_if(dat, X, on="x", nomatch=0)              # inner join
   x y v i.v foo
1: c 1 7   8   4
2: c 3 8   8   4
3: c 6 9   8   4
4: b 1 1   7   2
5: b 3 2   7   2
6: b 6 3   7   2
> query_if(dat, !X, on="x")                        # not join
   x y v
1: a 1 4
2: a 3 5
3: a 6 6
> # join using column "y" of 'dat' with column "v" of X
> query_if(dat, X, on=c(y="v"))
      x y  v i.x foo
1: <NA> 8 NA   c   4
2: <NA> 7 NA   b   2
> query_if(dat,X, on="y==v")                       # same as above (v1.9.8+)
      x y  v i.x foo
1: <NA> 8 NA   c   4
2: <NA> 7 NA   b   2
> 
> query_if(dat, X, on = .(y<=foo))                 # NEW non-equi join (v1.9.8+)
   x y v i.x i.v
1: b 4 1   c   8
2: b 4 2   c   8
3: a 4 4   c   8
4: a 4 5   c   8
5: c 4 7   c   8
6: c 4 8   c   8
7: b 2 1   b   7
8: a 2 4   b   7
9: c 2 7   b   7
> query_if(dat, X, on="y<=foo")                    # same as above
   x y v i.x i.v
1: b 4 1   c   8
2: b 4 2   c   8
3: a 4 4   c   8
4: a 4 5   c   8
5: c 4 7   c   8
6: c 4 8   c   8
7: b 2 1   b   7
8: a 2 4   b   7
9: c 2 7   b   7
> query_if(dat, X, on=c("y<=foo"))                 # same as above
   x y v i.x i.v
1: b 4 1   c   8
2: b 4 2   c   8
3: a 4 4   c   8
4: a 4 5   c   8
5: c 4 7   c   8
6: c 4 8   c   8
7: b 2 1   b   7
8: a 2 4   b   7
9: c 2 7   b   7
> query_if(dat, X, on=.(y>=foo))                   # NEW non-equi join (v1.9.8+)
   x y v i.x i.v
1: b 4 3   c   8
2: a 4 6   c   8
3: c 4 9   c   8
4: b 2 2   b   7
5: b 2 3   b   7
6: a 2 5   b   7
7: a 2 6   b   7
8: c 2 8   b   7
9: c 2 9   b   7
> query_if(dat, X, on=.(x, y<=foo))                # NEW non-equi join (v1.9.8+)
   x y v i.v
1: c 4 7   8
2: c 4 8   8
3: b 2 1   7
> query_if(dat, X, .(x,y,x.y,v), on=.(x, y>=foo))  # Select x's join columns as well
   x y x.y v
1: c 4   6 9
2: b 2   3 2
3: b 2   6 3
> 
> query_if(dat, X, on="x", mult="first")           # first row of each group
   x y v i.v foo
1: c 1 7   8   4
2: b 1 1   7   2
> query_if(dat, X, on="x", mult="last")            # last row of each group
   x y v i.v foo
1: c 6 9   8   4
2: b 6 3   7   2
> query_if(dat, X, sum(v), by=.EACHI, on="x")      # join and eval j for each row in i
   x V1
1: c 24
2: b  6
> query_if(dat, X, sum(v)*foo, by=.EACHI, on="x")  # join inherited scope
   x V1
1: c 96
2: b 12
> query_if(dat, X, sum(v)*i.v, by=.EACHI, on="x")  # 'i,v' refers to X's v column
   x  V1
1: c 192
2: b  42
> query_if(dat, X, on=.(x, v>=v), sum(y)*foo, by=.EACHI) # NEW non-equi join with by=.EACHI (v1.9.8+)
   x v V1
1: c 8 36
2: b 7 NA
> 
> 
> # more on special symbols, see also ?"special-symbols"
> query_if(dat, .N)                           # last row
   x y v
1: c 6 9
> query(dat, .N)                              # total number of rows in DT
[1] 9
> query(dat, .N, by=x)                        # number of rows in each group
   x N
1: b 3
2: a 3
3: c 3
> query(dat, .SD, .SDcols=x:y)                # select columns 'x' and 'y'
   x y
1: b 1
2: b 3
3: b 6
4: a 1
5: a 3
6: a 6
7: c 1
8: c 3
9: c 6
> query(dat, .SD[1])                          # first row of all columns
   x y v
1: b 1 1
> query(dat, .SD[1], by=x)                    # first row of 'y' and 'v' for each group in 'x'
   x y v
1: b 1 1
2: a 1 4
3: c 1 7
> query(dat, c(.N, lapply(.SD, sum)), by=x)   # get rows *and* sum columns 'v' and 'y' by group
   x N  y  v
1: b 3 10  6
2: a 3 10 15
3: c 3 10 24
> query(dat, .I[1], by=x)                     # row number in DT corresponding to each group
   x V1
1: b  1
2: a  4
3: c  7
> query(dat, grp := .GRP, by=x) %>% head()    # add a group counter column
   x y v grp
1: b 1 1   1
2: b 3 2   1
3: b 6 3   1
4: a 1 4   2
5: a 3 5   2
6: a 6 6   2
> query(X, query_if(dat, .BY, y, on="x"), by=x)               # join within each group
   x V1
1: c  1
2: c  3
3: c  6
4: b  1
5: b  3
6: b  6
> 
> # add/update/delete by reference (see ?assign)
> query(dat, z:=42L) %>% head()         # add new column by reference
   x y v grp  z
1: b 1 1   1 42
2: b 3 2   1 42
3: b 6 3   1 42
4: a 1 4   2 42
5: a 3 5   2 42
6: a 6 6   2 42
> query(dat, z:=NULL) %>% head()        # remove column by reference
   x y v grp
1: b 1 1   1
2: b 3 2   1
3: b 6 3   1
4: a 1 4   2
5: a 3 5   2
6: a 6 6   2
> query_if(dat, "a", v:=42L, on="x") %>% head()  # subassign to existing v column by reference
   x y  v grp
1: b 1  1   1
2: b 3  2   1
3: b 6  3   1
4: a 1 42   2
5: a 3 42   2
6: a 6 42   2
> query_if(dat, "b", v2:=84L, on="x") %>% head() # subassign to new column by reference (NA padded)
   x y  v grp v2
1: b 1  1   1 84
2: b 3  2   1 84
3: b 6  3   1 84
4: a 1 42   2 NA
5: a 3 42   2 NA
6: a 6 42   2 NA
> 
> # NB: postfix [] is shortcut to print()
> query(dat, m:=mean(v), by=x)[]              # add new column by reference by group
   x y  v grp v2  m
1: b 1  1   1 84  2
2: b 3  2   1 84  2
3: b 6  3   1 84  2
4: a 1 42   2 NA 42
5: a 3 42   2 NA 42
6: a 6 42   2 NA 42
7: c 1  7   3 NA  8
8: c 3  8   3 NA  8
9: c 6  9   3 NA  8
> 
> # advanced usage
> dat = data.table(x=rep(c("b","a","c"),each=3),
+                  v=c(1,1,1,2,2,1,1,2,2),
+                  y=c(1,3,6),
+                  a=1:9,
+                  b=9:1)
> dat
   x v y a b
1: b 1 1 1 9
2: b 1 3 2 8
3: b 1 6 3 7
4: a 2 1 4 6
5: a 2 3 5 5
6: a 1 6 6 4
7: c 1 1 7 3
8: c 2 3 8 2
9: c 2 6 9 1
> query(dat, sum(v), by=.(y%%2))              # expressions in by
   y V1
1: 1  9
2: 0  4
> query(dat, sum(v), by=.(bool = y%%2))       # same, using a named list to change by column name
   bool V1
1:    1  9
2:    0  4
> query(dat, .SD[2], by=x)                    # get 2nd row of each group
   x v y a b
1: b 1 3 2 8
2: a 2 3 5 5
3: c 2 3 8 2
> query(dat, tail(.SD,2), by=x)               # last 2 rows of each group
   x v y a b
1: b 1 3 2 8
2: b 1 6 3 7
3: a 2 3 5 5
4: a 1 6 6 4
5: c 2 3 8 2
6: c 2 6 9 1
> query(dat, lapply(.SD, sum), by=x)          # sum of all (other) columns for each group
   x v  y  a  b
1: b 3 10  6 24
2: a 5 10 15 15
3: c 5 10 24  6
> query(dat, .SD[which.min(v)], by=x)         # nested query by group
   x v y a b
1: b 1 1 1 9
2: a 1 6 6 4
3: c 1 1 7 3
> 
> query(dat, list(MySum=sum(v),
+                 MyMin=min(v),
+                 MyMax=max(v)),
+       by=.(x, y%%2)
+ )                    # by 2 expressions
   x y MySum MyMin MyMax
1: b 1     2     1     1
2: b 0     1     1     1
3: a 1     4     2     2
4: a 0     1     1     1
5: c 1     3     1     2
6: c 0     2     2     2
> 
> query(dat, .(a = .(a), b = .(b)), by=x)      # list columns
   x     a     b
1: b 1,2,3 9,8,7
2: a 4,5,6 6,5,4
3: c 7,8,9 3,2,1
> query(dat, .(seq = min(a):max(b)), by=x)     # j is not limited to just aggregations
    x seq
 1: b   1
 2: b   2
 3: b   3
 4: b   4
 5: b   5
 6: b   6
 7: b   7
 8: b   8
 9: b   9
10: a   4
11: a   5
12: a   6
13: c   7
14: c   6
15: c   5
16: c   4
17: c   3
> query(dat, sum(v), by=x) %>%
+     query_if(V1<20) # compound query
   x V1
1: b  3
2: a  5
3: c  5
> query(dat, sum(v), by=x) %>%
+     setorder(-V1) %>%
+     head()          # ordering results
   x V1
1: a  5
2: c  5
3: b  3
> query(dat, c(.N, lapply(.SD,sum)), by=x)     # get number of observations and sum per group
   x N v  y  a  b
1: b 3 3 10  6 24
2: a 3 5 10 15 15
3: c 3 5 10 24  6
> 
> # anonymous lambda in 'j', j accepts any valid
> # expression. TO REMEMBER: every element of
> # the list becomes a column in result.
> query(dat,
+       {tmp = mean(y);
+       .(a = a-tmp, b = b-tmp)
+       },
+       by=x)
   x          a          b
1: b -2.3333333  5.6666667
2: b -1.3333333  4.6666667
3: b -0.3333333  3.6666667
4: a  0.6666667  2.6666667
5: a  1.6666667  1.6666667
6: a  2.6666667  0.6666667
7: c  3.6666667 -0.3333333
8: c  4.6666667 -1.3333333
9: c  5.6666667 -2.3333333
> 
> ## Not run: 
> ##D     pdf("new.pdf")
> ##D     query(dat, plot(a,b), by=x)                # can also plot in 'j'
> ##D     dev.off()
> ## End(Not run)
> # using rleid, get max(y) and min of all cols in .SDcols for each consecutive run of 'v'
> query(dat,
+       c(.(y=max(y)), lapply(.SD, min)),
+       by=rleid(v),
+       .SDcols=v:b
+ )
   rleid y v y a b
1:     1 6 1 1 1 7
2:     2 3 2 1 4 5
3:     3 6 1 1 6 3
4:     4 6 2 3 8 1
> 
> 
> 
> cleanEx()
> nameEx("to_list")
> ### * to_list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: to_list
> ### Title: Apply an expression to each element of a list or vector
> ### Aliases: to_list to_vec to_df to_dfr to_dfc
> 
> ### ** Examples
> 
> 1:5 %>%
+     to_list(rnorm(n = 3, .x))
[[1]]
[1] 0.3735462 1.1836433 0.1643714

[[2]]
[1] 3.595281 2.329508 1.179532

[[3]]
[1] 3.487429 3.738325 3.575781

[[4]]
[1] 3.694612 5.511781 4.389843

[[5]]
[1] 4.378759 2.785300 6.124931

> 
> # or in 'lapply' style
> 1:5 %>%
+     to_list(rnorm, n = 3) %>%
+     to_vec(mean)
[1] 1.294237 2.778033 2.622450 4.135967 4.489680
> 
> # or use an anonymous function
> 1:5 %>%
+     to_list(function(x) rnorm(3, x))
[[1]]
[1] 2.3586796 0.8972123 1.3876716

[[2]]
[1] 1.9461950 0.6229404 1.5850054

[[3]]
[1] 2.605710 2.940687 4.100025

[[4]]
[1] 4.763176 3.835476 3.746638

[[5]]
[1] 5.696963 5.556663 4.311244

> 
> # Use to_vec() to reduce output to a vector instead
> # of a list:
> # filtering - return only even numbers
> to_vec(1:10, if(.x %% 2 == 0) .x)
[1]  2  4  6  8 10
> 
> # filtering - mean only on the numeric columns
> to_vec(iris, if(is.numeric(.x)) mean(.x))
Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 
> 
> # mean for numerics, number of distincts for others
> to_vec(iris, if(is.numeric(.x)) mean(.x) else uniqueN(.x))
Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
    5.843333     3.057333     3.758000     1.199333     3.000000 
> 
> # means for Sepal
> to_vec(iris, if(startsWith(.name, "Sepal")) mean(.x))
Sepal.Length  Sepal.Width 
    5.843333     3.057333 
> 
> # A more realistic example: split a data frame into pieces, fit a
> # model to each piece, summarise and extract R^2
> mtcars %>%
+     split(.$cyl) %>%
+     to_list(summary(lm(mpg ~ wt, data = .x))) %>%
+     to_vec(.x$r.squared)
        4         6         8 
0.5086326 0.4645102 0.4229655 
> 
> # If each element of the output is a data frame, use
> # to_df to row-bind them together:
> mtcars %>%
+     split(.$cyl) %>%
+     to_list(lm(mpg ~ wt, data = .x)) %>%
+     to_df(c(cyl = .name, coef(.x)))
   cyl      (Intercept)                wt
1:   4 39.5711960130377 -5.64702526124227
2:   6 28.4088445131955 -2.78010593915529
3:   8 23.8680290759995 -2.19243792644972
> 
> ## Not run: 
> ##D # read all csv files in "data" to data.frame
> ##D all_files = dir("data", pattern = "csv$", full.names = TRUE) %>%
> ##D     to_df(fread,
> ##D           idvalue = basename(.x),
> ##D           idname = "filename",
> ##D           trace = "pb"
> ##D           )
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("vlookup")
> ### * vlookup
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vlookup
> ### Title: Look up values in dictionary.
> ### Aliases: vlookup xlookup
> 
> ### ** Examples
> 
> # with data.frame
> dict = data.frame(num=1:26, small=letters, cap=LETTERS)
> vlookup(1:3, dict)
[1] "a" "b" "c"
> vlookup(c(45,1:3,58), dict, result_column='cap')
[1] NA  "A" "B" "C" NA 
> vlookup(c(45,1:3,58), dict, result_column='cap', no_match = "Not found")
[1] "Not found" "A"         "B"         "C"         "Not found"
> 
> # the same with xlookup
> xlookup(1:3, dict$num, dict$small)
[1] "a" "b" "c"
> xlookup(c(45,1:3,58), dict$num, dict$cap)
[1] NA  "A" "B" "C" NA 
> xlookup(c(45,1:3,58), dict$num, dict$cap, no_match = "Not found")
[1] "Not found" "A"         "B"         "C"         "Not found"
> 
> 
> # example from base 'merge'
> authors = data.table(
+     surname = c("Tukey", "Venables", "Tierney", "Ripley", "McNeil"),
+     nationality = c("US", "Australia", "US", "UK", "Australia"),
+     deceased = c("yes", rep("no", 4))
+ )
> 
> books = data.table(
+     surname = c("Tukey", "Venables", "Tierney",
+                 "Ripley", "Ripley", "McNeil", "R Core"),
+     title = c("Exploratory Data Analysis",
+               "Modern Applied Statistics ...",
+               "LISP-STAT",
+               "Spatial Statistics", "Stochastic Simulation",
+               "Interactive Data Analysis",
+               "An Introduction to R")
+ )
> 
> let(books,
+      c("author_nationality", "author_deceased") := vlookup(surname,
+              dict = authors,
+              result_column = 2:3
+          )
+ )[]
    surname                         title author_nationality author_deceased
1:    Tukey     Exploratory Data Analysis                 US             yes
2: Venables Modern Applied Statistics ...          Australia              no
3:  Tierney                     LISP-STAT                 US              no
4:   Ripley            Spatial Statistics                 UK              no
5:   Ripley         Stochastic Simulation                 UK              no
6:   McNeil     Interactive Data Analysis          Australia              no
7:   R Core          An Introduction to R               <NA>            <NA>
> 
> # Just for fun. Examples borrowed from Microsoft Excel.
> # It is not the R way of doing things.
> 
> # Example 2
> 
> ex2 = fread("
+     Item_ID Item Cost Markup
+     ST-340 Stroller 145.67  0.30
+     BI-567 Bib 3.56  0.40
+     DI-328 Diapers  21.45  0.35
+     WI-989 Wipes  5.12  0.40
+     AS-469 Aspirator 2.56  0.45
+ ")
> 
> # Calculates the retail price of diapers by adding the markup percentage to the cost.
> vlookup("DI-328", ex2, 3) * (1 + vlookup("DI-328", ex2, 4)) # 28.9575
[1] 28.9575
> 
> # Calculates the sale price of wipes by subtracting a specified discount from
> # the retail price.
> (vlookup("WI-989", ex2, "Cost") * (1 + vlookup("WI-989", ex2, "Markup"))) * (1 - 0.2)  # 5.7344
[1] 5.7344
> 
> A2 = ex2[["Item_ID"]][1]
> A3 = ex2[["Item_ID"]][2]
> 
> # If the cost of an item is greater than or equal to $20.00, displays the string
> # "Markup is nn%"; otherwise, displays the string "Cost is under $20.00".
> ifelse(vlookup(A2, ex2, "Cost") >= 20,
+        paste0("Markup is " , 100 * vlookup(A2, ex2, "Markup"),"%"),
+        "Cost is under $20.00") # Markup is 30%
[1] "Markup is 30%"
> 
> 
> # If the cost of an item is greater than or equal to $20.00, displays the string
> # Markup is nn%"; otherwise, displays the string "Cost is $n.nn".
> ifelse(vlookup(A3, ex2, "Cost") >= 20,
+        paste0("Markup is: " , 100 * vlookup(A3, ex2, "Markup") , "%"),
+        paste0("Cost is $", vlookup(A3, ex2, "Cost"))) #Cost is $3.56
[1] "Cost is $3.56"
> 
> 
> # Example 3
> 
> ex3 = fread('
+     ID  Last_name  First_name  Title Birth_date
+     1 Davis Sara "Sales Rep."  12/8/1968
+     2 Fontana Olivier "V.P. of Sales" 2/19/1952
+     3 Leal Karina "Sales Rep." 8/30/1963
+     4 Patten Michael "Sales Rep." 9/19/1958
+     5 Burke Brian "Sales Mgr." 3/4/1955
+     6 Sousa Luis "Sales Rep."  7/2/1963
+ ')
> 
> # If there is an employee with an ID of 5, displays the employee's last name;
> # otherwise, displays the message "Employee not found".
> vlookup(5, ex3, "Last_name", no_match = "Employee not found") # Burke
[1] "Burke"
> 
> # Many employees
> vlookup(1:10, ex3, "Last_name", no_match =  "Employee not found")
 [1] "Davis"              "Fontana"            "Leal"              
 [4] "Patten"             "Burke"              "Sousa"             
 [7] "Employee not found" "Employee not found" "Employee not found"
[10] "Employee not found"
> 
> # For the employee with an ID of 4, concatenates the values of three cells into
> # a complete sentence.
> paste0(vlookup(4, ex3, "First_name"), " ",
+        vlookup(4, ex3, "Last_name"), " is a ",
+        vlookup(4, ex3, "Title")) # Michael Patten is a Sales Rep.
[1] "Michael Patten is a Sales Rep."
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.137 0.105 2.141 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
