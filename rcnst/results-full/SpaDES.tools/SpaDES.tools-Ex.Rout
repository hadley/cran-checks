
R Under development (unstable) (2019-10-15 r77294) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SpaDES.tools"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SpaDES.tools')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("adj")
> ### * adj
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adj
> ### Title: Fast 'adjacent' function, and Just In Time compiled version
> ### Aliases: adj
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> a <- raster(extent(0, 1000, 0, 1000), res = 1)
> sam <- sample(1:length(a), 1e4)
> numCol <- ncol(a)
> numCell <- ncell(a)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8)
> adj.new <- adj(numCol = numCol, numCell = numCell, cells = sam, directions = 8,
+                include = TRUE)
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("cir")
> ### * cir
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cir
> ### Title: Identify pixels in a circle or ring (donut) around an object.
> ### Aliases: cir
> 
> ### ** Examples
> 
> library(data.table)
> library(sp)
> library(raster)

Attaching package: ‘raster’

The following object is masked from ‘package:data.table’:

    shift

> library(quickPlot)
> 
> set.seed(1642)
> 
> # circle centred
> ras <- raster(extent(0, 15, 0, 15), res = 1, val = 0)
> middleCircle <- cir(ras)
> ras[middleCircle[, "indices"]] <- 1
> circlePoints <- SpatialPoints(middleCircle[, c("x", "y")])
> if (interactive()) {
+   clearPlot()
+   Plot(ras)
+   Plot(circlePoints, addTo = "ras")
+ }
> 
> # circles non centred
> ras <- randomPolygons(ras, numTypes = 4)
ERROR: modification of compiler constant of type character, length 4
ERROR: the modified value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
attr(,".match.hash")
<hash table>
ERROR: the original value of the constant is:
[1] "includePixel" "excludePixel" "includeRing"  "excludeRing" 
ERROR: the modified constant is at index 24
ERROR: the modified constant is in this function body:
{
    if (!is.null(neighProbs)) {
        if (isTRUE(allowOverlap)) 
            stop("Can't use neighProbs and allowOverlap = TRUE together")
    }
    if (!is.null(mapID)) {
        warning("mapID is deprecated, use id")
        id <- mapID
    }
    if (!quick) {
        allowedRules <- c("includePixel", "excludePixel", "includeRing", 
            "excludeRing")
        if (!any(stopRuleBehavior %fin% allowedRules)) 
            stop("stopRuleBehaviour must be one of \"", paste(allowedRules, 
                collapse = "\", \""), "\".")
    }
    spreadStateExists <- is(spreadState, "data.table")
    spreadProbLaterExists <- TRUE
    if (!is(spreadProbLater, "Raster")) {
        if (anyNA(spreadProbLater)) {
            spreadProbLaterExists <- FALSE
            spreadProbLater <- spreadProb
        }
    }
    if (any(is.na(loci))) {
        if (!spreadStateExists) 
            loci <- (nrow(landscape)/2L + 0.5) * ncol(landscape)
    }
    if (length(loci) == 0) 
        stop("No loci. Nothing to do")
    if (any(!is.na(maxSize))) {
        msEqZero <- maxSize < 1
        if (any(msEqZero)) {
            loci <- loci[!msEqZero]
            maxSize <- maxSize[!msEqZero]
        }
    }
    if (spreadStateExists) {
        keepers <- spreadState$active == TRUE
        loci <- initialActiveCells <- spreadState[keepers, indices]
        initialLoci <- unique(spreadState$initialLocus)
    }
    else {
        initialLoci <- loci
    }
    if (!quick) {
        if (is(spreadProbLater, "RasterLayer") | is(spreadProb, 
            "Rasterlayer")) {
            if ((minValue(spreadProb) > 1L) || (maxValue(spreadProb) < 
                0L) || (maxValue(spreadProb) > 1L) || (minValue(spreadProb) < 
                0L)) {
                relativeSpreadProb <- TRUE
            }
            if (spreadProbLaterExists) 
                if (((minValue(spreadProbLater) > 1L) || (maxValue(spreadProbLater) < 
                  0L) || (maxValue(spreadProbLater) > 1L) || 
                  (minValue(spreadProbLater) < 0L))) {
                  relativeSpreadProb <- TRUE
                }
        }
        else {
            if (!all(inRange(spreadProb))) {
                relativeSpreadProb <- TRUE
                stop("spreadProb is not a probability")
            }
            if (spreadProbLaterExists) {
                relativeSpreadProb <- TRUE
                if (!all(inRange(spreadProbLater))) 
                  stop("spreadProbLater is not a probability")
            }
        }
    }
    ncells <- ncell(landscape)
    if (allowOverlap | returnDistances | spreadStateExists) {
        if (spreadStateExists) {
            spreads <- as.matrix(spreadState[, list(initialLocus, 
                indices, id, active)])
        }
        else {
            spreads <- cbind(initialLocus = initialLoci, indices = initialLoci, 
                id = 1:length(loci), active = 1)
        }
    }
    else {
        if (lowMemory) {
            spreads <- ff(vmode = "short", 0, length = ncells)
        }
        else {
            spreads <- vector("integer", ncells)
        }
    }
    n <- 1L
    if (circle | !is.na(asymmetry)) {
        if (circle) 
            directions <- 8L
        initialLociXY <- cbind(id = seq_along(initialLoci), xyFromCell(landscape, 
            initialLoci))
        id <- TRUE
        if (allowOverlap | returnDistances) {
            spreads <- cbind(spreads, dists = 0)
        }
    }
    otherVars <- list(...)
    anyList <- unlist(lapply(otherVars, is.list))
    if (any(anyList)) {
        otherVarsLists <- unlist(unname(otherVars), recursive = FALSE)
        otherVars[anyList] <- NULL
        otherVars <- append(otherVars, otherVarsLists)
    }
    if (is.function(stopRule)) {
        id <- TRUE
        stopRuleObjs <- names(formals(stopRule))
        if (!quick) {
            if (any(is.na(match(stopRuleObjs, c("id", "landscape", 
                "cells", names(otherVars)))))) {
                stop("Arguments in stopRule not valid.\n", "The function definition must be a function of built-in options,", 
                  " (id, landscape, or cells) or user supplied variables.", 
                  " If user supplied, the variables", " must be passed as named vectors, or lists or data.frames.", 
                  " See examples.")
            }
        }
        landRasNeeded <- any(stopRuleObjs == "landscape")
        colNamesPotentials <- c("id", "landscape"[landRasNeeded], 
            "cells", "prev")
        argNames <- c(colNamesPotentials, names(otherVars))
        whArgs <- match(names(formals(stopRule)), argNames)
        rasters <- unlist(lapply(otherVars[names(otherVars)], 
            function(x) is(x, "Raster")))
        if (any(rasters)) {
            for (i in 1:which(rasters)) {
                otherVars[[names(rasters[i])]] <- otherVars[[names(rasters[i])]][]
            }
        }
        landRas <- landscape[]
    }
    if (!allowOverlap & !returnDistances) {
        if (id | returnIndices | relativeSpreadProb) {
            if (!spreadStateExists) {
                spreads[loci] <- 1L:length(loci)
            }
        }
        else {
            spreads[loci] <- n
        }
        spreadsIndices <- unname(loci)
    }
    if (is(spreadProb, "Raster")) {
    }
    else if (is.numeric(spreadProb)) {
        if (is(mask, "Raster")) {
            spreadProb <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProb)
        }
    }
    if (is(spreadProbLater, "Raster")) {
    }
    else if (is.numeric(spreadProbLater)) {
        if (is(mask, "Raster")) {
            spreadProbLater <- raster(extent(landscape), res = res(landscape), 
                vals = spreadProbLater)
        }
    }
    if (is(mask, "Raster")) {
        spreadProbLater[mask[] == 1L] <- 0L
        spreadProb[mask[] == 1L] <- 0L
    }
    if (spreadStateExists) {
        if (allowOverlap | returnDistances) {
            stop("Using spreadState with either allowOverlap = TRUE", 
                " or returnDistances = TRUE is not implemented")
        }
        else {
            if (sum(colnames(spreadState) %fin% c("indices", 
                "id", "active", "initialLocus")) != 4) {
                stop("spreadState must have at least columns: ", 
                  "indices, id, active, and initialLocus.")
            }
        }
    }
    if (!quick) 
        if (any(loci > ncells)) 
            stop("loci indices are not on landscape")
    if (any(!is.na(maxSize))) {
        if (!is.integer(maxSize)) 
            maxSize <- floor(maxSize)
        if (spreadStateExists) {
            sizeAll <- spreadState[, list(len = .N), by = id]
            size <- c(sizeAll[, len])
        }
        else {
            maxSize <- rep_len(maxSize, length(loci))
            size <- rep_len(1L, length(loci))
        }
    }
    else {
        maxSize <- ncells
        size <- length(loci)
    }
    noMaxSize <- all(maxSize >= ncells)
    if (is.null(neighProbs)) {
        numNeighs <- NULL
    }
    if (!exists("numRetries", envir = .pkgEnv)) 
        assign("numRetries", rep(0, length(initialLoci)), envir = .pkgEnv)
    toColumn <- c("to", "indices")
    while (length(loci) & (n <= iterations)) {
        if (!is.null(neighProbs)) {
            numNeighs <- if (is.list(neighProbs)) {
                unlist(lapply(neighProbs, function(x) {
                  sample.int(length(x), size = 1, replace = TRUE, 
                    prob = x)
                }))
            }
            else {
                sample.int(length(neighProbs), size = length(loci), 
                  replace = TRUE, prob = neighProbs)
            }
        }
        if (allowOverlap | returnDistances | spreadStateExists) {
            whActive <- spreads[, "active"] == 1
            potentials <- adj(landscape, loci, directions, pairs = TRUE, 
                id = spreads[whActive, "id"])
            spreads[whActive, "active"] <- 0
            potentials <- cbind(potentials, active = 1)
        }
        else {
            if (id | returnIndices | circle | relativeSpreadProb | 
                !is.null(neighProbs)) {
                potentials <- adj(landscape, loci, directions, 
                  pairs = TRUE)
            }
            else {
                potentials <- cbind(NA, adj(landscape, loci, 
                  directions, pairs = FALSE))
            }
        }
        if (circle) 
            potentials <- cbind(potentials, dists = 0)
        if (allowOverlap | returnDistances | spreadStateExists) {
            if (TRUE) {
                spreadsDT <- data.table(spreads)
                potentialsDT <- data.table(potentials)
                potentialsDT[, `:=`(initialLocus, initialLoci[potentialsDT$id])]
                colnamesPDT <- colnames(potentialsDT)
                whIL <- which(colnamesPDT == "initialLocus")
                whFrom <- which(colnamesPDT == "from")
                setcolorder(potentialsDT, c(colnamesPDT[whIL], 
                  colnamesPDT[-c(whIL, whFrom)], colnamesPDT[whFrom]))
                setnames(potentialsDT, old = "to", new = "indices")
                d <- rbindlist(list(spreadsDT, potentialsDT), 
                  fill = TRUE)
                d <- data.table(d)
                setkey(d, "id")
                d[, `:=`(duplicated, duplicated(indices)), by = id]
                d <- d[duplicated == 0 & active == 1]
                set(d, , "duplicated", NULL)
                potentials <- as.matrix(d)
            }
            else {
                potentialsFrom <- potentials[, "from"]
                colnames(potentials) <- colnames(spreads)
                potentials[, "initialLocus"] <- initialLoci[potentials[, 
                  "id"]]
                d <- rbind(spreads, potentials)
                d <- cbind(d, from = c(rep(NA, NROW(spreads)), 
                  potentialsFrom))
                ids <- as.integer(unique(d[, "id"]))
                d <- do.call(rbind, lapply(ids, function(id) {
                  cbind(d[d[, "id"] == id, , drop = FALSE], duplicated = duplicated(d[d[, 
                    "id"] == id, "indices"]))
                }))
                lastCol <- ncol(d)
                potentials <- d[d[, "duplicated"] == 0 & d[, 
                  "active"] == 1, , drop = FALSE][, -lastCol, 
                  drop = FALSE]
            }
        }
        else {
            keep <- spreads[potentials[, 2L]] == 0L
            potentials <- potentials[keep, , drop = FALSE]
        }
        if (n == 2) {
            spreadProb <- spreadProbLater
        }
        if (is.numeric(spreadProb)) {
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- rep(spreadProb, NROW(potentials))
                spreadProb <- spreadProbLater
            }
            else {
                if (length(spreadProb) > 1) {
                  spreadProbs <- spreadProb[potentials[, 2L]]
                }
                else {
                  spreadProbs <- rep(spreadProb, NROW(potentials))
                }
            }
        }
        else {
            if (n == 1 & spreadProbLaterExists) {
                spreadProbs <- spreadProb[][potentials[, 2L]]
                spreadProb <- spreadProbLater
            }
            else {
                spreadProbs <- spreadProb[][potentials[, 2L]]
            }
        }
        if (anyNA(spreadProbs)) 
            spreadProbs[is.na(spreadProbs)] <- 0
        if (!is.na(asymmetry)) {
            if (allowOverlap | returnDistances) {
                a <- cbind(id = potentials[, 3L], to = potentials[, 
                  2L], xyFromCell(landscape, potentials[, 2L]))
            }
            else {
                a <- cbind(id = spreads[potentials[, 1L]], to = potentials[, 
                  2L], xyFromCell(landscape, potentials[, 2L]))
            }
            d <- directionFromEachPoint(from = initialLociXY, 
                to = a)
            newSpreadProbExtremes <- (spreadProb[] * 2)/(asymmetry + 
                1) * c(1, asymmetry)
            angleQuality <- (cos(d[, "angles"] - rad(asymmetryAngle)) + 
                1)/2
            spreadProbs <- newSpreadProbExtremes[1] + (angleQuality * 
                diff(newSpreadProbExtremes))
            spreadProbs <- spreadProbs - diff(c(spreadProb[], 
                mean(spreadProbs)))
        }
        if (!is.null(neighProbs) | relativeSpreadProb) {
            aaa <- split(seq_along(potentials[, toColumn[spreadStateExists + 
                1]]), potentials[, "from"])
            if (length(aaa) != length(numNeighs)) {
                activeCellContinue <- loci %in% unique(potentials[, 
                  "from"])
                numNeighs <- numNeighs[activeCellContinue]
            }
            tmpA <- unlist(lapply(aaa, length))
            tmpB <- which(tmpA < numNeighs)
            if (length(tmpB) > 0) 
                numNeighs[tmpB] <- unname(tmpA[tmpB])
            if (relativeSpreadProb) {
                rescaledProbs <- tapply(spreadProbs, potentials[, 
                  "from"], function(x) {
                  x/sum(x, na.rm = TRUE)
                }, simplify = FALSE)
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x], 
                    prob = rescaledProbs[[x]])))
            }
            else {
                neighIndexToKeep <- unlist(lapply(seq_along(aaa), 
                  function(x) resample(aaa[[x]], size = numNeighs[x])))
            }
            potentials <- potentials[neighIndexToKeep, , drop = FALSE]
            spreadProbs <- spreadProbs[neighIndexToKeep]
            spreadProbs[spreadProbs > 0] <- 1
        }
        potentials <- potentials[runif(NROW(potentials)) <= spreadProbs, 
            , drop = FALSE]
        potentials <- potentials[sample.int(NROW(potentials)), 
            , drop = FALSE]
        if (!allowOverlap) {
            potentials <- potentials[!duplicated(potentials[, 
                2L]), , drop = FALSE]
        }
        n <- n + 1L
        if (length(potentials) > 0) {
            if (!missing(circle)) {
                if (circle) {
                  if (allowOverlap | returnDistances) {
                    a <- cbind(potentials, xyFromCell(landscape, 
                      potentials[, 2L]))
                  }
                  else {
                    a <- cbind(potentials, id = spreads[potentials[, 
                      "from"]], xyFromCell(landscape, potentials[, 
                      "to"]))
                  }
                  a <- a[, !(colnames(a) %fin% c("dists")), drop = FALSE]
                  d <- distanceFromEachPoint(initialLociXY, a, 
                    angles = asymmetry)
                  cMR <- (n - 1) * res(landscape)[1]
                  if (!any(is.na(circleMaxRadius))) {
                    if (any(circleMaxRadius <= ((n - 1) * res(landscape)[1]))) {
                      if (length(circleMaxRadius) > 1) {
                        cMR <- circleMaxRadius[d[, "id"]]
                      }
                      else {
                        cMR <- circleMaxRadius
                      }
                    }
                  }
                  potentials <- d[, !(colnames(d) %fin% c("x", 
                    "y")), drop = FALSE]
                  potentials <- potentials[(d[, "dists"] %<=% 
                    cMR), , drop = FALSE]
                }
            }
            events <- potentials[, 2L]
            if (!noMaxSize) {
                if (allowOverlap | returnDistances | spreadStateExists) {
                  len <- tabulate(potentials[, 3L], length(maxSize))
                }
                else {
                  len <- tabulate(spreads[potentials[, 1L]], 
                    length(maxSize))
                }
                if (any((size + len) > maxSize & size <= maxSize)) {
                  whichID <- which(size + len > maxSize)
                  toRm <- (size + len)[whichID] - maxSize[whichID]
                  for (i in 1:length(whichID)) {
                    if (allowOverlap | returnDistances | spreadStateExists) {
                      thisID <- which(potentials[, 3L] == whichID[i])
                    }
                    else {
                      thisID <- which(spreads[potentials[, 1L]] == 
                        whichID[i])
                    }
                    if (length(thisID)) 
                      potentials <- potentials[-resample(thisID, 
                        toRm[i]), , drop = FALSE]
                  }
                  events <- potentials[, 2L]
                }
                size <- pmin(size + len, maxSize)
            }
            if (is.function(stopRule) & length(events) > 0) {
                if (allowOverlap | returnDistances) {
                  prevCells <- cbind(id = spreads[, "id"], landscape = if (landRasNeeded) 
                    landRas[spreads[, "indices"]]
                  else NULL, cells = spreads[, "indices"], prev = 1)
                  eventCells <- cbind(id = potentials[, "id"], 
                    landscape = if (landRasNeeded) 
                      landRas[events]
                    else NULL, cells = events, prev = 0)
                }
                else {
                  whgtZero <- spreadsIndices
                  prevCells <- cbind(id = spreads[whgtZero], 
                    landscape = if (landRasNeeded) 
                      landRas[whgtZero]
                    else NULL, cells = whgtZero, prev = 1)
                  eventCells <- cbind(id = spreads[potentials[, 
                    1L]], landscape = if (landRasNeeded) 
                    landRas[potentials[, 2L]]
                  else NULL, cells = potentials[, 2L], prev = 0)
                }
                if (circle) {
                  prevCells <- cbind(prevCells, dist = NA)
                  eventCells <- cbind(eventCells, dist = potentials[, 
                    "dists"])
                }
                tmp <- rbind(prevCells[prevCells[, "id"] %fin% 
                  unique(eventCells[, "id"]), ], eventCells)
                ids <- unique(tmp[, "id"])
                shouldStopList <- lapply(ids, function(id) {
                  shortTmp <- tmp[tmp[, "id"] == id, ]
                  args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                    function(j) shortTmp[, j]))
                  names(args) <- colNamesPotentials
                  args <- append(args, otherVars)
                  do.call(stopRule, args[whArgs])
                })
                if (any(lapply(shouldStopList, length) > 1)) 
                  stop("stopRule does not return a length-one logical.", 
                    " Perhaps stopRule need indexing by cells or id?")
                shouldStop <- unlist(shouldStopList)
                names(shouldStop) <- ids
                if (any(shouldStop)) {
                  if (stopRuleBehavior != "includeRing") {
                    if (stopRuleBehavior != "excludeRing") {
                      whStop <- as.numeric(names(shouldStop)[shouldStop])
                      whStopAll <- tmp[, "id"] %fin% whStop
                      tmp2 <- tmp[whStopAll, ]
                      whStopEvents <- eventCells[, "id"] %fin% 
                        whStop
                      out <- lapply(whStop, function(id) {
                        tmp3 <- tmp2[tmp2[, "id"] == id, ]
                        newOnes <- tmp3[, "prev"] == 0
                        ord <- seq_along(newOnes)
                        if (sum(newOnes) > 1) {
                          ord[newOnes] <- sample(ord[newOnes])
                          if (circle) 
                            ord[newOnes] <- ord[newOnes][order(tmp3[ord[newOnes], 
                              "dist"])]
                          tmp3 <- tmp3[ord, ]
                        }
                        startLen <- sum(!newOnes)
                        addIncr <- 1
                        done <- FALSE
                        args <- append(list(id = id), lapply(colNamesPotentials[-1], 
                          function(j) {
                            tmp3[1:startLen, j]
                          }))
                        names(args) <- colNamesPotentials
                        args <- append(args, otherVars)
                        argsSeq <- seq_along(colNamesPotentials[-1]) + 
                          1
                        while (!done) {
                          args[argsSeq] <- lapply(colNamesPotentials[-1], 
                            function(j) {
                              unname(c(args[[j]], tmp3[(startLen + 
                                addIncr), j]))
                            })
                          done <- do.call(stopRule, args[whArgs])
                          addIncr <- addIncr + 1
                        }
                        if (stopRuleBehavior == "excludePixel") 
                          addIncr <- addIncr - 1
                        firstInd <- startLen + addIncr
                        lastInd <- NROW(tmp3)
                        sequ <- if (firstInd > lastInd) 
                          0
                        else firstInd:lastInd
                        tmp3[sequ, , drop = FALSE]
                      })
                      eventRm <- do.call(rbind, out)[, "cells"]
                      cellsKeep <- !(potentials[, 2L] %fin% eventRm)
                    }
                    else {
                      cellsKeep <- rep(FALSE, NROW(potentials))
                    }
                    potentials <- potentials[cellsKeep, , drop = FALSE]
                    events <- potentials[, 2L]
                    eventCells <- eventCells[cellsKeep, , drop = FALSE]
                  }
                  toKeepSR <- !(eventCells[, "id"] %fin% as.numeric(names(which((shouldStop)))))
                }
            }
            if (length(events) > 0) {
                if (allowOverlap | returnDistances | spreadStateExists) {
                  fromCol <- colnames(potentials) == "from"
                  spreads <- rbind(spreads, potentials[, !fromCol])
                  if ((returnDistances | spreadStateExists) & 
                    !allowOverlap) {
                    notDups <- !duplicated(spreads[, "indices"])
                    nrSpreads <- NROW(spreads)
                    nrPotentials <- NROW(potentials)
                    notDupsEvents <- notDups[-(1:(nrSpreads - 
                      nrPotentials))]
                    spreads <- spreads[notDups, , drop = FALSE]
                    events <- events[notDupsEvents]
                  }
                }
                else {
                  if (id | returnIndices | relativeSpreadProb) {
                    spreads[events] <- spreads[potentials[, 1L]]
                  }
                  else {
                    spreads[events] <- n
                  }
                  spreadsIndices <- unname(c(spreadsIndices, 
                    events))
                }
            }
            if (length(maxSize) > 1L) {
                if (exists("whichID", inherits = FALSE)) {
                  if (exists("toKeepSR", inherits = FALSE)) {
                    if (allowOverlap | returnDistances) {
                      maxSizeKeep <- !(spreads[spreads[, "active"] == 
                        1, "id"] %fin% whichID)
                      spreads <- spreads[c(rep(TRUE, sum(spreads[, 
                        "active"] == 0)), maxSizeKeep), ]
                    }
                    else {
                      maxSizeKeep <- !spreads[events] %fin% whichID
                    }
                    events <- events[maxSizeKeep]
                    toKeepSR <- toKeepSR[maxSizeKeep]
                  }
                  rm(whichID)
                }
            }
            else {
                if (all(size >= maxSize)) {
                  events <- NULL
                }
            }
            if (is.function(stopRule)) {
                if (exists("toKeepSR", inherits = FALSE)) {
                  events <- events[toKeepSR]
                  if (allowOverlap | returnDistances) {
                    spreads[c(rep(TRUE, sum(spreads[, "active"] == 
                      0)), !toKeepSR), "active"] <- 0
                  }
                  rm(toKeepSR)
                }
            }
        }
        else {
            events <- NULL
        }
        if (exactSizes) {
            if (all(get("numRetries", inherits = FALSE, envir = .pkgEnv) < 
                10)) {
                if (spreadStateExists) {
                  tooSmall <- tabulate(spreads[, "id"], length(maxSize)) < 
                    maxSize
                  inactive <- tabulate(spreads[spreads[, "active"] == 
                    1, "id"], length(maxSize)) == 0
                }
                else {
                  tooSmall <- tabulate(spreads, length(maxSize)) < 
                    maxSize
                  inactive <- tabulate(spreads[events], length(maxSize)) == 
                    0
                }
                needPersist <- tooSmall & inactive
                needPersistJump <- TRUE
                if (any(needPersist)) {
                  assign("numRetries", envir = .pkgEnv, get("numRetries", 
                    inherits = FALSE, envir = .pkgEnv) + needPersist)
                  if (spreadStateExists) {
                    whSmallInactive <- which(tooSmall & inactive)
                    spreadsSmallInactive <- spreads[spreads[, 
                      "id"] %in% whSmallInactive, , drop = FALSE]
                    if (needPersistJump) {
                      message("Jumping to new active location, up to 1000 m away")
                      mmm <- rings(landscape, loci = spreadsSmallInactive[, 
                        "indices"], maxRadius = 1000, minRadius = 1, 
                        returnIndices = TRUE)
                      wh <- mmm[, list(whKeepLoci = resample(.I, 
                        1)), by = id]$whKeepLoci
                    }
                    else {
                      for (whSI in whSmallInactive) {
                        wh <- which(spreads[, "id"] == whSI)
                        wh <- tail(wh, 2)
                        keepLoci <- spreads[wh, "indices"]
                        events <- c(keepLoci, events)
                        spreads[wh, "active"] <- 1
                      }
                    }
                  }
                  else {
                    keepLoci <- spreads[loci] %fin% which(tooSmall & 
                      inactive)
                    events <- c(loci[keepLoci], events)
                  }
                }
            }
        }
        if (is.na(persistence) | persistence == 0L) {
            loci <- NULL
        }
        else {
            if (inRange(persistence)) {
                loci <- loci[runif(length(loci)) <= persistence]
            }
            else {
                stop("Unsupported type: persistence")
            }
        }
        if (plot.it) {
            if (n == 2 & !spreadStateExists) 
                clearPlot()
            if (allowOverlap | returnDistances) {
                spreadsDT <- data.table(spreads)
                hab2 <- landscape
                hab2[] <- 0
                pixVal <- spreadsDT[, sum(id), by = indices]
                hab2[pixVal$indices] <- pixVal$V1
                Plot(hab2, legendRange = c(0, sum(seq_along(initialLoci))))
            }
            else {
                plotCur <- raster(landscape)
                plotCur <- setValues(plotCur, spreads)
                Plot(plotCur)
            }
        }
        loci <- c(loci, events)
    }
    if (!allowOverlap & !returnDistances & !spreadStateExists) {
        if (lowMemory) {
            wh <- ffwhich(spreads, spreads > 0) %>% as.ram()
            if (returnIndices) {
                completed <- data.table(indices = wh, id = spreads[wh], 
                  active = FALSE)
                if (NROW(potentials) > 0) {
                  active <- data.table(indices = potentials[, 
                    2L], id = spreads[potentials[, 1L]], active = TRUE)
                }
                else {
                  active <- data.table(indices = numeric(0), 
                    id = numeric(0), active = logical(0))
                }
            }
        }
        else {
            wh <- if (spreadStateExists) {
                c(spreadState[!keepers]$indices, spreadsIndices)
            }
            else {
                spreadsIndices
            }
            if (returnIndices) {
                completed <- wh %>% data.table(indices = ., id = spreads[.], 
                  active = FALSE)
                if (NROW(potentials) > 0) {
                  active <- data.table(indices = potentials[, 
                    2L], id = spreads[potentials[, 1L]], active = TRUE)
                }
                else {
                  active <- data.table(indices = numeric(0), 
                    id = numeric(0), active = logical(0))
                }
            }
        }
    }
    if (returnIndices) {
        if (allowOverlap | returnDistances | spreadStateExists) {
            keepCols <- c(3, 1, 2, 4)
            if (circle) 
                keepCols <- c(keepCols, 5)
            allCells <- data.table(spreads[, keepCols, drop = FALSE])
            set(allCells, , j = "active", as.logical(allCells$active))
            setkeyv(allCells, "id")
        }
        else {
            allCells <- rbindlist(list(active, completed))
            if (spreadStateExists) {
                initEventID <- unique(spreadState$id)
            }
            else {
                initEventID <- allCells[indices %fin% initialLoci, 
                  id]
            }
            if (!all(is.na(initialLoci))) {
                dtToJoin <- data.table(id = sort(initEventID), 
                  initialLocus = initialLoci)
            }
            else {
                dtToJoin <- data.table(id = numeric(0), initialLocus = numeric(0))
            }
            setkeyv(dtToJoin, "id")
            setkeyv(allCells, "id")
            allCells <- dtToJoin[allCells]
        }
        allCells[]
        if (exists("numRetries", envir = .pkgEnv)) {
            if (sum(allCells$active) == 0) 
                rm("numRetries", envir = .pkgEnv)
        }
        return(allCells)
    }
    landscape[] <- 0
    landscape@legend@colortable <- logical(0)
    if (allowOverlap | returnDistances) {
        if (returnDistances & !allowOverlap) {
            landscape[spreads[, "indices"]] <- spreads[, "dists"]
        }
        else {
            spreadsDT <- data.table(spreads)
            if (returnDistances & allowOverlap) {
                pixVal <- spreadsDT[, min(dists), by = indices]
                message("returnDistances is TRUE, allowOverlap is TRUE, but returnIndices is FALSE; ", 
                  "returning minimum distance raster.")
            }
            else {
                pixVal <- spreadsDT[, sum(id), by = indices]
            }
            landscape[pixVal$indices] <- pixVal$V1
        }
    }
    else {
        landscape[wh] <- spreads[wh]
        if (exists("potentials")) 
            if (NROW(potentials) > 0) 
                landscape[potentials[, 1L]] <- spreads[potentials[, 
                  2L]]
    }
    return(landscape)
}
S4 Method spread:SpaDES.tools defined in namespace SpaDES.tools with signature RasterLayer has this body.
> n <- 2
> agent <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                                       y = stats::runif(n, xmin(ras), xmax(ras))))
> 
> cirs <- cir(ras, agent, maxRadius = 15, simplify = TRUE)
> cirsSP <- SpatialPoints(coords = cirs[, c("x", "y")])
> cirsRas <- raster(ras)
> cirsRas[] <- 0
> cirsRas[cirs[, "indices"]] <- 1
> 
> if (interactive()) {
+   clearPlot()
+   Plot(ras)
+   Plot(cirsRas, addTo = "ras", cols = c("transparent", "#00000055"))
+   Plot(agent, addTo = "ras")
+   Plot(cirsSP, addTo = "ras")
+ }
> 
> # Example comparing rings and cir
> a <- raster(extent(0, 30, 0, 30), res = 1)
> hab <- gaussMap(a, speedup = 1) # if raster is large (>1e6 pixels) use speedup > 1
Loading required namespace: RandomFields
> radius <- 4
> n <- 2
> coords <- SpatialPoints(coords = cbind(x = stats::runif(n, xmin(hab), xmax(hab)),
+                                        y = stats::runif(n, xmin(hab), xmax(hab))))
> 
> # cirs
> cirs <- cir(hab, coords, maxRadius = rep(radius, length(coords)), simplify = TRUE)
> 
> # rings
> loci <- cellFromXY(hab, coordinates(coords))
> cirs2 <- rings(hab, loci, maxRadius = radius, minRadius = radius - 1, returnIndices = TRUE)
> 
> # Plot both
> ras1 <- raster(hab)
> ras1[] <- 0
> ras1[cirs[, "indices"]] <- cirs[, "id"]
> 
> ras2 <- raster(hab)
> ras2[] <- 0
> ras2[cirs2$indices] <- cirs2$id
> if (interactive()) {
+   clearPlot()
+   Plot(ras1, ras2)
+ }
> 
> a <- raster(extent(0, 100, 0, 100), res = 1)
> hab <- gaussMap(a, speedup = 1)
> cirs <- cir(hab, coords, maxRadius = 44, minRadius = 0)
> ras1 <- raster(hab)
> ras1[] <- 0
> cirsOverlap <- data.table(cirs)[, list(sumIDs = sum(id)), by = indices]
> ras1[cirsOverlap$indices] <- cirsOverlap$sumIDs
> if (interactive()) {
+   clearPlot()
+   Plot(ras1)
+ }
> 
> # Provide a specific set of angles
> ras <- raster(extent(0, 330, 0, 330), res = 1)
> ras[] <- 0
> n <- 2
> coords <- cbind(x = stats::runif(n, xmin(ras), xmax(ras)),
+                 y = stats::runif(n, xmin(ras), xmax(ras)))
> circ <- cir(ras, coords, angles = seq(0, 2 * pi, length.out = 21),
+             maxRadius = 200, minRadius = 0, returnIndices = FALSE,
+             allowOverlap = TRUE, returnAngles = TRUE)
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’,
  ‘package:data.table’

> nameEx("directions")
> ### * directions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: directionFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: directionFromEachPoint .pointDirection
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> N <- 2
> dirRas <- raster(extent(0,40,0,40), res = 1)
> coords <- cbind(x = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 y = round(runif(N, xmin(dirRas), xmax(dirRas))) + 0.5,
+                 id = 1:N)
> 
> dirs1 <- directionFromEachPoint(from = coords, landscape = dirRas)
> library(CircStats)
Loading required package: MASS

Attaching package: ‘MASS’

The following objects are masked from ‘package:raster’:

    area, select

Loading required package: boot
> dirs1[, "angles"] <- deg(dirs1[,"angles"] %% (2*pi))
> indices <- cellFromXY(dirRas,dirs1[, c("x", "y")])
> minDir <- tapply(dirs1[, "angles"], indices, function(x) min(x)) # minimum angle
> dirRas[] <- as.vector(minDir)
> if (interactive()) {
+   clearPlot()
+   Plot(dirRas)
+   library(sp)
+   start <- SpatialPoints(coords[, c("x", "y"), drop = FALSE])
+   Plot(start, addTo = "dirRas")
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:CircStats’, ‘package:boot’, ‘package:MASS’,
  ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("distanceFromEachPoint")
> ### * distanceFromEachPoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: distanceFromEachPoint
> ### Title: Calculate distances and directions between many points and many
> ###   grid cells
> ### Aliases: distanceFromEachPoint
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> library(quickPlot)
> 
> n <- 2
> distRas <- raster(extent(0, 40, 0, 40), res = 1)
> coords <- cbind(x = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5,
+                 y = round(runif(n, xmin(distRas), xmax(distRas))) + 0.5)
> 
> # inverse distance weights
> dists1 <- distanceFromEachPoint(coords, landscape = distRas)
> indices <- cellFromXY(distRas, dists1[, c("x", "y")])
> invDist <- tapply(dists1[, "dists"], indices, function(x) sum(1 / (1 + x))) # idw function
> distRas[] <- as.vector(invDist)
> if (interactive()) {
+   clearPlot()
+   Plot(distRas)
+ }
> 
> # With iterative summing via cumulativeFn to keep memory use low, with same result
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = distRas, cumulativeFn = `+`)
> idwRaster <- raster(distRas)
> idwRaster[] <- dists1[, "val"]
> if (interactive()) Plot(idwRaster)
> 
> all(idwRaster[] == distRas[]) # TRUE
[1] TRUE
> 
> # A more complex example of cumulative inverse distance sums, weighted by the value
> #  of the origin cell
> ras <- raster(extent(0, 34, 0, 34), res = 1, val = 0)
> rp <- randomPolygons(ras, numTypes = 10) ^ 2
> n <- 15
> cells <- sample(ncell(ras), n)
> coords <- xyFromCell(ras, cells)
> distFn <- function(landscape, fromCell, dist) landscape[fromCell] / (1 + dist)
> 
> #beginCluster(3) # can do parallel
> dists1 <- distanceFromEachPoint(coords[, c("x", "y"), drop = FALSE],
+                                 landscape = rp, distFn = distFn, cumulativeFn = `+`)
> #endCluster() # if beginCluster was run
> 
> idwRaster <- raster(ras)
> idwRaster[] <- dists1[, "val"]
> if (interactive()) {
+   clearPlot()
+   Plot(rp, idwRaster)
+   sp1 <- SpatialPoints(coords)
+   Plot(sp1, addTo = "rp")
+   Plot(sp1, addTo = "idwRaster")
+ }
> 
> 
> 
> cleanEx()

detaching ‘package:quickPlot’, ‘package:raster’, ‘package:sp’

> nameEx("dwrpnorm2")
> ### * dwrpnorm2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dwrpnorm2
> ### Title: Vectorized wrapped normal density function
> ### Aliases: dwrpnorm2
> 
> ### ** Examples
> 
> # Values for which to evaluate density
> theta <- c(1:500) * 2 * pi / 500
> # Compute wrapped normal density function
> density <- c(1:500)
> for(i in 1:500) density[i] <- dwrpnorm2(theta[i], pi, .75)
> if (interactive()) plot(theta, density)
> # Approximate area under density curve
> sum(density * 2 * pi / 500)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("gaussmap")
> ### * gaussmap
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gaussMap
> ### Title: Produce a 'raster' of a random Gaussian process.
> ### Aliases: gaussMap
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if (require(RandomFields)) {
> ##D   library(raster)
> ##D   nx <- ny <- 100L
> ##D   r <- raster(nrows = ny, ncols = nx, xmn = -nx/2, xmx = nx/2, ymn = -ny/2, ymx = ny/2)
> ##D   speedup <- max(1, nx/5e2)
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, speedup = speedup, inMemory = TRUE)
> ##D   if (interactive()) Plot(map1)
> ##D 
> ##D   # with non-default method
> ##D   map1 <- gaussMap(r, scale = 300, var = 0.03, method = "RMgauss")
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("heading")
> ### * heading
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: heading
> ### Title: Heading between spatial points.
> ### Aliases: heading heading,SpatialPoints,SpatialPoints-method
> ###   heading,matrix,matrix-method heading,matrix,SpatialPoints-method
> ###   heading,SpatialPoints,matrix-method
> 
> ### ** Examples
> 
> library(sp)
> N <- 10L                # number of agents
> x1 <- stats::runif(N, -50, 50) # previous X location
> y1 <- stats::runif(N, -50, 50) # previous Y location
> x0 <- stats::rnorm(N, x1, 5)   # current X location
> y0 <- stats::rnorm(N, y1, 5)   # current Y location
> 
> # using SpatialPoints
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> # using matrix
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> #using both
> prev <- SpatialPoints(cbind(x = x1, y = y1))
> curr <- matrix(c(x0, y0), ncol = 2, dimnames = list(NULL, c("x","y")))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> prev <- matrix(c(x1, y1), ncol = 2, dimnames = list(NULL, c("x","y")))
> curr <- SpatialPoints(cbind(x = x0, y = y0))
> heading(prev, curr)
 [1]  58.70553  26.49322 276.84424 228.06827  61.14567 218.67886 185.93288
 [8] 147.31021 120.20979  54.86510
> 
> 
> 
> 
> cleanEx()

detaching ‘package:sp’

> nameEx("inRange")
> ### * inRange
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inRange
> ### Title: Test whether a number lies within range '[a,b]'
> ### Aliases: inRange
> 
> ### ** Examples
> 
> set.seed(100)
> x <- stats::rnorm(4) # -0.50219235  0.13153117 -0.07891709  0.88678481
> inRange(x, 0, 1)
[1] FALSE  TRUE FALSE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("initiateAgents")
> ### * initiateAgents
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: initiateAgents
> ### Title: 'SELES' - Initiate agents
> ### Aliases: initiateAgents
> ###   initiateAgents,Raster,missing,missing,ANY,missing-method
> ###   initiateAgents,Raster,missing,Raster,ANY,missing-method
> ###   initiateAgents,Raster,numeric,missing,ANY,missing-method
> ###   initiateAgents,Raster,numeric,Raster,ANY,missing-method
> ###   initiateAgents,Raster,missing,missing,ANY,numeric-method
> 
> ### ** Examples
> 
> library(magrittr)
> library(raster)
Loading required package: sp

Attaching package: ‘raster’

The following object is masked from ‘package:magrittr’:

    extract

> library(quickPlot)
> 
> map <- raster(xmn = 0, xmx = 10, ymn = 0, ymx = 10, val = 0, res = 1)
NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files
> map <- gaussMap(map, scale = 1, var = 4, speedup = 1)
> pr <- probInit(map, p = (map/maxValue(map))^2)
> agents <- initiateAgents(map, 100, pr)
> if (interactive()) {
+   clearPlot()
+   Plot(map)
+   Plot(agents, addTo = "map")
+ }
> # Test that they are indeed selecting according to probabilities in pr
> library(data.table)

Attaching package: ‘data.table’

The following object is masked from ‘package:raster’:

    shift

> dt1 <- data.table(table(round(map[agents], 0)))
> setnames(dt1, old = "N", new = "count")
> dt2 <- data.table(table(round(map[], 0)))
> setnames(dt2, old = "N", new = "available")
> dt <-dt1[dt2, on = "V1"]  # join the counts and available data.tables
> setnames(dt, old = "V1", new = "mapValue")
> dt[, selection := count/available]
> dt[is.na(selection), selection := 0]
> if (interactive())
+   with(dt, {plot(mapValue, selection)})
> 
> # Note, can also produce a Raster representing agents,
> # then the number of points produced can't be more than
> # the number of pixels:
> agentsRas <- initiateAgents(map, 30, pr, asSpatialPoints = FALSE)
> if (interactive()) Plot(agentsRas)
> 
> if (require(dplyr) && getRversion() >= 3.4) {
+   # Check that the agents are more often at the higher probability areas based on pr
+   if (utils::packageVersion("raster") >= "2.8-11") {
+     out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+              dplyr::mutate(selectionRatio = Freq / Freq.1) %>%
+              dplyr::select(-layer.1, -Var1) %>%
+              dplyr::rename(Present = Freq, Avail = Freq.1, Type = layer.2)
+   } else {
+     out <- data.frame(stats::na.omit(crosstab(agentsRas, map)), table(round(map[]))) %>%
+              dplyr::mutate(selectionRatio = Freq/Freq.1) %>%
+              dplyr::select(-Var1, -Var1.1) %>%
+              dplyr::rename(Present = Freq, Avail = Freq.1, Type = Var2)
+   }
+   out
+ }
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:data.table’:

    between, first, last

The following objects are masked from ‘package:raster’:

    intersect, select, union

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

Warning in h(afun, place, origplace, call, cb, cntxt) :
  restarting interrupted promise evaluation
   Type Present Avail selectionRatio
1     0       1     1     1.00000000
2     0       0     3     0.00000000
3     1       3     5     0.60000000
4     1       0    17     0.00000000
5     2       4    19     0.21052632
6     2       1    23     0.04347826
7     3      14    18     0.77777778
8     3       3    11     0.27272727
9     4      14     1    14.00000000
10    4       5     2     2.50000000
11    5      13     1    13.00000000
12    5      10     3     3.33333333
13    6      10     5     2.00000000
14    6       8    17     0.47058824
15    7       9    19     0.47368421
16    7       2    23     0.08695652
17    8       1    18     0.05555556
18    8       0    11     0.00000000
19    9       1     1     1.00000000
20    9       1     2     0.50000000
> 
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’, ‘package:data.table’, ‘package:quickPlot’,
  ‘package:raster’, ‘package:sp’, ‘package:magrittr’

> nameEx("randomPolygons")
> ### * randomPolygons
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: randomPolygons
> ### Title: randomPolygons
> ### Aliases: randomPolygons randomPolygon randomPolygon.SpatialPoints
> ###   randomPolygon.matrix randomPolygon.SpatialPolygons
> 
> ### ** Examples
> 
> library(quickPlot)
> 
> set.seed(1234)
> Ras <- randomPolygons(numTypes = 5)
> if (interactive()) {
+   clearPlot()
+   Plot(Ras, cols = c("yellow", "dark green", "blue", "dark red"))
+ }
> 
> library(raster)
Loading required package: sp
> # more complex patterning, with a range of patch sizes
> a <- randomPolygons(numTypes = 400, raster(extent(0, 50, 0, 50), res = 1, vals = 0))
> a[a<320] <- 0
> a[a>=320] <- 1
> suppressWarnings(clumped <- clump(a)) # warning sometimes occurs, but not important
> aHist <- hist(table(getValues(clumped)), plot = FALSE)
> if (interactive()) {
+   clearPlot()
+   Plot(a)
+   Plot(aHist)
+ }
> 
> library(raster)
> b <- SpatialPoints(cbind(-110, 59))
> crs(b) <- sp::CRS("+init=epsg:4326")
NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files
> a <- randomPolygon(b, area = 1e6)
NOTE: rgdal::checkCRSArgs: no proj_defs.dat in PROJ.4 shared files
Error in CRS(paste("+proj=utm +zone=", zone, " ellps=WGS84", sep = "")) : 
  major axis or radius = 0 or not given
Calls: randomPolygon -> randomPolygon.SpatialPoints -> utmCRS -> CRS
Execution halted
