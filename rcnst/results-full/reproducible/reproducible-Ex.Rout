
R Under development (unstable) (2020-12-08 r79592) -- "Unsuffered Consequences"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "reproducible"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('reproducible')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Cache")
> ### * Cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Cache
> ### Title: Cache method that accommodates environments, S4 methods,
> ###   Rasters, & nested caching
> ### Aliases: Cache Cache,ANY-method
> 
> ### ** Examples
> 
> tmpDir <- file.path(tempdir())
> 
> # Basic use
> ranNumsA <- Cache(rnorm, 10, 16, cacheRepo = tmpDir)
> 
> # All same
> ranNumsB <- Cache(rnorm, 10, 16, cacheRepo = tmpDir) # recovers cached copy
  ...(Object to retrieve (f11fb1a2880f8060.rds))
     loaded cached result from previous rnorm call, 
> ranNumsD <- Cache(quote(rnorm(n = 10, 16)), cacheRepo = tmpDir) # recovers cached copy
  ...(Object to retrieve (f11fb1a2880f8060.rds))
     loaded cached result from previous rnorm call, 
> 
> ###############################################
> # experimental devMode
> ###############################################
> opt <- options("reproducible.useCache" = "devMode")
> clearCache(tmpDir, ask = FALSE)
> centralTendency <- function(x)
+   mean(x)
> funnyData <- c(1, 1, 1, 1, 10)
> uniqueUserTags <- c("thisIsUnique", "reallyUnique")
> ranNumsB <- Cache(centralTendency, funnyData, cacheRepo = tmpDir,
+                   userTags = uniqueUserTags) # sets new value to Cache
> showCache(tmpDir) # 1 unique artifact -- cacheId is 8be9cf2a072bdbb0515c5f0b3578f474
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
             cacheId              tagKey              tagValue
 1: 71cd24ec3b0d0cac        thisIsUnique          thisIsUnique
 2: 71cd24ec3b0d0cac        reallyUnique          reallyUnique
 3: 71cd24ec3b0d0cac            function       centralTendency
 4: 71cd24ec3b0d0cac               class               numeric
 5: 71cd24ec3b0d0cac         object.size                   984
 6: 71cd24ec3b0d0cac            accessed   2020-12-08 07:44:40
 7: 71cd24ec3b0d0cac             inCloud                 FALSE
 8: 71cd24ec3b0d0cac          resultHash                      
 9: 71cd24ec3b0d0cac   elapsedTimeDigest      0.001107454 secs
10: 71cd24ec3b0d0cac elapsedTimeFirstRun      0.003335953 secs
11: 71cd24ec3b0d0cac      otherFunctions                      
12: 71cd24ec3b0d0cac           preDigest    x:e4aa8de28dc6c1bb
13: 71cd24ec3b0d0cac           preDigest .FUN:d5f5f91cbb662db9
14: 71cd24ec3b0d0cac           file.size                   142
            createdDate
 1: 2020-12-08 07:44:40
 2: 2020-12-08 07:44:40
 3: 2020-12-08 07:44:40
 4: 2020-12-08 07:44:40
 5: 2020-12-08 07:44:40
 6: 2020-12-08 07:44:40
 7: 2020-12-08 07:44:40
 8: 2020-12-08 07:44:40
 9: 2020-12-08 07:44:40
10: 2020-12-08 07:44:40
11: 2020-12-08 07:44:40
12: 2020-12-08 07:44:40
13: 2020-12-08 07:44:40
14: 2020-12-08 07:44:40
> 
> # During development, we often redefine function internals
> centralTendency <- function(x)
+   median(x)
> # When we rerun, we don't want to keep the "old" cache because the function will
> #   never again be defined that way. Here, because of userTags being the same,
> #   it will replace the entry in the Cache, effetively overwriting it, even though
> #   it has a different cacheId
> ranNumsD <- Cache(centralTendency, funnyData, cacheRepo = tmpDir, userTags = uniqueUserTags)
 ------ devMode -------
This call to cache will replace
... artifact with cacheId 71cd24ec3b0d0cac
... different .FUN
 ------ end devMode -------
Overwriting Cache entry with userTags: 'thisIsUnique, reallyUnique, centralTendency'
> showCache(tmpDir) # 1 unique artifact -- cacheId is bb1195b40c8d37a60fd6004e5d526e6b
Cache size: 
  Total (including Rasters): 246 bytes
  Selected objects (not including Rasters): 246 bytes
             cacheId              tagKey              tagValue
 1: 632cd06f30e111be        thisIsUnique          thisIsUnique
 2: 632cd06f30e111be        reallyUnique          reallyUnique
 3: 632cd06f30e111be            function       centralTendency
 4: 632cd06f30e111be               class               numeric
 5: 632cd06f30e111be         object.size                   984
 6: 632cd06f30e111be            accessed   2020-12-08 07:44:42
 7: 632cd06f30e111be             inCloud                 FALSE
 8: 632cd06f30e111be          resultHash                      
 9: 632cd06f30e111be   elapsedTimeDigest      0.001384497 secs
10: 632cd06f30e111be elapsedTimeFirstRun      0.003486872 secs
11: 632cd06f30e111be      otherFunctions                      
12: 632cd06f30e111be           preDigest    x:e4aa8de28dc6c1bb
13: 632cd06f30e111be           preDigest .FUN:af11d20d957667d9
14: 632cd06f30e111be           file.size                   142
            createdDate
 1: 2020-12-08 07:44:42
 2: 2020-12-08 07:44:42
 3: 2020-12-08 07:44:42
 4: 2020-12-08 07:44:42
 5: 2020-12-08 07:44:42
 6: 2020-12-08 07:44:42
 7: 2020-12-08 07:44:42
 8: 2020-12-08 07:44:42
 9: 2020-12-08 07:44:42
10: 2020-12-08 07:44:42
11: 2020-12-08 07:44:42
12: 2020-12-08 07:44:42
13: 2020-12-08 07:44:42
14: 2020-12-08 07:44:42
> 
> # If it finds it by cacheID, doesn't matter what the userTags are
> ranNumsD <- Cache(centralTendency, funnyData, cacheRepo = tmpDir, userTags = "thisIsUnique")
  ...(Object to retrieve (632cd06f30e111be.rds))
     loaded cached result from previous centralTendency call, 
> 
> options(opt)
> 
> # For more in depth uses, see vignette
> ## Not run: 
> ##D   # To use Postgres, set environment variables with the required credentials
> ##D   if (requireNamespace("RPostgres")) {
> ##D     Sys.setenv(PGHOST = "server.url")
> ##D     Sys.setenv(PGPORT = 5432)
> ##D     Sys.setenv(PGDATABASE = "mydatabase")
> ##D     Sys.setenv(PGUSER = "mydbuser")
> ##D     Sys.setenv(PGPASSWORD = "mysecurepassword")
> ##D 
> ##D     conn <- DBI::dbConnect(RPostgres::Postgres())
> ##D     options("reproducible.conn" = conn)
> ##D 
> ##D     # Will use postgres for cache data table, and tempdir() for saved R objects
> ##D     Cache(rnorm, 1, cacheRepo = tempdir())
> ##D   }
> ##D 
> ##D   browseVignettes(package = "reproducible")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("CacheDigest")
> ### * CacheDigest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: CacheDigest
> ### Title: The exact digest function that 'Cache' uses
> ### Aliases: CacheDigest
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   a <- Cache(rnorm, 1)
> ##D   CacheDigest(list(rnorm, 1))
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Checksums")
> ### * Checksums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Checksums
> ### Title: Calculate checksum
> ### Aliases: Checksums Checksums,character,logical-method
> ###   Checksums,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D moduleName <- "my_module"
> ##D modulePath <- file.path("path", "to", "modules")
> ##D 
> ##D ## verify checksums of all data files
> ##D Checksums(moduleName, modulePath)
> ##D 
> ##D ## write new CHECKSUMS.txt file
> ##D 
> ##D # 1. verify that all data files are present (and no extra files are present)
> ##D list.files(file.path(modulePath, moduleName, "data"))
> ##D 
> ##D # 2. calculate file checksums and write to file (this will overwrite CHECKSUMS.txt)
> ##D Checksums(moduleName, modulePath, write = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("Copy")
> ### * Copy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Copy
> ### Title: Recursive copying of nested environments, and other "hard to
> ###   copy" objects
> ### Aliases: Copy Copy,ANY-method Copy,SQLiteConnection-method
> ###   Copy,data.table-method Copy,list-method Copy,refClass-method
> ###   Copy,data.frame-method Copy,Raster-method
> 
> ### ** Examples
> 
> e <- new.env()
> e$abc <- letters
> e$one <- 1L
> e$lst <- list(W = 1:10, X = runif(10), Y = rnorm(10), Z = LETTERS[1:10])
> ls(e)
[1] "abc" "lst" "one"
> 
> # 'normal' copy
> f <- e
> ls(f)
[1] "abc" "lst" "one"
> f$one
[1] 1
> f$one <- 2L
> f$one
[1] 2
> e$one ## uh oh, e has changed!
[1] 2
> 
> # deep copy
> e$one <- 1L
> g <- Copy(e)
> ls(g)
[1] "abc" "lst" "one"
> g$one
[1] 1
> g$one <- 3L
> g$one
[1] 3
> f$one
[1] 1
> e$one
[1] 1
> 
> ## Not run: 
> ##D setMethod("Copy", signature = "the class", # where = specify here if not in a package,
> ##D   definition = function(object, filebackendDir, ...) {
> ##D   # write deep copy code here
> ##D })
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("Path-class")
> ### * Path-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Path-class
> ### Title: Coerce a character string to a class "Path"
> ### Aliases: Path-class asPath asPath.character asPath.null
> 
> ### ** Examples
> 
> tmpf <- tempfile(fileext = ".csv")
> file.exists(tmpf)    ## FALSE
[1] FALSE
> tmpfPath <- asPath(tmpf)
> is(tmpf, "Path")     ## FALSE
[1] FALSE
> is(tmpfPath, "Path") ## TRUE
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("addChangedAttr")
> ### * addChangedAttr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .addChangedAttr
> ### Title: Add an attribute to an object indicating which named elements
> ###   change
> ### Aliases: .addChangedAttr .addChangedAttr,ANY-method
> 
> ### ** Examples
> 
> a <- 1
> .addChangedAttr(a) # does nothing because default method is just a pass through
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("assessDataType")
> ### * assessDataType
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: assessDataType
> ### Title: Assess the appropriate raster layer data type
> ### Aliases: assessDataType assessDataType.Raster
> ###   assessDataType.RasterStack assessDataType.default assessDataTypeGDAL
> 
> ### ** Examples
> 
> ## LOG1S
> library(raster)
Loading required package: sp
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- rep(c(0,1),50)
> assessDataType(ras)
[1] "LOG1S"
> 
> ras[] <- rep(c(TRUE,FALSE),50)
> assessDataType(ras)
[1] "LOG1S"
> 
> ras[] <- c(NA, NA, rep(c(0,1),49))
> assessDataType(ras)
[1] "LOG1S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- c(0, NaN, rep(c(0,1),49))
> assessDataType(ras)
[1] "LOG1S"
> 
> 
> ## INT1S
> ras[] <- -1:98
> assessDataType(ras)
[1] "INT1S"
> 
> ras[] <- c(NA, -1:97)
> assessDataType(ras)
[1] "INT1S"
> 
> ## INT1U
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- 1:100
> assessDataType(ras)
[1] "INT1U"
> 
> ras[] <- c(NA, 2:100)
> assessDataType(ras)
[1] "INT1U"
> 
> ## INT2U
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 64000, max = 65000))
> assessDataType(ras)
[1] "INT2U"
> 
> ## INT2S
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -32767, max = 32767))
> assessDataType(ras)
[1] "INT2S"
> 
> ras[54] <- NA
> assessDataType(ras)
[1] "INT2S"
> 
> ## INT4U
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 0, max = 500000000))
> assessDataType(ras)
[1] "INT4U"
> 
> ras[14] <- NA
> assessDataType(ras)
[1] "INT4U"
> 
> ## INT4S
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -200000000, max = 200000000))
> assessDataType(ras)
[1] "INT4S"
> 
> ras[14] <- NA
> assessDataType(ras)
[1] "INT4S"
> 
> ## FLT4S
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- runif(100, min = -10, max = 87)
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = 3.4e+28))
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 3.4e+26, max = 3.4e+28))
> assessDataType(ras)
[1] "FLT4S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = -1))
> assessDataType(ras)
[1] "FLT4S"
> 
> ## FLT8S
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- c(-Inf, 1, rep(c(0,1),49))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- c(Inf, 1, rep(c(0,1),49))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -1.7e+30, max = 1.7e+308))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 1.7e+30, max = 1.7e+308))
> assessDataType(ras)
[1] "FLT8S"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -1.7e+308, max = -1))
> assessDataType(ras)
[1] "FLT8S"
> 
> # stack
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- rep(c(0,1),50)
> ras1 <- raster(ncol = 10, nrow = 10)
> ras1[] <- round(runif(100, min = -1.7e+308, max = -1))
> sta <- stack(ras, ras1)
> assessDataType(sta)
[1] "LOG1S" "FLT8S"
> library(raster)
> 
> ## Byte
> ras <- raster(ncol = 10, nrow = 10)
> 
> ras[] <- 1:100
> assessDataTypeGDAL(ras)
[1] "Byte"
> 
> ras[] <- c(NA, 2:100)
> assessDataTypeGDAL(ras)
[1] "Byte"
> 
> ##Int16
> ras <- raster(ncol = 10, nrow = 10)
> 
> ras <- setValues(ras, -1:98)
> assessDataTypeGDAL(ras)
[1] "Int16"
> 
> ras[] <- c(NA, -1:97)
> assessDataTypeGDAL(ras)
[1] "Int16"
> 
> ras[] <- round(runif(100, min = -32767, max = 32767))
> assessDataTypeGDAL(ras)
[1] "Int16"
> 
> ## UInt16
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 64000, max = 65000))
> assessDataTypeGDAL(ras)
[1] "UInt16"
> 
> 
> ## UInt32
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 0, max = 500000000))
> assessDataTypeGDAL(ras)
[1] "UInt32"
> 
> ras[14] <- NA
> assessDataTypeGDAL(ras)
[1] "UInt32"
> 
> ## Int32
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -200000000, max = 200000000))
> assessDataTypeGDAL(ras)
[1] "Int32"
> 
> ras[14] <- NA
> assessDataTypeGDAL(ras)
[1] "Int32"
> 
> ## Float32
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- runif(100, min = -10, max = 87)
> assessDataTypeGDAL(ras)
[1] "Float32"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = 3.4e+28))
> assessDataTypeGDAL(ras)
[1] "Float32"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = 3.4e+26, max = 3.4e+28))
> assessDataTypeGDAL(ras)
[1] "Float32"
> 
> ras <- raster(ncol = 10, nrow = 10)
> ras[] <- round(runif(100, min = -3.4e+26, max = -1))
> assessDataTypeGDAL(ras)
[1] "Float32"
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("cacheMessage")
> ### * cacheMessage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .cacheMessage
> ### Title: Create a custom cache message by class
> ### Aliases: .cacheMessage .cacheMessage,ANY-method
> 
> ### ** Examples
> 
> a <- 1
> .cacheMessage(a, "mean")
     loaded cached result from previous mean call, adding to memoised copy...
> 
> 
> 
> 
> cleanEx()
> nameEx("checkCacheRepo")
> ### * checkCacheRepo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .checkCacheRepo
> ### Title: Check for cache repository info in ...
> ### Aliases: .checkCacheRepo .checkCacheRepo,ANY-method
> 
> ### ** Examples
> 
> a <- "test"
> .checkCacheRepo(a) # no cache repository supplied
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
> 
> 
> 
> 
> cleanEx()
> nameEx("checkGDALVersion")
> ### * checkGDALVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkGDALVersion
> ### Title: Check whether the system has a minimum version of GDAL available
> ### Aliases: checkGDALVersion
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D   checkGDALVersion("2.0")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("checkoutVersion")
> ### * checkoutVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checkoutVersion
> ### Title: Clone, fetch, and checkout from GitHub.com repositories
> ### Aliases: checkoutVersion
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   tmpDir <- tempfile("")
> ##D   dir.create(tmpDir)
> ##D   repo <- "PredictiveEcology/reproducible"
> ##D 
> ##D   ## get latest from master branch
> ##D   localRepo <- checkoutVersion("PredictiveEcology/reproducible",
> ##D                                localRepoPath = tmpDir)
> ##D   git2r::summary(localRepo)
> ##D   unlink(tmpDir, recursive = TRUE)
> ##D 
> ##D   ## get latest from development branch
> ##D   localRepo <- checkoutVersion(paste0(repo, "@", "development"), localRepoPath = tmpDir)
> ##D   git2r::summary(localRepo)
> ##D   unlink(tmpDir, recursive = TRUE)
> ##D 
> ##D   ## get a particular commit by sha
> ##D   sha <- "8179e1910e7c617fdeacad0f9d81323e6aad57c3"
> ##D   localRepo <- checkoutVersion(paste0(repo, "@", sha), localRepoPath = tmpDir)
> ##D   git2r::summary(localRepo)
> ##D   unlink(tmpDir, recursive = TRUE)
> ##D 
> ##D   rm(localRepo, repo)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("clearStubArtifacts")
> ### * clearStubArtifacts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clearStubArtifacts
> ### Title: Clear erroneous archivist artifacts
> ### Aliases: clearStubArtifacts clearStubArtifacts,ANY-method
> 
> ### ** Examples
> 
> tmpDir <- file.path(tempdir(), "reproducible_examples", "clearStubArtifacts")
> 
> lapply(c(runif, rnorm), function(f) {
+   reproducible::Cache(f, 10, cacheRepo = tmpDir)
+ })
[[1]]
 [1] 0.26550866 0.37212390 0.57285336 0.90820779 0.20168193 0.89838968
 [7] 0.94467527 0.66079779 0.62911404 0.06178627
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:88dabbb6fbb67941"
attr(,"call")
[1] ""

[[2]]
 [1] -0.8204684  0.4874291  0.7383247  0.5757814 -0.3053884  1.5117812
 [7]  0.3898432 -0.6212406 -2.2146999  1.1249309
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:87eee6212ba1ae0a"
attr(,"call")
[1] ""

> 
> # clear out any stub artifacts
> showCache(tmpDir)
Cache size: 
  Total (including Rasters): 552 bytes
  Selected objects (not including Rasters): 552 bytes
             cacheId              tagKey              tagValue
 1: 88dabbb6fbb67941            function                     f
 2: 88dabbb6fbb67941               class               numeric
 3: 88dabbb6fbb67941         object.size                  1104
 4: 88dabbb6fbb67941            accessed   2020-12-08 07:44:44
 5: 88dabbb6fbb67941             inCloud                 FALSE
 6: 88dabbb6fbb67941          resultHash                      
 7: 88dabbb6fbb67941   elapsedTimeDigest      0.001321316 secs
 8: 88dabbb6fbb67941 elapsedTimeFirstRun      8.72612e-05 secs
 9: 88dabbb6fbb67941      otherFunctions                lapply
10: 88dabbb6fbb67941           preDigest    n:c5775c3b366fb719
11: 88dabbb6fbb67941           preDigest .FUN:881ec847b7161f3c
12: 88dabbb6fbb67941           file.size                   205
13: 87eee6212ba1ae0a            function                     f
14: 87eee6212ba1ae0a               class               numeric
15: 87eee6212ba1ae0a         object.size                  1104
16: 87eee6212ba1ae0a            accessed   2020-12-08 07:44:44
17: 87eee6212ba1ae0a             inCloud                 FALSE
18: 87eee6212ba1ae0a          resultHash                      
19: 87eee6212ba1ae0a   elapsedTimeDigest      0.001629591 secs
20: 87eee6212ba1ae0a elapsedTimeFirstRun     0.0001342297 secs
21: 87eee6212ba1ae0a      otherFunctions                lapply
22: 87eee6212ba1ae0a           preDigest    n:c5775c3b366fb719
23: 87eee6212ba1ae0a           preDigest .FUN:4f604aa46882b368
24: 87eee6212ba1ae0a           file.size                   224
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:44:44
 2: 2020-12-08 07:44:44
 3: 2020-12-08 07:44:44
 4: 2020-12-08 07:44:44
 5: 2020-12-08 07:44:44
 6: 2020-12-08 07:44:44
 7: 2020-12-08 07:44:44
 8: 2020-12-08 07:44:44
 9: 2020-12-08 07:44:44
10: 2020-12-08 07:44:44
11: 2020-12-08 07:44:44
12: 2020-12-08 07:44:44
13: 2020-12-08 07:44:44
14: 2020-12-08 07:44:44
15: 2020-12-08 07:44:44
16: 2020-12-08 07:44:44
17: 2020-12-08 07:44:44
18: 2020-12-08 07:44:44
19: 2020-12-08 07:44:44
20: 2020-12-08 07:44:44
21: 2020-12-08 07:44:44
22: 2020-12-08 07:44:44
23: 2020-12-08 07:44:44
24: 2020-12-08 07:44:44
            createdDate
> 
> file2Remove <- dir(CacheStorageDir(tmpDir), full.name = TRUE)[1]
> file.remove(file2Remove)
[1] TRUE
> showCache(tmpDir) # repository directory still thinks files are there
Cache size: 
  Total (including Rasters): 552 bytes
  Selected objects (not including Rasters): 552 bytes
             cacheId              tagKey              tagValue
 1: 88dabbb6fbb67941            function                     f
 2: 88dabbb6fbb67941               class               numeric
 3: 88dabbb6fbb67941         object.size                  1104
 4: 88dabbb6fbb67941            accessed   2020-12-08 07:44:44
 5: 88dabbb6fbb67941             inCloud                 FALSE
 6: 88dabbb6fbb67941          resultHash                      
 7: 88dabbb6fbb67941   elapsedTimeDigest      0.001321316 secs
 8: 88dabbb6fbb67941 elapsedTimeFirstRun      8.72612e-05 secs
 9: 88dabbb6fbb67941      otherFunctions                lapply
10: 88dabbb6fbb67941           preDigest    n:c5775c3b366fb719
11: 88dabbb6fbb67941           preDigest .FUN:881ec847b7161f3c
12: 88dabbb6fbb67941           file.size                   205
13: 87eee6212ba1ae0a            function                     f
14: 87eee6212ba1ae0a               class               numeric
15: 87eee6212ba1ae0a         object.size                  1104
16: 87eee6212ba1ae0a            accessed   2020-12-08 07:44:44
17: 87eee6212ba1ae0a             inCloud                 FALSE
18: 87eee6212ba1ae0a          resultHash                      
19: 87eee6212ba1ae0a   elapsedTimeDigest      0.001629591 secs
20: 87eee6212ba1ae0a elapsedTimeFirstRun     0.0001342297 secs
21: 87eee6212ba1ae0a      otherFunctions                lapply
22: 87eee6212ba1ae0a           preDigest    n:c5775c3b366fb719
23: 87eee6212ba1ae0a           preDigest .FUN:4f604aa46882b368
24: 87eee6212ba1ae0a           file.size                   224
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:44:44
 2: 2020-12-08 07:44:44
 3: 2020-12-08 07:44:44
 4: 2020-12-08 07:44:44
 5: 2020-12-08 07:44:44
 6: 2020-12-08 07:44:44
 7: 2020-12-08 07:44:44
 8: 2020-12-08 07:44:44
 9: 2020-12-08 07:44:44
10: 2020-12-08 07:44:44
11: 2020-12-08 07:44:44
12: 2020-12-08 07:44:44
13: 2020-12-08 07:44:44
14: 2020-12-08 07:44:44
15: 2020-12-08 07:44:44
16: 2020-12-08 07:44:44
17: 2020-12-08 07:44:44
18: 2020-12-08 07:44:44
19: 2020-12-08 07:44:44
20: 2020-12-08 07:44:44
21: 2020-12-08 07:44:44
22: 2020-12-08 07:44:44
23: 2020-12-08 07:44:44
24: 2020-12-08 07:44:44
            createdDate
> 
> # run clearStubArtifacts
> suppressWarnings(clearStubArtifacts(tmpDir))
> showCache(tmpDir) # stubs are removed
Cache size: 
  Total (including Rasters): 552 bytes
  Selected objects (not including Rasters): 552 bytes
             cacheId              tagKey              tagValue
 1: 88dabbb6fbb67941            function                     f
 2: 88dabbb6fbb67941               class               numeric
 3: 88dabbb6fbb67941         object.size                  1104
 4: 88dabbb6fbb67941            accessed   2020-12-08 07:44:44
 5: 88dabbb6fbb67941             inCloud                 FALSE
 6: 88dabbb6fbb67941          resultHash                      
 7: 88dabbb6fbb67941   elapsedTimeDigest      0.001321316 secs
 8: 88dabbb6fbb67941 elapsedTimeFirstRun      8.72612e-05 secs
 9: 88dabbb6fbb67941      otherFunctions                lapply
10: 88dabbb6fbb67941           preDigest    n:c5775c3b366fb719
11: 88dabbb6fbb67941           preDigest .FUN:881ec847b7161f3c
12: 88dabbb6fbb67941           file.size                   205
13: 87eee6212ba1ae0a            function                     f
14: 87eee6212ba1ae0a               class               numeric
15: 87eee6212ba1ae0a         object.size                  1104
16: 87eee6212ba1ae0a            accessed   2020-12-08 07:44:44
17: 87eee6212ba1ae0a             inCloud                 FALSE
18: 87eee6212ba1ae0a          resultHash                      
19: 87eee6212ba1ae0a   elapsedTimeDigest      0.001629591 secs
20: 87eee6212ba1ae0a elapsedTimeFirstRun     0.0001342297 secs
21: 87eee6212ba1ae0a      otherFunctions                lapply
22: 87eee6212ba1ae0a           preDigest    n:c5775c3b366fb719
23: 87eee6212ba1ae0a           preDigest .FUN:4f604aa46882b368
24: 87eee6212ba1ae0a           file.size                   224
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:44:44
 2: 2020-12-08 07:44:44
 3: 2020-12-08 07:44:44
 4: 2020-12-08 07:44:44
 5: 2020-12-08 07:44:44
 6: 2020-12-08 07:44:44
 7: 2020-12-08 07:44:44
 8: 2020-12-08 07:44:44
 9: 2020-12-08 07:44:44
10: 2020-12-08 07:44:44
11: 2020-12-08 07:44:44
12: 2020-12-08 07:44:44
13: 2020-12-08 07:44:44
14: 2020-12-08 07:44:44
15: 2020-12-08 07:44:44
16: 2020-12-08 07:44:44
17: 2020-12-08 07:44:44
18: 2020-12-08 07:44:44
19: 2020-12-08 07:44:44
20: 2020-12-08 07:44:44
21: 2020-12-08 07:44:44
22: 2020-12-08 07:44:44
23: 2020-12-08 07:44:44
24: 2020-12-08 07:44:44
            createdDate
> 
> # cleanup
> clearCache(tmpDir, ask = FALSE)
> unlink(tmpDir, recursive = TRUE)
> 
> 
> 
> 
> cleanEx()
> nameEx("compareNA")
> ### * compareNA
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareNA
> ### Title: 'NA'-aware comparison of two vectors
> ### Aliases: compareNA
> 
> ### ** Examples
> 
> a <- c(NA, 1, 2, NA)
> b <- c(1, NA, 2, NA)
> compareNA(a, b)
[1] FALSE FALSE  TRUE  TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("convertPaths")
> ### * convertPaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convertPaths
> ### Title: Change the absolute path of a file
> ### Aliases: convertPaths convertRasterPaths
> 
> ### ** Examples
> 
> filenames <- c("/home/user1/Documents/file.txt", "/Users/user1/Documents/file.txt")
> oldPaths <- dirname(filenames)
> newPaths <- c("/home/user2/Desktop", "/Users/user2/Desktop")
> convertPaths(filenames, oldPaths, newPaths)
[1] "/home/user2/Desktop/file.txt"  "/Users/user2/Desktop/file.txt"
> 
> r1 <- raster::raster(system.file("external/test.grd", package = "raster"))
> r2 <- raster::raster(system.file("external/rlogo.grd", package = "raster"))
> rasters <- list(r1, r2)
> oldPaths <- system.file("external", package = "raster")
> newPaths <- file.path("~/rasters")
> rasters <- convertRasterPaths(rasters, oldPaths, newPaths)
> lapply(rasters, raster::filename)
[[1]]
[1] "/space/tkalibera/rasters/test.grd"

[[2]]
[1] "/space/tkalibera/rasters/rlogo.grd"

> 
> 
> 
> 
> cleanEx()
> nameEx("copyFile")
> ### * copyFile
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copySingleFile
> ### Title: Copy a file using 'robocopy' on Windows and 'rsync' on
> ###   Linux/macOS
> ### Aliases: copySingleFile copyFile
> 
> ### ** Examples
> 
> tmpDirFrom <- file.path(tempdir(), "example_fileCopy_from")
> tmpDirTo <- file.path(tempdir(), "example_fileCopy_to")
> tmpFile1 <- tempfile("file1", tmpDirFrom, ".csv")
> tmpFile2 <- tempfile("file2", tmpDirFrom, ".csv")
> checkPath(tmpDirFrom, create = TRUE)
[1] "/var/scratch2/tomas/tmp/RtmpK9dOt9/example_fileCopy_from"
> f1 <- normalizePath(tmpFile1, mustWork = FALSE)
> f2 <- normalizePath(tmpFile2, mustWork = FALSE)
> t1 <- normalizePath(file.path(tmpDirTo, basename(tmpFile1)), mustWork = FALSE)
> t2 <- normalizePath(file.path(tmpDirTo, basename(tmpFile2)), mustWork = FALSE)
> 
> write.csv(data.frame(a = 1:10, b = runif(10), c = letters[1:10]), f1)
> write.csv(data.frame(c = 11:20, d = runif(10), e = letters[11:20]), f2)
> copyFile(c(f1, f2), c(t1, t2))
/var/scratch2/tomas/tmp/RtmpK9dOt9/example_fileCopy_from/file1b2bb77ff9672e.csv 
"/var/scratch2/tomas/tmp/RtmpK9dOt9/example_fileCopy_to/file1b2bb77ff9672e.csv" 
 /var/scratch2/tomas/tmp/RtmpK9dOt9/example_fileCopy_from/file2b2bb745d1953.csv 
 "/var/scratch2/tomas/tmp/RtmpK9dOt9/example_fileCopy_to/file2b2bb745d1953.csv" 
> file.exists(t1) ## TRUE
[1] TRUE
> file.exists(t2) ## TRUE
[1] TRUE
> identical(read.csv(f1), read.csv(f2)) ## FALSE
[1] FALSE
> identical(read.csv(f1), read.csv(t1)) ## TRUE
[1] TRUE
> identical(read.csv(f2), read.csv(t2)) ## TRUE
[1] TRUE
> 
> unlink(tmpDirFrom, recursive = TRUE)
> unlink(tmpDirTo, recursive = TRUE)
> 
> 
> 
> 
> cleanEx()
> nameEx("cropInputs")
> ### * cropInputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cropInputs
> ### Title: Crop a 'Spatial*' or 'Raster*' object
> ### Aliases: cropInputs cropInputs.default cropInputs.spatialClasses
> ###   cropInputs.sf
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
    reprojecting ...
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("determineFilename")
> ### * determineFilename
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: determineFilename
> ### Title: Determine filename, either automatically or manually
> ### Aliases: determineFilename
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("fastMask")
> ### * fastMask
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fastMask
> ### Title: Faster operations on rasters
> ### Aliases: fastMask
> 
> ### ** Examples
> 
> library(sp)
> library(raster)
> 
> Sr1 <- Polygon(cbind(c(2, 4, 4, 0.9, 2), c(2, 3, 5, 4, 2)))
> Sr2 <- Polygon(cbind(c(5, 4, 2, 5), c(2, 3, 2, 2)))
> Sr3 <- Polygon(cbind(c(4, 4, 5, 10, 4), c(5, 3, 2, 5, 5)))
> 
> Srs1 <- Polygons(list(Sr1), "s1")
> Srs2 <- Polygons(list(Sr2), "s2")
> Srs3 <- Polygons(list(Sr3), "s3")
> shp <- SpatialPolygons(list(Srs1, Srs2, Srs3), 1:3)
> d <- data.frame(vals = 1:3, other = letters[3:1], stringsAsFactors = FALSE)
> row.names(d) <- names(shp)
> shp <- SpatialPolygonsDataFrame(shp, data = d)
> poly <- list()
> poly[[1]] <- raster(raster::extent(shp), vals = 0, res = c(1, 1))
> poly[[2]] <- raster(raster::extent(shp), vals = 1, res = c(1, 1))
> origStack <- stack(poly)
> # original mask function in raster
> newStack1 <- mask(x= origStack, mask = shp)
> newStack2 <- fastMask(x = origStack, y = shp)
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
This function is using raster::mask
 because fastMask doesn't have a specific method for these RasterStack or RasterBrick yet
> 
> # test all equal
> all.equal(newStack1, newStack2)
[1] TRUE
> 
> newStack1 <- stack(newStack1)
> newStack2 <- stack(newStack2)
> 
> if (interactive()) {
+   plot(newStack2[[1]])
+   plot(shp, add = TRUE)
+ }
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("fixErrors")
> ### * fixErrors
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fixErrors
> ### Title: Do some minor error fixing
> ### Aliases: fixErrors fixErrors.default fixErrors.Raster
> ###   fixErrors.SpatialPolygons fixErrors.sf
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("isInteractive")
> ### * isInteractive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: isInteractive
> ### Title: Alternative to 'interactive()' for unit testing
> ### Aliases: isInteractive
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D testthat::with_mock(
> ##D `isInteractive` = function() {browser(); TRUE},
> ##D {
> ##D   tmpdir <- tempdir()
> ##D   aa <- Cache(rnorm, 1, cacheRepo = tmpdir, userTags = "something2")
> ##D   # Test clearCache -- has an internal isInteractive() call
> ##D   clearCache(tmpdir, ask = FALSE)
> ##D   })
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("linkOrCopy")
> ### * linkOrCopy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: linkOrCopy
> ### Title: Hardlink, symlink, or copy a file
> ### Aliases: linkOrCopy
> 
> ### ** Examples
> 
> library(datasets)
> library(magrittr)
> library(raster)
Loading required package: sp

Attaching package: ‘raster’

The following object is masked from ‘package:magrittr’:

    extract

> 
> tmpDir <- file.path(tempdir(), "symlink-test") %>%
+   normalizePath(winslash = '/', mustWork = FALSE)
> dir.create(tmpDir)
> 
> f0 <- file.path(tmpDir, "file0.csv")
> write.csv(iris, f0)
> 
> d1 <- file.path(tmpDir, "dir1")
> dir.create(d1)
> write.csv(iris, file.path(d1, "file1.csv"))
> 
> d2 <- file.path(tmpDir, "dir2")
> dir.create(d2)
> f2 <- file.path(tmpDir, "file2.csv")
> 
> ## create link to a file
> linkOrCopy(f0, f2)
Hardlinked version of file created at: /var/scratch2/tomas/tmp/RtmpK9dOt9/symlink-test/file2.csv, which points to /var/scratch2/tomas/tmp/RtmpK9dOt9/symlink-test/file0.csv; no copy was made.
[1] TRUE
> file.exists(f2) ## TRUE
[1] TRUE
> identical(read.table(f0), read.table(f2)) ## TRUE
[1] TRUE
> 
> ## deleting the link shouldn't delete the original file
> unlink(f0)
> file.exists(f0) ## FALSE
[1] FALSE
> file.exists(f2) ## TRUE
[1] TRUE
> 
> ## using rasters and other file-backed objects
> f3a <- system.file("external/test.grd", package = "raster")
> f3b <- system.file("external/test.gri", package = "raster")
> r3a <- raster(f3a)
> f4a <- file.path(tmpDir, "raster4.grd")
> f4b <- file.path(tmpDir, "raster4.gri")
> linkOrCopy(f3a, f4a) ## hardlink
Hardlinked version of file created at: /var/scratch2/tomas/tmp/RtmpK9dOt9/symlink-test/raster4.grd, which points to /var/scratch2/tomas/cran/rcnst/lib/raster/external/test.grd; no copy was made.
[1] TRUE
> linkOrCopy(f3b, f4b) ## hardlink
Hardlinked version of file created at: /var/scratch2/tomas/tmp/RtmpK9dOt9/symlink-test/raster4.gri, which points to /var/scratch2/tomas/cran/rcnst/lib/raster/external/test.gri; no copy was made.
[1] TRUE
> r4a <- raster(f4a)
> 
> isTRUE(all.equal(r3a, r4a)) # TRUE
[1] TRUE
> 
> ## cleanup
> unlink(tmpDir, recursive = TRUE)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’, ‘package:magrittr’

> nameEx("maskInputs")
> ### * maskInputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maskInputs
> ### Title: Mask module inputs
> ### Aliases: maskInputs maskInputs.Raster maskInputs.Spatial maskInputs.sf
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("movedCache")
> ### * movedCache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: movedCache
> ### Title: Deal with moved cache issues
> ### Aliases: movedCache
> 
> ### ** Examples
> 
> tmpCache <- file.path(tempdir(), "tmpCache")
> tmpdir <- file.path(tempdir(), "tmpdir")
> bb <- Cache(rnorm, 1, cacheRepo = tmpCache)
> 
> # Copy all files from tmpCache to tmpdir
> froms <- normPath(dir(tmpCache, recursive = TRUE, full.names = TRUE))
> checkPath(file.path(tmpdir, "rasters"), create = TRUE)
[1] "/var/scratch2/tomas/tmp/RtmpK9dOt9/tmpdir/rasters"
> checkPath(file.path(tmpdir, "cacheOutputs"), create = TRUE)
[1] "/var/scratch2/tomas/tmp/RtmpK9dOt9/tmpdir/cacheOutputs"
> file.copy(from = froms, overwrite = TRUE,
+           to = gsub(normPath(tmpCache), normPath(tmpdir), froms))
[1] TRUE TRUE
> 
> # Must use 'movedCache' to update the database table
> movedCache(new = tmpdir, old = tmpCache)
> bb <- Cache(rnorm, 1, cacheRepo = tmpdir) # should recover the previous call
  ...(Object to retrieve (7072c305d8c69df0.rds))
     loaded cached result from previous rnorm call, 
> 
> 
> 
> 
> cleanEx()
> nameEx("objSize")
> ### * objSize
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: objSize
> ### Title: Recursive 'object.size'
> ### Aliases: objSize objSize.default objSize.list objSize.environment
> ###   objSize.Path objSize.function objSizeSession
> 
> ### ** Examples
> 
> library(utils)
> 
> foo <- new.env()
> foo$b <- 1:10
> foo$d <- 1:10
> 
> objSize(foo) # all the elements in the environment
$`foo$b`
96 bytes

$`foo$d`
96 bytes

$foo
56 bytes

> object.size(foo) # different - only measuring the environment as an object
56 bytes
> 
> object.size(prepInputs) # only the function, without its enclosing environment
438768 bytes
> objSize(prepInputs)     # the function, plus its enclosing environment
$`%<%`
24120 bytes

$`%C%`
52776 bytes

$Cache
22688 bytes

$CacheDBFile
32024 bytes

$CacheDBTableName
47640 bytes

$CacheDigest
123560 bytes

$CacheIsACache
122496 bytes

$CacheStorageDir
7968 bytes

$CacheStoredFile
28112 bytes

$Checksums
9064 bytes

$Copy
5616 bytes

$Filenames
5264 bytes

$MaxVals
1232 bytes

$MaxValsFlts
464 bytes

$MinVals
1232 bytes

$MinValsFlts
464 bytes

$RCurlMess
232 bytes

$appendChecksumsTable
142640 bytes

$argsToRemove
2032 bytes

$asPath
1928 bytes

$asPath.character
10824 bytes

$asPath.null
1480 bytes

$assessDataType
1784 bytes

$assessDataType.Raster
166272 bytes

$assessDataType.RasterStack
21832 bytes

$assessDataType.default
3808 bytes

$assessDataTypeGDAL
3344 bytes

$assessGoogle
82968 bytes

$attemptGDAL
55504 bytes

$basename2
4768 bytes

$bigRastersTmpFile
2200 bytes

$bigRastersTmpFolder
4112 bytes

$captureWarningsToAttr
57104 bytes

$cc
53776 bytes

$checkAndMakeCloudFolderID
23128 bytes

$checkColors
10760 bytes

$checkFutures
54184 bytes

$checkGDALVersion
12808 bytes

$checkoutVersion
2992 bytes

$clearCache
12360 bytes

$clearStubArtifacts
4696 bytes

$cloudCache
3776 bytes

$cloudCheckOld
4000 bytes

$cloudDownload
69896 bytes

$cloudDownloadRasterBackend
185904 bytes

$cloudFolderFromCacheRepo
6760 bytes

$cloudSyncCacheOld
5616 bytes

$cloudUpload
103352 bytes

$cloudUploadFromCache
63368 bytes

$cloudUploadRasterBackends
50072 bytes

$cloudWriteOld
4808 bytes

$compareNA
12496 bytes

$convertPaths
28440 bytes

$convertRasterPaths
49840 bytes

$copyFile
33328 bytes

$copySingleFile
283640 bytes

$createCache
73720 bytes

$cropInputs
2584 bytes

$cropInputs.default
1592 bytes

$cropInputs.sf
199392 bytes

$cropInputs.spatialClasses
595952 bytes

$cropReprojMaskWGDAL
472224 bytes

$datatypeVals
8080 bytes

$dbConnectAll
24720 bytes

$dealWithCores
33024 bytes

$dealWithRasters
191064 bytes

$dealWithRastersOnRecovery
178792 bytes

$determineFilename
141936 bytes

$determineNestedTags
106272 bytes

$devModeFn1
216952 bytes

$differentRasters
33544 bytes

$dlGeneric
53320 bytes

$dlGoogle
224880 bytes

$downloadFile
867928 bytes

$downloadRemote
431336 bytes

$driveLs
59368 bytes

$dtp
864 bytes

$dtps
1232 bytes

$extractFromArchive
576480 bytes

$fastMask
421152 bytes

$file.move
27688 bytes

$fileExt
12920 bytes

$filePathSansExt
3832 bytes

$findGDAL
72696 bytes

$fixErrors
3112 bytes

$fixErrors.Raster
45344 bytes

$fixErrors.SpatialPolygons
107456 bytes

$fixErrors.default
2648 bytes

$fixErrors.sf
94792 bytes

$getArtifact
28832 bytes

$getCacheId
30208 bytes

$getCacheRepos
25728 bytes

$getFunctionName
553112 bytes

$getGDALVersion
54400 bytes

$getUserTags
56984 bytes

$internetExists
46896 bytes

$isAbsolutePath
43784 bytes

$isDirectory
26640 bytes

$isFile
24592 bytes

$isInteractive
840 bytes

$isLongLat
7728 bytes

$isOrHasRaster
78752 bytes

$isProjected
29168 bytes

$isTRUEorForce
5880 bytes

$isWindows
3544 bytes

$is_dollar
3752 bytes

$is_first
12960 bytes

$is_function
3128 bytes

$is_funexpr
7184 bytes

$is_parenthesized
7184 bytes

$is_pipe
18320 bytes

$is_placeholder
3752 bytes

$is_tee
3752 bytes

$keepCache
10664 bytes

$knownArchiveExtensions
432 bytes

$knownInternalArchiveExtensions
304 bytes

$knownSystemArchiveExtensions
176 bytes

$linkOrCopy
135032 bytes

$loadFile
22056 bytes

$loadFromCache
109568 bytes

$makeMemoisable
1552 bytes

$makeMemoisable.default
1088 bytes

$maskInputs
1888 bytes

$maskInputs.Raster
52016 bytes

$maskInputs.Spatial
20856 bytes

$maskInputs.sf
134448 bytes

$maskWithRasterNAs
25232 bytes

$mergeCache
9880 bytes

$messageCache
3640 bytes

$messageColoured
48320 bytes

$messageDF
81680 bytes

$messagePrepInputs
3704 bytes

$messageQuestion
6528 bytes

$messageRgeosMissing
232 bytes

$missingFiles
38056 bytes

$missingUnrarMess
232 bytes

$moveAttributes
28808 bytes

$movedCache
74216 bytes

$nextNumericName
97200 bytes

$objSize
2432 bytes

$objSize.Path
6984 bytes

$objSize.default
3496 bytes

$objSize.environment
35144 bytes

$objSize.function
48056 bytes

$objSize.list
127880 bytes

$objSizeSession
143520 bytes

$paddedFloatToChar
41832 bytes

$postProcess
1720 bytes

$postProcess.default
1256 bytes

$postProcess.list
8872 bytes

$postProcess.quosure
4128 bytes

$postProcess.sf
52304 bytes

$postProcess.spatialClasses
35808 bytes

$postProcessAllSpatial
540184 bytes

$postProcessChecks
53864 bytes

$preProcess
1131656 bytes

$preProcessParams
401312 bytes

$prepInputs
438768 bytes

$prepare_first
9352 bytes

$prepare_function
3464 bytes

$progressBarCode
19176 bytes

$proj6Warn
136 bytes

$projNotWKT2warn
136 bytes

$projectInputs
2416 bytes

$projectInputs.Raster
891080 bytes

$projectInputs.Spatial
47176 bytes

$projectInputs.default
1424 bytes

$projectInputs.sf
82848 bytes

$rebuildColors
71440 bytes

$reproducibleOptions
17400 bytes

$requireNamespaceMsg
23824 bytes

$retry
63584 bytes

$rmFromCache
43864 bytes

$rmFromCloudFolder
97656 bytes

$rndstr
29240 bytes

$roundTo6Dec
14568 bytes

$roundToRes
44672 bytes

$saveFileInCacheFolder
62952 bytes

$saveToCache
173096 bytes

$searchFull
37224 bytes

$searchFullEx
1120 bytes

$setMinMaxIfNeeded
76592 bytes

$showCache
9648 bytes

$split_chain
82744 bytes

$studyAreaName
5200 bytes

$suppressWarningsSpecific
54592 bytes

$unmakeMemoisable
1584 bytes

$unmakeMemoisable.default
1088 bytes

$updateFilenameSlots
77256 bytes

$useDBI
7936 bytes

$useETM
16544 bytes

$verboseDF1
39560 bytes

$verboseDF2
36000 bytes

$verboseDF3
36096 bytes

$verboseMessage1
10976 bytes

$verboseMessage2
7368 bytes

$verboseMessage3
12096 bytes

$verboseTime
4208 bytes

$wrap_function
22408 bytes

$writeChecksumsTable
24960 bytes

$writeFuture
42432 bytes

$writeOutputs
2360 bytes

$writeOutputs.Raster
726256 bytes

$writeOutputs.Spatial
10792 bytes

$writeOutputs.default
4400 bytes

$writeOutputs.quosure
6032 bytes

$writeOutputs.sf
79728 bytes

> 
> # Size of all packages; includes their imported functions
> ## Not run: 
> ##D   bar <- objSizeSession(1)
> ##D   print(bar, units = "auto")
> ## End(Not run)
> 
> os1 <- object.size(as.environment("package:reproducible"))
> os2 <- objSize(as.environment("package:reproducible"))
> (os1) # very small -- just the environment container
568 bytes
> sum(unlist(os2)) # around 13 MB, with all functions, objects
[1] 25600352
>                  # and imported functions
> 
> 
> 
> 
> cleanEx()
> nameEx("paddedFloatToChar")
> ### * paddedFloatToChar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paddedFloatToChar
> ### Title: Convert numeric to character with padding
> ### Aliases: paddedFloatToChar
> 
> ### ** Examples
> 
> paddedFloatToChar(1.25)
[1] "1.250"
> paddedFloatToChar(1.25, padL = 3, padR = 5)
[1] "001.25000"
> paddedFloatToChar(1.25, padL = 3, padR = 1) # no rounding, so keeps 2 right of decimal
[1] "001.25"
> 
> 
> 
> cleanEx()
> nameEx("pipe")
> ### * pipe
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pipe
> ### Title: A cache-aware pipe (currently not working)
> ### Aliases: pipe %C% %<%
> 
> ### ** Examples
> 
> # THIS IS CURRENTLY BROKEN DUE TO UPGRADES TO INTERNALS OF magrittr %>%
> library(magrittr) # standard pipe
> ## Not run: 
> ##D  # these can't be automatically run due to package conflicts with magrittr
> ##D tmpdir <- file.path(tempdir(), "testCache")
> ##D checkPath(tmpdir, create = TRUE)
> ##D a <- rnorm(10, 16) %>%
> ##D      mean() %>%
> ##D      prod(., 6)
> ##D b <- Cache(cacheRepo = tmpdir) %C% # use of the %C% pipe!
> ##D      rnorm(10, 16) %>% # everything after here is NOT cached!
> ##D      mean() %>%
> ##D      prod(., 6)
> ##D d <- Cache(cacheRepo = tmpdir) %C%
> ##D      rnorm(10, 16) %>%
> ##D      mean() %>%
> ##D      prod(., 6)
> ##D e <- Cache(cacheRepo = tmpdir) %C%
> ##D      rnorm(10, 16) %>%
> ##D      mean() %>%
> ##D      prod(., 5) # changed
> ##D all.equal(b,d) # TRUE
> ##D all.equal(a,d) # different because 'a' uses a unique rnorm, 'd' uses the Cached rnorm
> ##D                #   because the arguments to rnorm, i.e., 10 and 16, and
> ##D                #   the subsequent functions in the chain, are identical
> ##D all.equal(a,e) # different because the final function, prod, has a changed argument.
> ##D 
> ##D ###########
> ##D # multiple random elements shows Cached sequence up to %C%
> ##D a1 <- Cache(cacheRepo = tmpdir) %>%
> ##D        seq(1, 10) %>%
> ##D        rnorm(2, mean = .) %>%
> ##D        mean() %C%                # Cache pipe here --
> ##D                                  # means this pipe is the last one that is Cached
> ##D        rnorm(3, mean = .) %>%
> ##D        mean(.) %>%
> ##D        rnorm(4, mean = .)  # Random 4 numbers, the mean is same each time
> ##D a2 <- Cache(cacheRepo = tmpdir) %>%
> ##D        seq(1, 10) %>%
> ##D        rnorm(2, mean = .) %>%
> ##D        mean() %C%                # Cache pipe here --
> ##D                                  # means this pipe is the last one that is Cached
> ##D        rnorm(3, mean = .) %>%
> ##D        mean(.) %>%
> ##D        rnorm(4, mean = .)  # Random 4 numbers, the mean is same each time
> ##D sum(a1 - a2) # not 0 # i.e., numbers are different
> ##D 
> ##D # NOW DO WITH CACHE AT END
> ##D b1 <- Cache(cacheRepo = tmpdir) %>%
> ##D        seq(1, 10) %>%
> ##D        rnorm(2, mean = .) %>%
> ##D        mean() %>%
> ##D                                  # means this pipe is the last one that is Cached
> ##D        rnorm(3, mean = .) %>%
> ##D        mean(.) %C%               # Cache pipe here --
> ##D        rnorm(4, mean = .)        # These are samethe mean is same each time
> ##D b2 <- Cache(cacheRepo = tmpdir) %>%
> ##D        seq(1, 10) %>%
> ##D        rnorm(2, mean = .) %>%
> ##D        mean() %>%
> ##D                                  # means this pipe is the last one that is Cached
> ##D        rnorm(3, mean = .) %>%
> ##D        mean(.) %C%               # Cache pipe here --
> ##D        rnorm(4, mean = .)        # These are samethe mean is same each time
> ##D sum(b1 - b2) # 0 # i.e., numbers are same
> ##D 
> ##D unlink(tmpdir, recursive = TRUE)
> ## End(Not run)
> # Equivalent
> a <- Cache(rnorm, 1)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
> b %<% rnorm(1)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (7072c305d8c69df0.rds))
     loaded cached result from previous rnorm call, 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:magrittr’

> nameEx("postProcess")
> ### * postProcess
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: postProcess
> ### Title: Generic function to post process objects
> ### Aliases: postProcess postProcess.default postProcess.list
> ###   postProcess.spatialClasses postProcess.sf
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("preDigestByClass")
> ### * preDigestByClass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .preDigestByClass
> ### Title: Any miscellaneous things to do before '.robustDigest' and after
> ###   'FUN' call
> ### Aliases: .preDigestByClass .preDigestByClass,ANY-method
> 
> ### ** Examples
> 
> a <- 1
> .preDigestByClass(a) # returns NULL in the simple case here.
NULL
> 
> 
> 
> 
> cleanEx()
> nameEx("prefix")
> ### * prefix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .prefix
> ### Title: Add a prefix or suffix to the basename part of a file path
> ### Aliases: .prefix suffix .suffix
> 
> ### ** Examples
> 
> # file's full path is specified (i.e., dirname is known)
> myFile <- file.path("~/data", "file.tif")
> .prefix(myFile, "small_")    ## "/home/username/data/small_file.tif"
[1] "/space/tkalibera/data/small_file.tif"
> .suffix(myFile, "_cropped") ## "/home/username/data/myFile_cropped.shp"
[1] "/space/tkalibera/data/file_cropped.tif"
> 
> # file's full path is not specified
> .prefix("myFile.shp", "small")    ## "./small_myFile.shp"
[1] "./smallmyFile.shp"
> .suffix("myFile.shp", "_cropped") ## "./myFile_cropped.shp"
[1] "./myFile_cropped.shp"
> 
> 
> 
> 
> cleanEx()
> nameEx("prepInputs")
> ### * prepInputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prepInputs
> ### Title: Download and optionally post-process files
> ### Aliases: prepInputs
> 
> ### ** Examples
> 
> # This function works within a module; however, currently,
> #   \cde{sourceURL} is not yet working as desired. Use \code{url}.
> ## Not run: 
> ##D # download a zip file from internet, unzip all files, load as shapefile, Cache the call
> ##D # First time: don't know all files - prepInputs will guess, if download file is an archive,
> ##D #   then extract all files, then if there is a .shp, it will load with raster::shapefile
> ##D dPath <- file.path(tempdir(), "ecozones")
> ##D shpEcozone <- prepInputs(destinationPath = dPath,
> ##D                          url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip")
> ##D 
> ##D # Robust to partial file deletions:
> ##D unlink(dir(dPath, full.names = TRUE)[1:3])
> ##D shpEcozone <- prepInputs(destinationPath = dPath,
> ##D                          url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip")
> ##D unlink(dPath, recursive = TRUE)
> ##D 
> ##D # Once this is done, can be more precise in operational code:
> ##D #  specify targetFile, alsoExtract, and fun, wrap with Cache
> ##D ecozoneFilename <- file.path(dPath, "ecozones.shp")
> ##D ecozoneFiles <- c("ecozones.dbf", "ecozones.prj",
> ##D                   "ecozones.sbn", "ecozones.sbx", "ecozones.shp", "ecozones.shx")
> ##D shpEcozone <- prepInputs(targetFile = ecozoneFilename,
> ##D                          url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip",
> ##D                          alsoExtract = ecozoneFiles,
> ##D                          fun = "shapefile", destinationPath = dPath)
> ##D unlink(dPath, recursive = TRUE)
> ##D 
> ##D #' # Add a study area to Crop and Mask to
> ##D # Create a "study area"
> ##D library(sp)
> ##D library(raster)
> ##D coords <- structure(c(-122.98, -116.1, -99.2, -106, -122.98, 59.9, 65.73, 63.58, 54.79, 59.9),
> ##D                     .Dim = c(5L, 2L))
> ##D Sr1 <- Polygon(coords)
> ##D Srs1 <- Polygons(list(Sr1), "s1")
> ##D StudyArea <- SpatialPolygons(list(Srs1), 1L)
> ##D crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> ##D 
> ##D #  specify targetFile, alsoExtract, and fun, wrap with Cache
> ##D ecozoneFilename <- file.path(dPath, "ecozones.shp")
> ##D # Note, you don't need to "alsoExtract" the archive... if the archive is not there, but the
> ##D #   targetFile is there, it will not redownload the archive.
> ##D ecozoneFiles <- c("ecozones.dbf", "ecozones.prj",
> ##D                   "ecozones.sbn", "ecozones.sbx", "ecozones.shp", "ecozones.shx")
> ##D shpEcozoneSm <- Cache(prepInputs,
> ##D                       url = "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip",
> ##D                       targetFile = reproducible::asPath(ecozoneFilename),
> ##D                       alsoExtract = reproducible::asPath(ecozoneFiles),
> ##D                       studyArea = StudyArea,
> ##D                       fun = "shapefile", destinationPath = dPath,
> ##D                       filename2 = "EcozoneFile.shp") # passed to determineFilename
> ##D 
> ##D plot(shpEcozone)
> ##D plot(shpEcozoneSm, add = TRUE, col = "red")
> ##D unlink(dPath)
> ##D 
> ##D # Big Raster, with crop and mask to Study Area - no reprojecting (lossy) of raster,
> ##D #   but the StudyArea does get reprojected, need to use rasterToMatch
> ##D dPath <- file.path(tempdir(), "LCC")
> ##D lcc2005Filename <- file.path(dPath, "LCC2005_V1_4a.tif")
> ##D url <- file.path("ftp://ftp.ccrs.nrcan.gc.ca/ad/NLCCLandCover",
> ##D                  "LandcoverCanada2005_250m/LandCoverOfCanada2005_V1_4.zip")
> ##D 
> ##D # messages received below may help for filling in more arguments in the subsequent call
> ##D LCC2005 <- prepInputs(url = url,
> ##D                       destinationPath = asPath(dPath),
> ##D                       studyArea = StudyArea)
> ##D 
> ##D plot(LCC2005)
> ##D 
> ##D # if wrapped with Cache, will be fast second time, very fast 3rd time (via memoised copy)
> ##D LCC2005 <- Cache(prepInputs, url = url,
> ##D                  targetFile = lcc2005Filename,
> ##D                  archive = asPath("LandCoverOfCanada2005_V1_4.zip"),
> ##D                  destinationPath = asPath(dPath),
> ##D                  studyArea = StudyArea)
> ##D # Using dlFun -- a custom download function -- passed to preProcess
> ##D test1 <- prepInputs(targetFile = "GADM_2.8_LUX_adm0.rds", # must specify currently
> ##D                     dlFun = "raster::getData", name = "GADM", country = "LUX", level = 0,
> ##D                     path = dPath)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("prepareFileBackedRaster")
> ### * prepareFileBackedRaster
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .prepareFileBackedRaster
> ### Title: Copy the file-backing of a file-backed Raster* object
> ### Aliases: .prepareFileBackedRaster
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> # make a cache repository
> a <- Cache(rnorm, 1)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (7072c305d8c69df0.rds))
     loaded cached result from previous rnorm call, 
> 
> r <- raster(extent(0,10,0,10), vals = 1:100)
> 
> # write to disk manually -- will be in tempdir()
> r <- writeRaster(r, file = tempfile())
> 
> # copy it to the cache repository
> r <- .prepareFileBackedRaster(r, tempdir())
> 
> r # now in "rasters" subfolder of tempdir()
class      : RasterLayer 
dimensions : 10, 10, 100  (nrow, ncol, ncell)
resolution : 1, 1  (x, y)
extent     : 0, 10, 0, 10  (xmin, xmax, ymin, ymax)
crs        : NA 
source     : /var/scratch2/tomas/tmp/RtmpK9dOt9/rasters/fileb2bb7300fd5ac.grd 
names      : layer 
values     : 1, 100  (min, max)

> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("prepareOutput")
> ### * prepareOutput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .prepareOutput
> ### Title: Make any modifications to object recovered from cacheRepo
> ### Aliases: .prepareOutput .prepareOutput,Raster-method
> ###   .prepareOutput,ANY-method
> 
> ### ** Examples
> 
> a <- 1
> .prepareOutput(a) # does nothing
[1] 1
> 
> b <- "Null"
> .prepareOutput(b) # converts to NULL
NULL
> 
> library(raster)
Loading required package: sp
> r <- raster(extent(0,10,0,10), vals = 1:100)
> 
> # write to disk manually -- will be in tempdir()
> r <- writeRaster(r, file = tempfile())
> 
> # copy it to the cache repository
> r <- .prepareOutput(r, tempdir())
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("projectInputs")
> ### * projectInputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: projectInputs
> ### Title: Project 'Raster*' or Spatial* or 'sf' objects
> ### Aliases: projectInputs projectInputs.default projectInputs.Raster
> ###   projectInputs.sf projectInputs.Spatial
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("robustDigest")
> ### * robustDigest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .robustDigest
> ### Title: Create reproducible digests of objects in R
> ### Aliases: .robustDigest .robustDigest,ANY-method
> ###   .robustDigest,function-method .robustDigest,expression-method
> ###   .robustDigest,character-method .robustDigest,Path-method
> ###   .robustDigest,environment-method .robustDigest,list-method
> ###   .robustDigest,data.frame-method .robustDigest,Raster-method
> ###   .robustDigest,Spatial-method
> ### Keywords: internal
> 
> ### ** Examples
> 
> 
> a <- 2
> tmpfile1 <- tempfile()
> tmpfile2 <- tempfile()
> save(a, file = tmpfile1)
> save(a, file = tmpfile2)
> 
> # treats as character string, so 2 filenames are different
> digest::digest(tmpfile1)
[1] "b93069612352bd41696945f6541760e0"
> digest::digest(tmpfile2)
[1] "60435151b147c6d6413c015d99233f85"
> 
> # tests to see whether character string is representing a file
> .robustDigest(tmpfile1)
[1] "776b5af0a8732d1f"
> .robustDigest(tmpfile2) # same
[1] "776b5af0a8732d1f"
> 
> # if you tell it that it is a path, then you can decide if you want it to be
> #  treated as a character string or as a file path
> .robustDigest(asPath(tmpfile1), quick = TRUE)
[1] "169aacf2f3f24693"
> .robustDigest(asPath(tmpfile2), quick = TRUE) # different because using file info
[1] "3b707d3e3a717a47"
> 
> .robustDigest(asPath(tmpfile1), quick = FALSE)
[[1]]
[1] "776b5af0a8732d1f"

> .robustDigest(asPath(tmpfile2), quick = FALSE) # same because using file content
[[1]]
[1] "776b5af0a8732d1f"

> 
> # Rasters are interesting because it is not know a priori if it
> #   it has a file name associated with it.
> library(raster)
Loading required package: sp
> r <- raster(extent(0,10,0,10), vals = 1:100)
> 
> # write to disk
> r1 <- writeRaster(r, file = tmpfile1)
> r2 <- writeRaster(r, file = tmpfile2)
> 
> digest::digest(r1)
[1] "46d338e61f99854720e95cbe72c5af03"
> digest::digest(r2) # different
[1] "9fa047f5dc0370561fbd30ed0e75efdf"
> digest::digest(r1)
[1] "46d338e61f99854720e95cbe72c5af03"
> digest::digest(r2) # different
[1] "9fa047f5dc0370561fbd30ed0e75efdf"
> .robustDigest(r1)
[1] "faaaa7b7fecfe853"
> .robustDigest(r2) # same... data are the same in the file
[1] "faaaa7b7fecfe853"
> 
> # note, this is not true for comparing memory and file-backed rasters
> .robustDigest(r)
[1] "f030911d89573359"
> .robustDigest(r1) # different
[1] "faaaa7b7fecfe853"
> 
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("search")
> ### * search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: searchFull
> ### Title: Search up the full scope for functions
> ### Aliases: searchFull searchFullEx
> 
> ### ** Examples
> 
> seeScope <- function() {
+   searchFull()
+ }
> seeScope()
[[1]]
<environment: R_GlobalEnv>

[[2]]
[1] "package:reproducible"

[[3]]
[1] "CheckExEnv"

[[4]]
[1] "package:stats"

[[5]]
[1] "package:graphics"

[[6]]
[1] "package:grDevices"

[[7]]
[1] "package:utils"

[[8]]
[1] "package:datasets"

[[9]]
[1] "package:methods"

[[10]]
[1] "Autoloads"

[[11]]
<environment: base>

> searchFull()
[[1]]
[1] "package:reproducible"

[[2]]
[1] "CheckExEnv"

[[3]]
[1] "package:stats"

[[4]]
[1] "package:graphics"

[[5]]
[1] "package:grDevices"

[[6]]
[1] "package:utils"

[[7]]
[1] "package:datasets"

[[8]]
[1] "package:methods"

[[9]]
[1] "Autoloads"

[[10]]
<environment: base>

> searchFullEx()
[[1]]
<environment: namespace:reproducible>

[[2]]
[1] "imports:reproducible"

[[3]]
<environment: namespace:base>

[[4]]
<environment: R_GlobalEnv>

[[5]]
[1] "package:reproducible"

[[6]]
[1] "CheckExEnv"

[[7]]
[1] "package:stats"

[[8]]
[1] "package:graphics"

[[9]]
[1] "package:grDevices"

[[10]]
[1] "package:utils"

[[11]]
[1] "package:datasets"

[[12]]
[1] "package:methods"

[[13]]
[1] "Autoloads"

[[14]]
<environment: base>

> 
> 
> 
> cleanEx()
> nameEx("sortDotsUnderscoreFirst")
> ### * sortDotsUnderscoreFirst
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .sortDotsUnderscoreFirst
> ### Title: Sort or order any named object with dotted names and underscores
> ###   first
> ### Aliases: .sortDotsUnderscoreFirst .orderDotsUnderscoreFirst
> 
> ### ** Examples
> 
> items <- c(A = "a", Z = "z", `.D` = ".d", `_C` = "_C")
> .sortDotsUnderscoreFirst(items)
   A    Z   _C   .D 
 "a"  "z" "_C" ".d" 
> 
> # dots & underscore (using 2nd character), then all lower then all upper
> items <- c(B = "Upper", b = "lower", A = "a", `.D` = ".d", `_C` = "_C")
> .sortDotsUnderscoreFirst(items)
      A       B      _C      .D       b 
    "a" "Upper"    "_C"    ".d" "lower" 
> 
> # with a vector
> .sortDotsUnderscoreFirst(c(".C", "_B", "A")) # _B is first
[1] "A"  "_B" ".C"
> 
> 
> 
> 
> cleanEx()
> nameEx("tagsByClass")
> ### * tagsByClass
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .tagsByClass
> ### Title: Add extra tags to an archive based on class
> ### Aliases: .tagsByClass .tagsByClass,ANY-method
> 
> ### ** Examples
> 
> .tagsByClass(character()) # Nothing interesting. Other packages will make methods
NULL
> 
> 
> 
> 
> cleanEx()
> nameEx("viewCache")
> ### * viewCache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clearCache
> ### Title: Examining and modifying the cache
> ### Aliases: clearCache clearCache,ANY-method cc showCache
> ###   showCache,ANY-method keepCache keepCache,ANY-method
> 
> ### ** Examples
> 
> library(raster)
Loading required package: sp
> 
> tmpDir <- file.path(tempdir(), "reproducible_examples", "Cache")
> try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear
> 
> # Basic use
> ranNumsA <- Cache(rnorm, 10, 16, cacheRepo = tmpDir)
> 
> # All same
> ranNumsB <- Cache(rnorm, 10, 16, cacheRepo = tmpDir) # recovers cached copy
  ...(Object to retrieve (f11fb1a2880f8060.rds))
     loaded cached result from previous rnorm call, 
> ranNumsD <- Cache(quote(rnorm(n = 10, 16)), cacheRepo = tmpDir) # recovers cached copy
  ...(Object to retrieve (f11fb1a2880f8060.rds))
     loaded cached result from previous rnorm call, 
> 
> # Any minor change makes it different
> ranNumsE <- Cache(rnorm, 10, 6, cacheRepo = tmpDir) # different
> 
> ## Example 1: basic cache use with tags
> ranNumsA <- Cache(rnorm, 4, cacheRepo = tmpDir, userTags = "objectName:a")
> ranNumsB <- Cache(runif, 4, cacheRepo = tmpDir, userTags = "objectName:b")
> ranNumsC <- Cache(runif, 40, cacheRepo = tmpDir, userTags = "objectName:b")
> 
> showCache(tmpDir, userTags = c("objectName"))
Cache size: 
  Total (including Rasters): 828 bytes
  Selected objects (not including Rasters): 828 bytes
             cacheId              tagKey              tagValue
 1: 3aef38d1fc02aee5          objectName                     b
 2: 3aef38d1fc02aee5            function                 runif
 3: 3aef38d1fc02aee5               class               numeric
 4: 3aef38d1fc02aee5         object.size                  1008
 5: 3aef38d1fc02aee5            accessed   2020-12-08 07:45:01
 6: 3aef38d1fc02aee5             inCloud                 FALSE
 7: 3aef38d1fc02aee5          resultHash                      
 8: 3aef38d1fc02aee5   elapsedTimeDigest      0.001347065 secs
 9: 3aef38d1fc02aee5 elapsedTimeFirstRun     0.0002076626 secs
10: 3aef38d1fc02aee5      otherFunctions                      
11: 3aef38d1fc02aee5           preDigest    n:7eef4eae85fd9229
12: 3aef38d1fc02aee5           preDigest .FUN:881ec847b7161f3c
13: 3aef38d1fc02aee5           file.size                   168
14: 7225b47fe5dc51d0          objectName                     b
15: 7225b47fe5dc51d0            function                 runif
16: 7225b47fe5dc51d0               class               numeric
17: 7225b47fe5dc51d0         object.size                  1296
18: 7225b47fe5dc51d0            accessed   2020-12-08 07:45:01
19: 7225b47fe5dc51d0             inCloud                 FALSE
20: 7225b47fe5dc51d0          resultHash                      
21: 7225b47fe5dc51d0   elapsedTimeDigest      0.001258612 secs
22: 7225b47fe5dc51d0 elapsedTimeFirstRun      0.000140667 secs
23: 7225b47fe5dc51d0      otherFunctions                      
24: 7225b47fe5dc51d0           preDigest    n:1393aef18608c8be
25: 7225b47fe5dc51d0           preDigest .FUN:881ec847b7161f3c
26: 7225b47fe5dc51d0           file.size                   393
27: f7bee22047b8d0c1          objectName                     a
28: f7bee22047b8d0c1            function                 rnorm
29: f7bee22047b8d0c1               class               numeric
30: f7bee22047b8d0c1         object.size                  1008
31: f7bee22047b8d0c1            accessed   2020-12-08 07:45:01
32: f7bee22047b8d0c1             inCloud                 FALSE
33: f7bee22047b8d0c1          resultHash                      
34: f7bee22047b8d0c1   elapsedTimeDigest      0.001292944 secs
35: f7bee22047b8d0c1 elapsedTimeFirstRun     8.416176e-05 secs
36: f7bee22047b8d0c1      otherFunctions                      
37: f7bee22047b8d0c1           preDigest    n:7eef4eae85fd9229
38: f7bee22047b8d0c1           preDigest .FUN:4f604aa46882b368
39: f7bee22047b8d0c1           file.size                   173
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:45:01
 2: 2020-12-08 07:45:01
 3: 2020-12-08 07:45:01
 4: 2020-12-08 07:45:01
 5: 2020-12-08 07:45:01
 6: 2020-12-08 07:45:01
 7: 2020-12-08 07:45:01
 8: 2020-12-08 07:45:01
 9: 2020-12-08 07:45:01
10: 2020-12-08 07:45:01
11: 2020-12-08 07:45:01
12: 2020-12-08 07:45:01
13: 2020-12-08 07:45:01
14: 2020-12-08 07:45:01
15: 2020-12-08 07:45:01
16: 2020-12-08 07:45:01
17: 2020-12-08 07:45:01
18: 2020-12-08 07:45:01
19: 2020-12-08 07:45:01
20: 2020-12-08 07:45:01
21: 2020-12-08 07:45:01
22: 2020-12-08 07:45:01
23: 2020-12-08 07:45:01
24: 2020-12-08 07:45:01
25: 2020-12-08 07:45:01
26: 2020-12-08 07:45:01
27: 2020-12-08 07:45:01
28: 2020-12-08 07:45:01
29: 2020-12-08 07:45:01
30: 2020-12-08 07:45:01
31: 2020-12-08 07:45:01
32: 2020-12-08 07:45:01
33: 2020-12-08 07:45:01
34: 2020-12-08 07:45:01
35: 2020-12-08 07:45:01
36: 2020-12-08 07:45:01
37: 2020-12-08 07:45:01
38: 2020-12-08 07:45:01
39: 2020-12-08 07:45:01
            createdDate
> showCache(tmpDir, userTags = c("^a$")) # regular expression ... "a" exactly
Cache size: 
  Total (including Rasters): 252 bytes
  Selected objects (not including Rasters): 252 bytes
             cacheId              tagKey              tagValue
 1: f7bee22047b8d0c1          objectName                     a
 2: f7bee22047b8d0c1            function                 rnorm
 3: f7bee22047b8d0c1               class               numeric
 4: f7bee22047b8d0c1         object.size                  1008
 5: f7bee22047b8d0c1            accessed   2020-12-08 07:45:01
 6: f7bee22047b8d0c1             inCloud                 FALSE
 7: f7bee22047b8d0c1          resultHash                      
 8: f7bee22047b8d0c1   elapsedTimeDigest      0.001292944 secs
 9: f7bee22047b8d0c1 elapsedTimeFirstRun     8.416176e-05 secs
10: f7bee22047b8d0c1      otherFunctions                      
11: f7bee22047b8d0c1           preDigest    n:7eef4eae85fd9229
12: f7bee22047b8d0c1           preDigest .FUN:4f604aa46882b368
13: f7bee22047b8d0c1           file.size                   173
            createdDate
 1: 2020-12-08 07:45:01
 2: 2020-12-08 07:45:01
 3: 2020-12-08 07:45:01
 4: 2020-12-08 07:45:01
 5: 2020-12-08 07:45:01
 6: 2020-12-08 07:45:01
 7: 2020-12-08 07:45:01
 8: 2020-12-08 07:45:01
 9: 2020-12-08 07:45:01
10: 2020-12-08 07:45:01
11: 2020-12-08 07:45:01
12: 2020-12-08 07:45:01
13: 2020-12-08 07:45:01
> 
> # Fine control of cache elements -- pick out only the large runif object, and remove it
> cache1 <- showCache(tmpDir, userTags = c("runif")) # show only cached objects made during runif
Cache size: 
  Total (including Rasters): 576 bytes
  Selected objects (not including Rasters): 576 bytes
> toRemove <- cache1[tagKey == "object.size"][as.numeric(tagValue) > 700]$cacheId
> clearCache(tmpDir, userTags = toRemove, ask = FALSE)
Cache size: 
  Total (including Rasters): 0 bytes
  Selected objects (not including Rasters): 0 bytes
> cacheAfter <- showCache(tmpDir, userTags = c("runif")) # Only the small one is left
Cache size: 
  Total (including Rasters): 576 bytes
  Selected objects (not including Rasters): 576 bytes
> 
> tmpDir <- file.path(tempdir(), "reproducible_examples", "Cache")
> try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear
> 
> Cache(rnorm, 1, cacheRepo = tmpDir)
[1] 0.364582
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:7072c305d8c69df0"
attr(,"call")
[1] ""
> thisTime <- Sys.time()
> Cache(rnorm, 2, cacheRepo = tmpDir)
[1]  0.7685329 -0.1123462
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:3b347dee8f6305c7"
attr(,"call")
[1] ""
> Cache(rnorm, 3, cacheRepo = tmpDir)
[1]  0.8811077  0.3981059 -0.6120264
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:f0da91a44b839434"
attr(,"call")
[1] ""
> Cache(rnorm, 4, cacheRepo = tmpDir)
[1]  0.3411197 -1.1293631  1.4330237  1.9803999
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:f7bee22047b8d0c1"
attr(,"call")
[1] ""
> showCache(x = tmpDir) # shows all 4 entries
Cache size: 
  Total (including Rasters): 998 bytes
  Selected objects (not including Rasters): 998 bytes
             cacheId              tagKey              tagValue
 1: 7072c305d8c69df0            function                 rnorm
 2: 7072c305d8c69df0               class               numeric
 3: 7072c305d8c69df0         object.size                   984
 4: 7072c305d8c69df0            accessed   2020-12-08 07:45:01
 5: 7072c305d8c69df0             inCloud                 FALSE
 6: 7072c305d8c69df0          resultHash                      
 7: 7072c305d8c69df0   elapsedTimeDigest      0.001236916 secs
 8: 7072c305d8c69df0 elapsedTimeFirstRun     8.320808e-05 secs
 9: 7072c305d8c69df0      otherFunctions                      
10: 7072c305d8c69df0           preDigest    n:853b1797f54b229c
11: 7072c305d8c69df0           preDigest .FUN:4f604aa46882b368
12: 7072c305d8c69df0           file.size                   147
13: 3b347dee8f6305c7            function                 rnorm
14: 3b347dee8f6305c7               class               numeric
15: 3b347dee8f6305c7         object.size                   992
16: 3b347dee8f6305c7            accessed   2020-12-08 07:45:01
17: 3b347dee8f6305c7             inCloud                 FALSE
18: 3b347dee8f6305c7          resultHash                      
19: 3b347dee8f6305c7   elapsedTimeDigest      0.001172066 secs
20: 3b347dee8f6305c7 elapsedTimeFirstRun     6.723404e-05 secs
21: 3b347dee8f6305c7      otherFunctions                      
22: 3b347dee8f6305c7           preDigest    n:82dc709f2b91918a
23: 3b347dee8f6305c7           preDigest .FUN:4f604aa46882b368
24: 3b347dee8f6305c7           file.size                   157
25: f0da91a44b839434            function                 rnorm
26: f0da91a44b839434               class               numeric
27: f0da91a44b839434         object.size                  1008
28: f0da91a44b839434            accessed   2020-12-08 07:45:01
29: f0da91a44b839434             inCloud                 FALSE
30: f0da91a44b839434          resultHash                      
31: f0da91a44b839434   elapsedTimeDigest      0.001166821 secs
32: f0da91a44b839434 elapsedTimeFirstRun     6.961823e-05 secs
33: f0da91a44b839434      otherFunctions                      
34: f0da91a44b839434           preDigest    n:7f12988bd88a0fb8
35: f0da91a44b839434           preDigest .FUN:4f604aa46882b368
36: f0da91a44b839434           file.size                   165
37: f7bee22047b8d0c1            function                 rnorm
38: f7bee22047b8d0c1               class               numeric
39: f7bee22047b8d0c1         object.size                  1008
40: f7bee22047b8d0c1            accessed   2020-12-08 07:45:01
41: f7bee22047b8d0c1             inCloud                 FALSE
42: f7bee22047b8d0c1          resultHash                      
43: f7bee22047b8d0c1   elapsedTimeDigest      0.001069307 secs
44: f7bee22047b8d0c1 elapsedTimeFirstRun     6.318092e-05 secs
45: f7bee22047b8d0c1      otherFunctions                      
46: f7bee22047b8d0c1           preDigest    n:7eef4eae85fd9229
47: f7bee22047b8d0c1           preDigest .FUN:4f604aa46882b368
48: f7bee22047b8d0c1           file.size                   174
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:45:01
 2: 2020-12-08 07:45:01
 3: 2020-12-08 07:45:01
 4: 2020-12-08 07:45:01
 5: 2020-12-08 07:45:01
 6: 2020-12-08 07:45:01
 7: 2020-12-08 07:45:01
 8: 2020-12-08 07:45:01
 9: 2020-12-08 07:45:01
10: 2020-12-08 07:45:01
11: 2020-12-08 07:45:01
12: 2020-12-08 07:45:01
13: 2020-12-08 07:45:01
14: 2020-12-08 07:45:01
15: 2020-12-08 07:45:01
16: 2020-12-08 07:45:01
17: 2020-12-08 07:45:01
18: 2020-12-08 07:45:01
19: 2020-12-08 07:45:01
20: 2020-12-08 07:45:01
21: 2020-12-08 07:45:01
22: 2020-12-08 07:45:01
23: 2020-12-08 07:45:01
24: 2020-12-08 07:45:01
25: 2020-12-08 07:45:01
26: 2020-12-08 07:45:01
27: 2020-12-08 07:45:01
28: 2020-12-08 07:45:01
29: 2020-12-08 07:45:01
30: 2020-12-08 07:45:01
31: 2020-12-08 07:45:01
32: 2020-12-08 07:45:01
33: 2020-12-08 07:45:01
34: 2020-12-08 07:45:01
35: 2020-12-08 07:45:01
36: 2020-12-08 07:45:01
37: 2020-12-08 07:45:01
38: 2020-12-08 07:45:01
39: 2020-12-08 07:45:01
40: 2020-12-08 07:45:01
41: 2020-12-08 07:45:01
42: 2020-12-08 07:45:01
43: 2020-12-08 07:45:01
44: 2020-12-08 07:45:01
45: 2020-12-08 07:45:01
46: 2020-12-08 07:45:01
47: 2020-12-08 07:45:01
48: 2020-12-08 07:45:01
            createdDate
> cc(ask = FALSE, x = tmpDir)
No time provided; removing the most recent entry to the Cache
Cache size: 
  Total (including Rasters): 252 bytes
  Selected objects (not including Rasters): 252 bytes
> showCache(x = tmpDir) # most recent is gone
Cache size: 
  Total (including Rasters): 746 bytes
  Selected objects (not including Rasters): 746 bytes
             cacheId              tagKey              tagValue
 1: 7072c305d8c69df0            function                 rnorm
 2: 7072c305d8c69df0               class               numeric
 3: 7072c305d8c69df0         object.size                   984
 4: 7072c305d8c69df0            accessed   2020-12-08 07:45:01
 5: 7072c305d8c69df0             inCloud                 FALSE
 6: 7072c305d8c69df0          resultHash                      
 7: 7072c305d8c69df0   elapsedTimeDigest      0.001236916 secs
 8: 7072c305d8c69df0 elapsedTimeFirstRun     8.320808e-05 secs
 9: 7072c305d8c69df0      otherFunctions                      
10: 7072c305d8c69df0           preDigest    n:853b1797f54b229c
11: 7072c305d8c69df0           preDigest .FUN:4f604aa46882b368
12: 7072c305d8c69df0           file.size                   147
13: 3b347dee8f6305c7            function                 rnorm
14: 3b347dee8f6305c7               class               numeric
15: 3b347dee8f6305c7         object.size                   992
16: 3b347dee8f6305c7            accessed   2020-12-08 07:45:01
17: 3b347dee8f6305c7             inCloud                 FALSE
18: 3b347dee8f6305c7          resultHash                      
19: 3b347dee8f6305c7   elapsedTimeDigest      0.001172066 secs
20: 3b347dee8f6305c7 elapsedTimeFirstRun     6.723404e-05 secs
21: 3b347dee8f6305c7      otherFunctions                      
22: 3b347dee8f6305c7           preDigest    n:82dc709f2b91918a
23: 3b347dee8f6305c7           preDigest .FUN:4f604aa46882b368
24: 3b347dee8f6305c7           file.size                   157
25: f0da91a44b839434            function                 rnorm
26: f0da91a44b839434               class               numeric
27: f0da91a44b839434         object.size                  1008
28: f0da91a44b839434            accessed   2020-12-08 07:45:01
29: f0da91a44b839434             inCloud                 FALSE
30: f0da91a44b839434          resultHash                      
31: f0da91a44b839434   elapsedTimeDigest      0.001166821 secs
32: f0da91a44b839434 elapsedTimeFirstRun     6.961823e-05 secs
33: f0da91a44b839434      otherFunctions                      
34: f0da91a44b839434           preDigest    n:7f12988bd88a0fb8
35: f0da91a44b839434           preDigest .FUN:4f604aa46882b368
36: f0da91a44b839434           file.size                   165
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:45:01
 2: 2020-12-08 07:45:01
 3: 2020-12-08 07:45:01
 4: 2020-12-08 07:45:01
 5: 2020-12-08 07:45:01
 6: 2020-12-08 07:45:01
 7: 2020-12-08 07:45:01
 8: 2020-12-08 07:45:01
 9: 2020-12-08 07:45:01
10: 2020-12-08 07:45:01
11: 2020-12-08 07:45:01
12: 2020-12-08 07:45:01
13: 2020-12-08 07:45:01
14: 2020-12-08 07:45:01
15: 2020-12-08 07:45:01
16: 2020-12-08 07:45:01
17: 2020-12-08 07:45:01
18: 2020-12-08 07:45:01
19: 2020-12-08 07:45:01
20: 2020-12-08 07:45:01
21: 2020-12-08 07:45:01
22: 2020-12-08 07:45:01
23: 2020-12-08 07:45:01
24: 2020-12-08 07:45:01
25: 2020-12-08 07:45:01
26: 2020-12-08 07:45:01
27: 2020-12-08 07:45:01
28: 2020-12-08 07:45:01
29: 2020-12-08 07:45:01
30: 2020-12-08 07:45:01
31: 2020-12-08 07:45:01
32: 2020-12-08 07:45:01
33: 2020-12-08 07:45:01
34: 2020-12-08 07:45:01
35: 2020-12-08 07:45:01
36: 2020-12-08 07:45:01
            createdDate
> cc(thisTime, ask = FALSE, x = tmpDir)
Cache size: 
  Total (including Rasters): 0 bytes
  Selected objects (not including Rasters): 0 bytes
> showCache(x = tmpDir) # all those after thisTime gone, i.e., only 1 left
Cache size: 
  Total (including Rasters): 746 bytes
  Selected objects (not including Rasters): 746 bytes
             cacheId              tagKey              tagValue
 1: 7072c305d8c69df0            function                 rnorm
 2: 7072c305d8c69df0               class               numeric
 3: 7072c305d8c69df0         object.size                   984
 4: 7072c305d8c69df0            accessed   2020-12-08 07:45:01
 5: 7072c305d8c69df0             inCloud                 FALSE
 6: 7072c305d8c69df0          resultHash                      
 7: 7072c305d8c69df0   elapsedTimeDigest      0.001236916 secs
 8: 7072c305d8c69df0 elapsedTimeFirstRun     8.320808e-05 secs
 9: 7072c305d8c69df0      otherFunctions                      
10: 7072c305d8c69df0           preDigest    n:853b1797f54b229c
11: 7072c305d8c69df0           preDigest .FUN:4f604aa46882b368
12: 7072c305d8c69df0           file.size                   147
13: 3b347dee8f6305c7            function                 rnorm
14: 3b347dee8f6305c7               class               numeric
15: 3b347dee8f6305c7         object.size                   992
16: 3b347dee8f6305c7            accessed   2020-12-08 07:45:01
17: 3b347dee8f6305c7             inCloud                 FALSE
18: 3b347dee8f6305c7          resultHash                      
19: 3b347dee8f6305c7   elapsedTimeDigest      0.001172066 secs
20: 3b347dee8f6305c7 elapsedTimeFirstRun     6.723404e-05 secs
21: 3b347dee8f6305c7      otherFunctions                      
22: 3b347dee8f6305c7           preDigest    n:82dc709f2b91918a
23: 3b347dee8f6305c7           preDigest .FUN:4f604aa46882b368
24: 3b347dee8f6305c7           file.size                   157
25: f0da91a44b839434            function                 rnorm
26: f0da91a44b839434               class               numeric
27: f0da91a44b839434         object.size                  1008
28: f0da91a44b839434            accessed   2020-12-08 07:45:01
29: f0da91a44b839434             inCloud                 FALSE
30: f0da91a44b839434          resultHash                      
31: f0da91a44b839434   elapsedTimeDigest      0.001166821 secs
32: f0da91a44b839434 elapsedTimeFirstRun     6.961823e-05 secs
33: f0da91a44b839434      otherFunctions                      
34: f0da91a44b839434           preDigest    n:7f12988bd88a0fb8
35: f0da91a44b839434           preDigest .FUN:4f604aa46882b368
36: f0da91a44b839434           file.size                   165
             cacheId              tagKey              tagValue
            createdDate
 1: 2020-12-08 07:45:01
 2: 2020-12-08 07:45:01
 3: 2020-12-08 07:45:01
 4: 2020-12-08 07:45:01
 5: 2020-12-08 07:45:01
 6: 2020-12-08 07:45:01
 7: 2020-12-08 07:45:01
 8: 2020-12-08 07:45:01
 9: 2020-12-08 07:45:01
10: 2020-12-08 07:45:01
11: 2020-12-08 07:45:01
12: 2020-12-08 07:45:01
13: 2020-12-08 07:45:01
14: 2020-12-08 07:45:01
15: 2020-12-08 07:45:01
16: 2020-12-08 07:45:01
17: 2020-12-08 07:45:01
18: 2020-12-08 07:45:01
19: 2020-12-08 07:45:01
20: 2020-12-08 07:45:01
21: 2020-12-08 07:45:01
22: 2020-12-08 07:45:01
23: 2020-12-08 07:45:01
24: 2020-12-08 07:45:01
25: 2020-12-08 07:45:01
26: 2020-12-08 07:45:01
27: 2020-12-08 07:45:01
28: 2020-12-08 07:45:01
29: 2020-12-08 07:45:01
30: 2020-12-08 07:45:01
31: 2020-12-08 07:45:01
32: 2020-12-08 07:45:01
33: 2020-12-08 07:45:01
34: 2020-12-08 07:45:01
35: 2020-12-08 07:45:01
36: 2020-12-08 07:45:01
            createdDate
> cc(ask = FALSE, x = tmpDir) # Cache is
No time provided; removing the most recent entry to the Cache
Cache size: 
  Total (including Rasters): 252 bytes
  Selected objects (not including Rasters): 252 bytes
> cc(ask = FALSE, x = tmpDir) # Cache is already empty
No time provided; removing the most recent entry to the Cache
Cache size: 
  Total (including Rasters): 248 bytes
  Selected objects (not including Rasters): 248 bytes
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> nameEx("writeOutputs")
> ### * writeOutputs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: writeOutputs
> ### Title: Write module inputs on disk
> ### Aliases: writeOutputs writeOutputs.Raster writeOutputs.Spatial
> ###   writeOutputs.sf writeOutputs.quosure writeOutputs.default
> 
> ### ** Examples
> 
> # Add a study area to Crop and Mask to
> # Create a "study area"
> library(sp)
> library(raster)
> ow <- setwd(tempdir())
> 
> # make a SpatialPolygon
> coords1 <- structure(c(-123.98, -117.1, -80.2, -100, -123.98, 60.9, 67.73, 65.58, 51.79, 60.9),
+                      .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords1)
> Srs1 <- Polygons(list(Sr1), "s1")
> shpEcozone <- SpatialPolygons(list(Srs1), 1L)
> crs(shpEcozone) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> # make a "study area" that is subset of larger dataset
> coords <- structure(c(-118.98, -116.1, -99.2, -106, -118.98, 59.9, 65.73, 63.58, 54.79, 59.9),
+                     .Dim = c(5L, 2L))
> Sr1 <- Polygon(coords)
> Srs1 <- Polygons(list(Sr1), "s1")
> StudyArea <- SpatialPolygons(list(Srs1), 1L)
> crs(StudyArea) <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##########
> shpEcozonePostProcessed <- postProcess(shpEcozone, studyArea = StudyArea)
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (08770b276d911ac4.rds))
     loaded cached result from previous cropInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (76528e519d1ce0eb.rds))
     loaded cached result from previous projectInputs call, 
Checking for errors in SpatialPolygon
  Found no errors.
No cacheRepo supplied and getOption('reproducible.cachePath') is inside a temporary directory;
  this will not persist across R sessions.
  ...(Object to retrieve (5dd32a7c7590448e.rds))
     loaded cached result from previous maskInputs call, 
  Skipping writeOutputs; filename2 is NULL
> 
> # Try manually, individual pieces
> shpEcozoneReprojected <- projectInputs(shpEcozone, StudyArea)
    reprojecting ...
> shpEcozoneCropped <- cropInputs(shpEcozone, StudyArea)
    cropping ...
      useGDAL is TRUE, but problem is small enough for RAM; skipping GDAL; useGDAL = 'force' to override
Checking for errors in SpatialPolygon
  Found no errors.
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
Warning in st_buffer.sfc(st_geometry(x), dist, nQuadSegs, endCapStyle = endCapStyle,  :
  st_buffer does not correctly buffer longitude/latitude data
dist is assumed to be in decimal degrees (arc_degrees).
although coordinates are longitude/latitude, st_intersection assumes that they are planar
> shpEcozoneClean <- fixErrors(shpEcozone)
Checking for errors in SpatialPolygon
  Found no errors.
> shpEcozoneMasked <- maskInputs(shpEcozone, StudyArea)
Checking for errors in SimpleFeature
  Found no errors.
maskInputs with sf class objects is still experimental
    intersecting ...
Checking for errors in SimpleFeature
  Found no errors.
although coordinates are longitude/latitude, st_intersection assumes that they are planar
dist is assumed to be in decimal degrees (arc_degrees).
> 
> setwd(ow)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()

detaching ‘package:raster’, ‘package:sp’

> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  34.599 2.101 40.755 0.096 0.168 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
