
R Under development (unstable) (2017-08-15 r73096) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "multinet"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('multinet')
Loading required package: igraph

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

Loading required package: Rcpp
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ActorMeasures")
> ### * ActorMeasures
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Measures: basic
> ### Title: Network analysis measures
> ### Aliases: 'Measures: basic' degree.ml degree.deviation.ml
> ###   neighborhood.ml xneighborhood.ml connective.redundancy.ml
> ###   relevance.ml xrelevance.ml
> 
> ### ** Examples
> 
> net <- ml.aucs()
> # degrees of all actors, considering edges on all layers
> degree.ml(net)
 U18  U65  U13 U141  U32  U17  U76  U10   U4  U79  U21  U19 U134  U59  U33 U123 
  25   18    9    7   32   18   32   22   49   44   13   16   18   19   15   44 
U124 U126  U41 U130  U23   U6  U86  U63 U118 U106  U22 U142  U26 U113  U90  U14 
  25   27   11   39   16   13    3   11   19   21   13   21   24   19   23   22 
 U47  U48  U49  U92 U107  U37 U109 U110  U53 U138   U3  U72  U42  U29  U54   U1 
  23   10   11    7   17    9   25   41   11   12   18   20   19   17   35   31 
U102  U73  U67 U112  U69 U140  U91  U71  U62  U99  U68 U139  U97 
   2   20   47    7   17    2   46   30   16   18   12   12   17 
> # degree of actors U54 and U3, only considering layers work and coauthor
> degree.ml(net,c("U54","U3"),c("work","coauthor"),"in")
U54  U3 
  8   2 
> # an indication of whether U54 and U3 are selectively active only on some layers
> degree.deviation.ml(net,c("U54","U3"))
     U54       U3 
3.577709 2.870540 
> # co-workers of U54
> neighborhood.ml(net,"U54","work")
U54 
  8 
> # co-workers of U54 who are not connected to U54 on other layers
> xneighborhood.ml(net,"U54","work")
U54 
  4 
> # percentage of neighbors of U54 who are also co-workers
> relevance.ml(net,"U54","work")
      U54 
0.4210526 
> # redundancy between work and lunch
> connective.redundancy.ml(net,"U54",c("work","lunch"))
      U54 
0.1764706 
> # percentage of neighbors of U54 who would no longer
> # be neighbors by removing this layer
> xrelevance.ml(net,"U54","work")
      U54 
0.2105263 
> 
> 
> 
> cleanEx()
> nameEx("Attributes")
> ### * Attributes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Network management: attributes
> ### Title: Managing attributes
> ### Aliases: 'Network management: attributes' new.attributes.ml
> ###   list.attributes.ml set.values.ml get.values.ml
> 
> ### ** Examples
> 
> net <- ml.aucs()
> list.attributes.ml(net)
   name   type
1 group string
2  role string
> # actor attributes, of string type (default)
> new.attributes.ml(net,c("name","surname"))
> # a numeric attribute associated to the layers
> new.attributes.ml(net,"num nodes",type="numeric",target="layer")
> # attributes for nodes on the facebook layer
> new.attributes.ml(net,"username",type="string",target="node",layer="facebook")
> # attributes for edges on the work layer
> new.attributes.ml(net,"strength",type="numeric",target="edge",layer="work")
> # listing the attributes
> list.attributes.ml(net)
     name   type
1   group string
2    role string
3    name string
4 surname string
> list.attributes.ml(net,"layer")
       name    type
1 num nodes numeric
> list.attributes.ml(net,"node")
     layer     name   type
1 facebook username string
> list.attributes.ml(net,"edge")
  layer1 layer2     name    type
1   work   work strength numeric
> # setting some values for the newly created attributes
> set.values.ml(net,"name",actors=c("U54","U139"),values=c("John","Johanna"))
> e <- data.frame(
+     c("U139","U139"),
+     c("work","work"),
+     c("U71","U97"),
+     c("work","work"))
> set.values.ml(net,"strength",edges=e,values=.47)
> # getting the values back
> get.values.ml(net,"name",actors=c("U139"))
    value
1 Johanna
> get.values.ml(net,"strength",edges=e)
  value
1  0.47
2  0.47
> # setting attributes based on network properties: create a "degree"
> # attribute and set its value to the degree of each actor
> actors.ml(net) -> a
> layers.ml(net) -> l
> degree.ml(net,actors=a,layers=l,mode="all") -> d
> new.attributes.ml(net,target="actor",type="numeric",attributes="degree")
> set.values.ml(net,attribute="degree",actors=a,values=d)
> get.values.ml(net,attribute="degree",actors="U54")
  value
1    35
> # select actors based on attribute values (e.g., with degree greater than 40)
> get.values.ml(net,attribute="degree",actors=a) -> degrees
> a[degrees>40]
[1] "U4"   "U67"  "U79"  "U91"  "U110" "U123"
> # list all the attributes again
> list.attributes.ml(net)
     name    type
1   group  string
2    role  string
3    name  string
4 surname  string
5  degree numeric
> 
> 
> 
> cleanEx()
> nameEx("Communities")
> ### * Communities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Mining: communities
> ### Title: Community detection algorithms
> ### Aliases: 'Mining: communities' abacus.ml clique.percolation.ml
> ###   glouvain.ml lart.ml get.community.list.ml
> 
> ### ** Examples
> 
> net <- ml.florentine()
> abacus.ml(net)

 *** caught segfault ***
address 0x8, cause 'memory not mapped'

Traceback:
 1: abacus.ml(net)
An irrecoverable exception occurred. R is aborting now ...
Segmentation fault (core dumped)
