
R Under development (unstable) (2019-06-25 r76738) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "bzinb"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('bzinb')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("bnb")
> ### * bnb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bnb
> ### Title: The bivariate negative binomial distribution
> ### Aliases: bnb lik.bnb rbnb
> 
> ### ** Examples
> 
> # generating a pair of random vectors
> set.seed(1)
> data1 <- rbnb(n = 20, a0 = 1, a1 = 1, a2 = 1, 
+                 b1 = 1, b2 = 1)
> 
> lik.bnb(xvec = data1[, 1], yvec = data1[ ,2], 
+           a0 = 1, a1 = 1, a2 = 1, b1 = 1, b2 = 1) 
[1] -69.87918
> 
> bnb(xvec = data1[,1], yvec = data1[,2], showFlag = FALSE)
        a0         a1         a2         b1         b2 
3.34038638 1.39319874 0.00242203 0.45434926 0.48969219 
> 
> 
> 
> 
> cleanEx()
> nameEx("bp")
> ### * bp
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bp
> ### Title: The bivariate poisson distribution
> ### Aliases: bp lik.bp rbp
> 
> ### ** Examples
> 
> # generating a pair of random vectors
> set.seed(1)
> data1 <- rbp(n = 20, m0 = 1, m1 = 1, m2 = 1)
> 
> lik.bp(xvec = data1[, 1], yvec = data1[ ,2], 
+           m0 = 1, m1 = 1, m2 = 1) 
[1] -61.85141
> 
> bp(xvec = data1[,1], yvec = data1[,2])
        mu0    mu1.xvec    mu2.yvec  likelihood 
  1.4093739   0.5906261   0.6906261 -60.8331384 
> 
> 
> 
> 
> cleanEx()
> nameEx("bzinb")
> ### * bzinb
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bzinb
> ### Title: The bivariate zero-inflated negative binomial distribution
> ### Aliases: bzinb lik.bzinb rbzinb
> 
> ### ** Examples
> 
> # generating a pair of random vectors
> set.seed(2)
> data1 <- rbzinb(n = 20, a0 = 1, a1 = 1, a2 = 1, 
+                 b1 = 1, b2 = 1, p1 = 0.5, p2 = 0.2, 
+                 p3 = 0.2, p4 = 0.1)
> 
> lik.bzinb(xvec = data1[, 1], yvec = data1[ ,2], 
+           a0 = 1, a1 = 1, a2 = 1, b1 = 1, b2 = 1, 
+           p1 = 0.5, p2 = 0.2, p3 = 0.2, p4 = 0.1)
[1] -56.06595
> 
> bzinb(xvec = data1[,1], yvec = data1[,2], showFlag = FALSE)
ERROR: modification of compiler constant of type integer, length 1
ERROR: the modified value of the constant is:
[1] 154
ERROR: the original value of the constant is:
[1] 0
ERROR: the modified constant is at index 208
ERROR: the modified constant is in this function body:
{
    se = TRUE
    xy.reduced <- as.data.frame(table(xvec, yvec))
    names(xy.reduced) <- c("x", "y", "freq")
    xy.reduced <- xy.reduced[xy.reduced$freq != 0, ]
    xy.reduced$x <- as.numeric(as.character(xy.reduced$x))
    xy.reduced$y <- as.numeric(as.character(xy.reduced$y))
    xy.reduced$freq <- as.numeric(as.character(xy.reduced$freq))
    n <- sum(xy.reduced$freq)
    n.reduced <- as.integer(length(xy.reduced$freq))
    if (max(xvec) == 0 & max(yvec) == 0) {
        return(c(rep(1e-10, 5), 1, 0, 0, 0, 0, 1, 0, if (se) {
            rep(NA, 11)
        }))
    }
    info <- if (se) {
        matrix(0, ncol = 8, nrow = 8, dimnames = list(abp.names[-9], 
            abp.names[-9]))
    }
    else {
        0
    }
    if (is.null(initial)) {
        xbar <- mean(xvec)
        ybar <- mean(yvec)
        xybar <- mean(c(xbar, ybar))
        s2.x <- var(xvec)
        s2.y <- var(yvec)
        if (is.na(s2.x) | is.na(s2.y)) {
            s2.x <- s2.y <- 1
        }
        cor.xy <- cor(xvec, yvec)
        if (is.na(cor.xy)) {
            cor.xy <- 0
        }
        zero <- sum(xvec == 0 & yvec == 0)/n
        initial <- rep(NA, 9)
        names(initial) <- c("a0", "a1", "a2", "b1", "b2", "p1", 
            "p2", "p3", "p4")
        initial[4] <- s2.x/ifelse(xbar == 0, 1e-04, xbar)
        initial[5] <- s2.y/ifelse(ybar == 0, 1e-04, ybar)
        initial[2:3] <- c(xbar, ybar)/pmax(initial[4:5], c(0.1, 
            0.1))
        initial[1] <- min(initial[2:3]) * abs(cor.xy)
        initial[2:3] <- initial[2:3] - initial[1]
        initial[6:9] <- bin.profile(xvec, yvec)
        initial[6:9] <- initial[6:9]/sum(initial[6:9])
        initial <- pmax(initial, 1e-05)
        if (is.na(sum(initial))) {
            initial[is.na(initial)] <- 1
        }
    }
    else {
        names(initial) <- abp.names
    }
    iter = 0L
    param = initial
    lik = -Inf
    expt = setNames(as.double(rep(0, 12)), expt.names)
    lik.vec = rep(0, maxiter + 1)
    nonconv = 0L
    em(param2 = param, xvec = xy.reduced$x, yvec = xy.reduced$y, 
        freq = xy.reduced$freq, n = n.reduced, expt = expt, info = info, 
        se = as.integer(se), iter = as.integer(iter), maxiter = as.integer(maxiter), 
        tol = as.double(tol), showFlag = as.integer(showFlag), 
        nonconv = nonconv, trajectory = lik.vec)
    if (nonconv == 1) 
        warning("The iteration exited before reaching convergence.")
    rho <- param[1]/sqrt((param[1] + param[2]) * (param[1] + 
        param[3])) * sqrt(param[4] * param[5]/(param[4] + 1)/(param[5] + 
        1))
    logit.rho <- qlogis(rho)
    if (se) {
        qr.info <- try(qr(info))
        if (class(qr.info) == "try-error") {
            warning("The information matrix has NA/NaN/Inf and thus the standard error is not properly estimatd.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else if (qr(info)$rank < 8) {
            warning("The information matrix is (essentially) not full rank, and thus the standard error is not reliable.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else {
            cov.mat <- try(solve(info))
            if (class(cov.mat) == "try-error") {
                std.param = setNames(rep(NA, 11), c(abp.names, 
                  "rho", "logit.rho"))
                cov.mat <- NA
            }
            else {
                var.p4 <- sum(cov.mat[6:8, 6:8])
                d.g <- rho * c(1/param[1] - 1/{
                  2 * (param[1] + param[2])
                } - 1/{
                  2 * (param[1] + param[3])
                }, -1/{
                  2 * (param[1] + param[2])
                }, -1/{
                  2 * (param[1] + param[3])
                }, 1/{
                  2 * param[4] * (param[4] + 1)
                }, 1/{
                  2 * param[5] * (param[5] + 1)
                })
                var.rho <- t(d.g) %*% cov.mat[1:5, 1:5] %*% d.g
                var.logit.rho <- var.rho/rho^2/(1 - rho)^2
                std.param = sqrt(c(diag(cov.mat), p4 = var.p4, 
                  rho = var.rho, logit.rho = var.logit.rho))
            }
        }
    }
    result <- list(rho = matrix(c(rho, logit.rho, if (se) std.param[c("rho", 
        "logit.rho")] else rep(NA, 2)), ncol = 2, dimnames = list(c("rho", 
        "logit.rho"), c("Estimate", "Std.err"))), coefficients = matrix(c(param, 
        if (se) std.param[1:9] else rep(NA, 9)), ncol = 2, dimnames = list(abp.names, 
        c("Estimate", "Std.err"))), lik = expt[1], iter = iter)
    if (se & vcov) {
        result$info = info
        result$vcov = cov.mat
    }
    return(result)
}
Function bzinb.base in namespace bzinb has this body.
ERROR: detected compiler constant(s) modification after .Call invocation of function _bzinb_em from library bzinb (/var/scratch2/tomas/cran/rcnst/lib/bzinb/libs/bzinb.so).
NOTE: .Call function _bzinb_em modified its argument (number 1, type double, length 9)
NOTE: .Call function _bzinb_em modified its argument (number 6, type double, length 12)
NOTE: .Call function _bzinb_em modified its argument (number 7, type double, length 64)
NOTE: .Call function _bzinb_em modified its argument (number 9, type integer, length 1)
NOTE: .Call function _bzinb_em modified its argument (number 13, type integer, length 1)
NOTE: .Call function _bzinb_em modified its argument (number 14, type double, length 50001)
Fatal error: compiler constants were modified (in .Call?)!

ERROR: modification of compiler constant of type integer, length 1
ERROR: the modified value of the constant is:
[1] 154
ERROR: the original value of the constant is:
[1] 0
ERROR: the modified constant is at index 208
ERROR: the modified constant is in this function body:
{
    se = TRUE
    xy.reduced <- as.data.frame(table(xvec, yvec))
    names(xy.reduced) <- c("x", "y", "freq")
    xy.reduced <- xy.reduced[xy.reduced$freq != 0, ]
    xy.reduced$x <- as.numeric(as.character(xy.reduced$x))
    xy.reduced$y <- as.numeric(as.character(xy.reduced$y))
    xy.reduced$freq <- as.numeric(as.character(xy.reduced$freq))
    n <- sum(xy.reduced$freq)
    n.reduced <- as.integer(length(xy.reduced$freq))
    if (max(xvec) == 0 & max(yvec) == 0) {
        return(c(rep(1e-10, 5), 1, 0, 0, 0, 0, 1, 0, if (se) {
            rep(NA, 11)
        }))
    }
    info <- if (se) {
        matrix(0, ncol = 8, nrow = 8, dimnames = list(abp.names[-9], 
            abp.names[-9]))
    }
    else {
        0
    }
    if (is.null(initial)) {
        xbar <- mean(xvec)
        ybar <- mean(yvec)
        xybar <- mean(c(xbar, ybar))
        s2.x <- var(xvec)
        s2.y <- var(yvec)
        if (is.na(s2.x) | is.na(s2.y)) {
            s2.x <- s2.y <- 1
        }
        cor.xy <- cor(xvec, yvec)
        if (is.na(cor.xy)) {
            cor.xy <- 0
        }
        zero <- sum(xvec == 0 & yvec == 0)/n
        initial <- rep(NA, 9)
        names(initial) <- c("a0", "a1", "a2", "b1", "b2", "p1", 
            "p2", "p3", "p4")
        initial[4] <- s2.x/ifelse(xbar == 0, 1e-04, xbar)
        initial[5] <- s2.y/ifelse(ybar == 0, 1e-04, ybar)
        initial[2:3] <- c(xbar, ybar)/pmax(initial[4:5], c(0.1, 
            0.1))
        initial[1] <- min(initial[2:3]) * abs(cor.xy)
        initial[2:3] <- initial[2:3] - initial[1]
        initial[6:9] <- bin.profile(xvec, yvec)
        initial[6:9] <- initial[6:9]/sum(initial[6:9])
        initial <- pmax(initial, 1e-05)
        if (is.na(sum(initial))) {
            initial[is.na(initial)] <- 1
        }
    }
    else {
        names(initial) <- abp.names
    }
    iter = 0L
    param = initial
    lik = -Inf
    expt = setNames(as.double(rep(0, 12)), expt.names)
    lik.vec = rep(0, maxiter + 1)
    nonconv = 0L
    em(param2 = param, xvec = xy.reduced$x, yvec = xy.reduced$y, 
        freq = xy.reduced$freq, n = n.reduced, expt = expt, info = info, 
        se = as.integer(se), iter = as.integer(iter), maxiter = as.integer(maxiter), 
        tol = as.double(tol), showFlag = as.integer(showFlag), 
        nonconv = nonconv, trajectory = lik.vec)
    if (nonconv == 1) 
        warning("The iteration exited before reaching convergence.")
    rho <- param[1]/sqrt((param[1] + param[2]) * (param[1] + 
        param[3])) * sqrt(param[4] * param[5]/(param[4] + 1)/(param[5] + 
        1))
    logit.rho <- qlogis(rho)
    if (se) {
        qr.info <- try(qr(info))
        if (class(qr.info) == "try-error") {
            warning("The information matrix has NA/NaN/Inf and thus the standard error is not properly estimatd.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else if (qr(info)$rank < 8) {
            warning("The information matrix is (essentially) not full rank, and thus the standard error is not reliable.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else {
            cov.mat <- try(solve(info))
            if (class(cov.mat) == "try-error") {
                std.param = setNames(rep(NA, 11), c(abp.names, 
                  "rho", "logit.rho"))
                cov.mat <- NA
            }
            else {
                var.p4 <- sum(cov.mat[6:8, 6:8])
                d.g <- rho * c(1/param[1] - 1/{
                  2 * (param[1] + param[2])
                } - 1/{
                  2 * (param[1] + param[3])
                }, -1/{
                  2 * (param[1] + param[2])
                }, -1/{
                  2 * (param[1] + param[3])
                }, 1/{
                  2 * param[4] * (param[4] + 1)
                }, 1/{
                  2 * param[5] * (param[5] + 1)
                })
                var.rho <- t(d.g) %*% cov.mat[1:5, 1:5] %*% d.g
                var.logit.rho <- var.rho/rho^2/(1 - rho)^2
                std.param = sqrt(c(diag(cov.mat), p4 = var.p4, 
                  rho = var.rho, logit.rho = var.logit.rho))
            }
        }
    }
    result <- list(rho = matrix(c(rho, logit.rho, if (se) std.param[c("rho", 
        "logit.rho")] else rep(NA, 2)), ncol = 2, dimnames = list(c("rho", 
        "logit.rho"), c("Estimate", "Std.err"))), coefficients = matrix(c(param, 
        if (se) std.param[1:9] else rep(NA, 9)), ncol = 2, dimnames = list(abp.names, 
        c("Estimate", "Std.err"))), lik = expt[1], iter = iter)
    if (se & vcov) {
        result$info = info
        result$vcov = cov.mat
    }
    return(result)
}
Function bzinb.base in namespace bzinb has this body.
Fatal error: compiler constants were modified!

