* using log directory ‘/var/scratch2/tomas/cran/rcnst/check/bzinb.Rcheck’
* using R Under development (unstable) (2019-06-25 r76738)
* using platform: x86_64-pc-linux-gnu (64-bit)
* using session charset: UTF-8
* checking for file ‘bzinb/DESCRIPTION’ ... OK
* checking extension type ... Package
* this is package ‘bzinb’ version ‘1.0.1’
* package encoding: UTF-8
* checking package namespace information ... OK
* checking package dependencies ... OK
* checking if this is a source package ... OK
* checking if there is a namespace ... OK
* checking for executable files ... OK
* checking for hidden files and directories ... OK
* checking for portable file names ... OK
* checking for sufficient/correct file permissions ... OK
* checking whether package ‘bzinb’ can be installed ... OK
* checking package directory ... OK
* checking DESCRIPTION meta-information ... OK
* checking top-level files ... OK
* checking for left-over files ... OK
* checking index information ... OK
* checking package subdirectories ... OK
* checking R files for non-ASCII characters ... OK
* checking R files for syntax errors ... OK
* checking whether the package can be loaded ... OK
* checking whether the package can be loaded with stated dependencies ... OK
* checking whether the package can be unloaded cleanly ... OK
* checking whether the namespace can be loaded with stated dependencies ... OK
* checking whether the namespace can be unloaded cleanly ... OK
* checking loading without being on the library search path ... OK
* checking dependencies in R code ... OK
* checking S3 generic/method consistency ... OK
* checking replacement functions ... OK
* checking foreign function calls ... OK
* checking R code for possible problems ... OK
* checking Rd files ... OK
* checking Rd metadata ... OK
* checking Rd cross-references ... OK
* checking for missing documentation entries ... OK
* checking for code/documentation mismatches ... OK
* checking Rd \usage sections ... OK
* checking Rd contents ... OK
* checking for unstated dependencies in examples ... OK
* checking line endings in C/C++/Fortran sources/headers ... OK
* checking line endings in Makefiles ... OK
* checking compilation flags in Makevars ... OK
* checking for GNU extensions in Makefiles ... OK
* checking for portable use of $(BLAS_LIBS) and $(LAPACK_LIBS) ... OK
* checking use of PKG_*FLAGS in Makefiles ... OK
* checking compiled code ... NOTE
Note: information on .o files is not available
* checking examples ... ERROR
Running examples in ‘bzinb-Ex.R’ failed
The error most likely occurred in:

> ### Name: bzinb
> ### Title: The bivariate zero-inflated negative binomial distribution
> ### Aliases: bzinb lik.bzinb rbzinb
> 
> ### ** Examples
> 
> # generating a pair of random vectors
> set.seed(2)
> data1 <- rbzinb(n = 20, a0 = 1, a1 = 1, a2 = 1, 
+                 b1 = 1, b2 = 1, p1 = 0.5, p2 = 0.2, 
+                 p3 = 0.2, p4 = 0.1)
> 
> lik.bzinb(xvec = data1[, 1], yvec = data1[ ,2], 
+           a0 = 1, a1 = 1, a2 = 1, b1 = 1, b2 = 1, 
+           p1 = 0.5, p2 = 0.2, p3 = 0.2, p4 = 0.1)
[1] -56.06595
> 
> bzinb(xvec = data1[,1], yvec = data1[,2], showFlag = FALSE)
ERROR: modification of compiler constant of type integer, length 1
ERROR: the modified value of the constant is:
[1] 154
ERROR: the original value of the constant is:
[1] 0
ERROR: the modified constant is at index 208
ERROR: the modified constant is in this function body:
{
    se = TRUE
    xy.reduced <- as.data.frame(table(xvec, yvec))
    names(xy.reduced) <- c("x", "y", "freq")
    xy.reduced <- xy.reduced[xy.reduced$freq != 0, ]
    xy.reduced$x <- as.numeric(as.character(xy.reduced$x))
    xy.reduced$y <- as.numeric(as.character(xy.reduced$y))
    xy.reduced$freq <- as.numeric(as.character(xy.reduced$freq))
    n <- sum(xy.reduced$freq)
    n.reduced <- as.integer(length(xy.reduced$freq))
    if (max(xvec) == 0 & max(yvec) == 0) {
        return(c(rep(1e-10, 5), 1, 0, 0, 0, 0, 1, 0, if (se) {
            rep(NA, 11)
        }))
    }
    info <- if (se) {
        matrix(0, ncol = 8, nrow = 8, dimnames = list(abp.names[-9], 
            abp.names[-9]))
    }
    else {
        0
    }
    if (is.null(initial)) {
        xbar <- mean(xvec)
        ybar <- mean(yvec)
        xybar <- mean(c(xbar, ybar))
        s2.x <- var(xvec)
        s2.y <- var(yvec)
        if (is.na(s2.x) | is.na(s2.y)) {
            s2.x <- s2.y <- 1
        }
        cor.xy <- cor(xvec, yvec)
        if (is.na(cor.xy)) {
            cor.xy <- 0
        }
        zero <- sum(xvec == 0 & yvec == 0)/n
        initial <- rep(NA, 9)
        names(initial) <- c("a0", "a1", "a2", "b1", "b2", "p1", 
            "p2", "p3", "p4")
        initial[4] <- s2.x/ifelse(xbar == 0, 1e-04, xbar)
        initial[5] <- s2.y/ifelse(ybar == 0, 1e-04, ybar)
        initial[2:3] <- c(xbar, ybar)/pmax(initial[4:5], c(0.1, 
            0.1))
        initial[1] <- min(initial[2:3]) * abs(cor.xy)
        initial[2:3] <- initial[2:3] - initial[1]
        initial[6:9] <- bin.profile(xvec, yvec)
        initial[6:9] <- initial[6:9]/sum(initial[6:9])
        initial <- pmax(initial, 1e-05)
        if (is.na(sum(initial))) {
            initial[is.na(initial)] <- 1
        }
    }
    else {
        names(initial) <- abp.names
    }
    iter = 0L
    param = initial
    lik = -Inf
    expt = setNames(as.double(rep(0, 12)), expt.names)
    lik.vec = rep(0, maxiter + 1)
    nonconv = 0L
    em(param2 = param, xvec = xy.reduced$x, yvec = xy.reduced$y, 
        freq = xy.reduced$freq, n = n.reduced, expt = expt, info = info, 
        se = as.integer(se), iter = as.integer(iter), maxiter = as.integer(maxiter), 
        tol = as.double(tol), showFlag = as.integer(showFlag), 
        nonconv = nonconv, trajectory = lik.vec)
    if (nonconv == 1) 
        warning("The iteration exited before reaching convergence.")
    rho <- param[1]/sqrt((param[1] + param[2]) * (param[1] + 
        param[3])) * sqrt(param[4] * param[5]/(param[4] + 1)/(param[5] + 
        1))
    logit.rho <- qlogis(rho)
    if (se) {
        qr.info <- try(qr(info))
        if (class(qr.info) == "try-error") {
            warning("The information matrix has NA/NaN/Inf and thus the standard error is not properly estimatd.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else if (qr(info)$rank < 8) {
            warning("The information matrix is (essentially) not full rank, and thus the standard error is not reliable.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else {
            cov.mat <- try(solve(info))
            if (class(cov.mat) == "try-error") {
                std.param = setNames(rep(NA, 11), c(abp.names, 
                  "rho", "logit.rho"))
                cov.mat <- NA
            }
            else {
                var.p4 <- sum(cov.mat[6:8, 6:8])
                d.g <- rho * c(1/param[1] - 1/{
                  2 * (param[1] + param[2])
                } - 1/{
                  2 * (param[1] + param[3])
                }, -1/{
                  2 * (param[1] + param[2])
                }, -1/{
                  2 * (param[1] + param[3])
                }, 1/{
                  2 * param[4] * (param[4] + 1)
                }, 1/{
                  2 * param[5] * (param[5] + 1)
                })
                var.rho <- t(d.g) %*% cov.mat[1:5, 1:5] %*% d.g
                var.logit.rho <- var.rho/rho^2/(1 - rho)^2
                std.param = sqrt(c(diag(cov.mat), p4 = var.p4, 
                  rho = var.rho, logit.rho = var.logit.rho))
            }
        }
    }
    result <- list(rho = matrix(c(rho, logit.rho, if (se) std.param[c("rho", 
        "logit.rho")] else rep(NA, 2)), ncol = 2, dimnames = list(c("rho", 
        "logit.rho"), c("Estimate", "Std.err"))), coefficients = matrix(c(param, 
        if (se) std.param[1:9] else rep(NA, 9)), ncol = 2, dimnames = list(abp.names, 
        c("Estimate", "Std.err"))), lik = expt[1], iter = iter)
    if (se & vcov) {
        result$info = info
        result$vcov = cov.mat
    }
    return(result)
}
Function bzinb.base in namespace bzinb has this body.
ERROR: detected compiler constant(s) modification after .Call invocation of function _bzinb_em from library bzinb (/var/scratch2/tomas/cran/rcnst/lib/bzinb/libs/bzinb.so).
NOTE: .Call function _bzinb_em modified its argument (number 1, type double, length 9)
NOTE: .Call function _bzinb_em modified its argument (number 6, type double, length 12)
NOTE: .Call function _bzinb_em modified its argument (number 7, type double, length 64)
NOTE: .Call function _bzinb_em modified its argument (number 9, type integer, length 1)
NOTE: .Call function _bzinb_em modified its argument (number 13, type integer, length 1)
NOTE: .Call function _bzinb_em modified its argument (number 14, type double, length 50001)
Fatal error: compiler constants were modified (in .Call?)!

ERROR: modification of compiler constant of type integer, length 1
ERROR: the modified value of the constant is:
[1] 154
ERROR: the original value of the constant is:
[1] 0
ERROR: the modified constant is at index 208
ERROR: the modified constant is in this function body:
{
    se = TRUE
    xy.reduced <- as.data.frame(table(xvec, yvec))
    names(xy.reduced) <- c("x", "y", "freq")
    xy.reduced <- xy.reduced[xy.reduced$freq != 0, ]
    xy.reduced$x <- as.numeric(as.character(xy.reduced$x))
    xy.reduced$y <- as.numeric(as.character(xy.reduced$y))
    xy.reduced$freq <- as.numeric(as.character(xy.reduced$freq))
    n <- sum(xy.reduced$freq)
    n.reduced <- as.integer(length(xy.reduced$freq))
    if (max(xvec) == 0 & max(yvec) == 0) {
        return(c(rep(1e-10, 5), 1, 0, 0, 0, 0, 1, 0, if (se) {
            rep(NA, 11)
        }))
    }
    info <- if (se) {
        matrix(0, ncol = 8, nrow = 8, dimnames = list(abp.names[-9], 
            abp.names[-9]))
    }
    else {
        0
    }
    if (is.null(initial)) {
        xbar <- mean(xvec)
        ybar <- mean(yvec)
        xybar <- mean(c(xbar, ybar))
        s2.x <- var(xvec)
        s2.y <- var(yvec)
        if (is.na(s2.x) | is.na(s2.y)) {
            s2.x <- s2.y <- 1
        }
        cor.xy <- cor(xvec, yvec)
        if (is.na(cor.xy)) {
            cor.xy <- 0
        }
        zero <- sum(xvec == 0 & yvec == 0)/n
        initial <- rep(NA, 9)
        names(initial) <- c("a0", "a1", "a2", "b1", "b2", "p1", 
            "p2", "p3", "p4")
        initial[4] <- s2.x/ifelse(xbar == 0, 1e-04, xbar)
        initial[5] <- s2.y/ifelse(ybar == 0, 1e-04, ybar)
        initial[2:3] <- c(xbar, ybar)/pmax(initial[4:5], c(0.1, 
            0.1))
        initial[1] <- min(initial[2:3]) * abs(cor.xy)
        initial[2:3] <- initial[2:3] - initial[1]
        initial[6:9] <- bin.profile(xvec, yvec)
        initial[6:9] <- initial[6:9]/sum(initial[6:9])
        initial <- pmax(initial, 1e-05)
        if (is.na(sum(initial))) {
            initial[is.na(initial)] <- 1
        }
    }
    else {
        names(initial) <- abp.names
    }
    iter = 0L
    param = initial
    lik = -Inf
    expt = setNames(as.double(rep(0, 12)), expt.names)
    lik.vec = rep(0, maxiter + 1)
    nonconv = 0L
    em(param2 = param, xvec = xy.reduced$x, yvec = xy.reduced$y, 
        freq = xy.reduced$freq, n = n.reduced, expt = expt, info = info, 
        se = as.integer(se), iter = as.integer(iter), maxiter = as.integer(maxiter), 
        tol = as.double(tol), showFlag = as.integer(showFlag), 
        nonconv = nonconv, trajectory = lik.vec)
    if (nonconv == 1) 
        warning("The iteration exited before reaching convergence.")
    rho <- param[1]/sqrt((param[1] + param[2]) * (param[1] + 
        param[3])) * sqrt(param[4] * param[5]/(param[4] + 1)/(param[5] + 
        1))
    logit.rho <- qlogis(rho)
    if (se) {
        qr.info <- try(qr(info))
        if (class(qr.info) == "try-error") {
            warning("The information matrix has NA/NaN/Inf and thus the standard error is not properly estimatd.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else if (qr(info)$rank < 8) {
            warning("The information matrix is (essentially) not full rank, and thus the standard error is not reliable.")
            std.param = setNames(rep(NA, 11), c(abp.names, "rho", 
                "logit.rho"))
            cov.mat <- NA
        }
        else {
            cov.mat <- try(solve(info))
            if (class(cov.mat) == "try-error") {
                std.param = setNames(rep(NA, 11), c(abp.names, 
                  "rho", "logit.rho"))
                cov.mat <- NA
            }
            else {
                var.p4 <- sum(cov.mat[6:8, 6:8])
                d.g <- rho * c(1/param[1] - 1/{
                  2 * (param[1] + param[2])
                } - 1/{
                  2 * (param[1] + param[3])
                }, -1/{
                  2 * (param[1] + param[2])
                }, -1/{
                  2 * (param[1] + param[3])
                }, 1/{
                  2 * param[4] * (param[4] + 1)
                }, 1/{
                  2 * param[5] * (param[5] + 1)
                })
                var.rho <- t(d.g) %*% cov.mat[1:5, 1:5] %*% d.g
                var.logit.rho <- var.rho/rho^2/(1 - rho)^2
                std.param = sqrt(c(diag(cov.mat), p4 = var.p4, 
                  rho = var.rho, logit.rho = var.logit.rho))
            }
        }
    }
    result <- list(rho = matrix(c(rho, logit.rho, if (se) std.param[c("rho", 
        "logit.rho")] else rep(NA, 2)), ncol = 2, dimnames = list(c("rho", 
        "logit.rho"), c("Estimate", "Std.err"))), coefficients = matrix(c(param, 
        if (se) std.param[1:9] else rep(NA, 9)), ncol = 2, dimnames = list(abp.names, 
        c("Estimate", "Std.err"))), lik = expt[1], iter = iter)
    if (se & vcov) {
        result$info = info
        result$vcov = cov.mat
    }
    return(result)
}
Function bzinb.base in namespace bzinb has this body.
Fatal error: compiler constants were modified!

* checking PDF version of manual ... OK
* DONE
Status: 1 ERROR, 1 NOTE
