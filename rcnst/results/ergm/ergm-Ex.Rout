
R Under development (unstable) (2017-08-15 r73096) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ergm"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ergm')
Loading required package: statnet.common

Attaching package: ‘statnet.common’

The following object is masked from ‘package:base’:

    order

Loading required package: network
network: Classes for Relational Data
Version 1.13.0 created on 2015-08-31.
copyright (c) 2005, Carter T. Butts, University of California-Irvine
                    Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Martina Morris, University of Washington
                    Skye Bender-deMoll, University of Washington
 For citation information, type citation("network").
 Type help("network-package") to get started.


ergm: version 3.7.1, created on 2017-03-20
Copyright (c) 2017, Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Carter T. Butts, University of California -- Irvine
                    Steven M. Goodreau, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Martina Morris, University of Washington
                    with contributions from
                    Li Wang
                    Kirk Li, University of Washington
                    Skye Bender-deMoll, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("ergm").

NOTE: Versions before 3.6.1 had a bug in the implementation of the bd()
constriant which distorted the sampled distribution somewhat. In
addition, Sampson's Monks datasets had mislabeled verteces. See the
NEWS and the documentation for more details.

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("anova.ergm")
> ### * anova.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: anova.ergm
> ### Title: ANOVA for ERGM Fits
> ### Aliases: anova.ergm anova.ergmlist
> ### Keywords: regression models
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("as.edgelist")
> ### * as.edgelist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.edgelist
> ### Title: Convert a network object into a numeric edgelist matrix
> ### Aliases: as.edgelist.compressed
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("as.network.numeric")
> ### * as.network.numeric
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.network.numeric
> ### Title: Create a Simple Random network of a Given Size
> ### Aliases: as.network.numeric
> ### Keywords: classes graphs
> 
> ### ** Examples
> 
> #Draw a random directed network with 25 nodes
> g<-network(25)
> #Draw a random undirected network with density 0.1
> g<-network(25, directed=FALSE, density=0.1)
> #Draw a random bipartite network with 10 events and 5 actors and density 0.1
> g<-network(5, bipartite=10, density=0.1)
> 
> 
> 
> cleanEx()
> nameEx("coef.ergm")
> ### * coef.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coef.ergm
> ### Title: Extract Model Coefficients
> ### Aliases: coef.ergm coefficients.ergm
> ### Keywords: regression models
> 
> ### ** Examples
> 
> data(molecule)
> molecule %v% "atomic type" <- c(1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,3,3)
> fit <- ergm(molecule ~ edges + nodefactor("atomic type"))
Warning: In ‘ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘control.san’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘control.logLik.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘control.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘logLikNull.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Evaluating log-likelihood at the estimate. Warning: In ‘logLik.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.

> coef(fit)
                   edges nodefactor.atomic type.2 nodefactor.atomic type.3 
              -1.4463219               -0.0687476               -0.4019830 
> 
> 
> 
> cleanEx()
> nameEx("degreedist")
> ### * degreedist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: degreedist
> ### Title: Computes and Returns the Degree Distribution Information for a
> ###   Given Network
> ### Aliases: degreedist
> 
> ### ** Examples
> 
> data(faux.mesa.high)
> degreedist(faux.mesa.high)
 degree0  degree1  degree2  degree3  degree4  degree5  degree6  degree7 
      57       51       30       28       18       10        2        4 
 degree8  degree9 degree10 degree13 
       1        2        1        1 
> 
> 
> 
> cleanEx()
> nameEx("enformulate.curved")
> ### * enformulate.curved
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: enformulate.curved
> ### Title: Convert a curved ERGM into a form suitable as initial values for
> ###   the same ergm.
> ### Aliases: enformulate.curved.formula enformulate.curved.ergm
> ###   enformulate.curved
> ### Keywords: model
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("ergm-parallel")
> ### * ergm-parallel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm-parallel
> ### Title: Parallel Processing in the 'ergm' Package
> ### Aliases: ergm-parallel parallel ergm.parallel parallel.ergm
> ###   parallel-ergm ergm.stopCluster ergm.stopCluster.MPIcluster
> ###   ergm.stopCluster.default ergm.getCluster ergm.cluster.started
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("ergm-terms")
> ### * ergm-terms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm-terms
> ### Title: Terms used in Exponential Family Random Graph Models
> ### Aliases: ergm-terms ergm.terms terms-ergm terms.ergm InitErgmTerm
> ###   absdiff absdiffcat altkstar asymmetric atleast atmost b1concurrent
> ###   b1cov b1degrange b1degree b1factor b1mindegree b1nodematch b1star
> ###   b1starmix b1twostar b2concurrent b2cov b2degrange b2degree b2factor
> ###   b2mindegree b2nodematch b2star b2starmix b2twostar balance
> ###   coincidence concurrent concurrentties ctriad ctriple cycle
> ###   cyclicalties cyclicalweights ddsp degcor degcrossprod degrange degree
> ###   degreepopularity diff density desp dgwdsp dgwesp dgwnsp dnsp dsp
> ###   dyadcov edgecov edges esp equalto greaterthan gwb1degree gwb2degree
> ###   gwdegree gwdsp gwesp gwidegree gwnsp gwodegree hamming hammingmix
> ###   idegrange idegree idegreepopularity ininterval intransitive isolates
> ###   istar kstar localtriangle m2star match meandeg mutual nearsimmelian
> ###   nodecov nodecovar nodefactor nodeicov nodeicovar nodeifactor
> ###   nodeisqrtcovar nodemain nodematch nodemix nodeocov nodeocovar
> ###   nodeofactor nodeosqrtcovar nodesqrtcovar nonzero nsp odegrange
> ###   odegree odegreepopularity opentriad ostar receiver sender simmelian
> ###   simmelianties smalldiff smallerthan sociality sum threepath
> ###   threetrail transitive transitiveties transitiveweights triadcensus
> ###   triangle triangles tripercent ttriad ttriple twopath
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle)
> ##D 
> ##D ergm(molecule ~ edges + kstar(2:3) + triangle
> ##D                       + nodematch("atomic type",diff=TRUE)
> ##D                       + triangle + absdiff("atomic type"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ergm")
> ### * ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm
> ### Title: Exponential-Family Random Graph Models
> ### Aliases: ergm ergm.object is.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("ergm.allstats")
> ### * ergm.allstats
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm.allstats
> ### Title: Calculate all possible vectors of statistics on a network for an
> ###   ERGM
> ### Aliases: ergm.allstats
> ### Keywords: models
> 
> ### ** Examples
> 
> # Count by brute force all the edge statistics possible for a 7-node 
> # undirected network
> mynw <- network(matrix(0,7,7),dir=FALSE)
> system.time(a <- ergm.allstats(mynw~edges))
   user  system elapsed 
  0.460   0.004   0.542 
> 
> # Summarize results
> rbind(t(a$statmat),a$weights)
     [,1]  [,2] [,3] [,4] [,5]   [,6] [,7]   [,8]   [,9]  [,10] [,11]  [,12]
[1,]    0    15   18    3   20      9    1      8     12      7    16     10
[2,]    1 54264 1330 1330   21 293930   21 203490 293930 116280 20349 352716
      [,13] [,14]  [,15] [,16] [,17] [,18] [,19]  [,20] [,21] [,22]
[1,]     14    19     13     2    17     6     4     11    21     5
[2,] 116280   210 203490   210  5985 54264  5985 352716     1 20349
> 
> # Each value of a$weights is equal to 21-choose-k, 
> # where k is the corresponding statistic (and 21 is 
> # the number of dyads in an 7-node undirected network).  
> # Here's a check of that fact:
> as.vector(a$weights - choose(21, t(a$statmat)))
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
> 
> # Simple ergm.exact outpuf for this network.  
> # We know that the loglikelihood for my empty 7-node network
> # should simply be -21*log(1+exp(eta)), so we may check that
> # the following two values agree:
> -21*log(1+exp(.1234)) 
[1] -15.89174
> ergm.exact(.1234, mynw~edges, statmat=a$statmat, weights=a$weights)
          [,1]
[1,] -15.89174
> 
> 
> 
> cleanEx()
> nameEx("ergm.exact")
> ### * ergm.exact
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm.exact
> ### Title: Calculate the exact loglikelihood for an ERGM
> ### Aliases: ergm.exact
> ### Keywords: models
> 
> ### ** Examples
> 
> # Count by brute force all the edge statistics possible for a 7-node 
> # undirected network
> mynw <- network(matrix(0,7,7),dir=FALSE)
> system.time(a <- ergm.allstats(mynw~edges))
   user  system elapsed 
  0.464   0.000   0.467 
> 
> # Summarize results
> rbind(t(a$statmat),a$weights)
     [,1]  [,2] [,3] [,4] [,5]   [,6] [,7]   [,8]   [,9]  [,10] [,11]  [,12]
[1,]    0    15   18    3   20      9    1      8     12      7    16     10
[2,]    1 54264 1330 1330   21 293930   21 203490 293930 116280 20349 352716
      [,13] [,14]  [,15] [,16] [,17] [,18] [,19]  [,20] [,21] [,22]
[1,]     14    19     13     2    17     6     4     11    21     5
[2,] 116280   210 203490   210  5985 54264  5985 352716     1 20349
> 
> # Each value of a$weights is equal to 21-choose-k, 
> # where k is the corresponding statistic (and 21 is 
> # the number of dyads in an 7-node undirected network).  
> # Here's a check of that fact:
> as.vector(a$weights - choose(21, t(a$statmat)))
 [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
> 
> # Simple ergm.exact outpuf for this network.  
> # We know that the loglikelihood for my empty 7-node network
> # should simply be -21*log(1+exp(eta)), so we may check that
> # the following two values agree:
> -21*log(1+exp(.1234)) 
[1] -15.89174
> ergm.exact(.1234, mynw~edges, statmat=a$statmat, weights=a$weights)
          [,1]
[1,] -15.89174
> 
> 
> 
> cleanEx()
> nameEx("ergm.geodistdist")
> ### * ergm.geodistdist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergm.geodistdist
> ### Title: calculate geodesic distance distribution for a network or
> ###   edgelist
> ### Aliases: ergm.geodistdist ergm.geodesicmatrix
> ###   ergm.geodesicmatrix.edgelist ergm.geodistn ergm.nodegeodesics
> ###   ergm.pairgeodesic
> 
> ### ** Examples
> 
> data(faux.mesa.high)
> ergm.geodistdist(faux.mesa.high)
    1     2     3     4     5     6     7     8     9    10    11    12    13 
  203   411   561   591   710   875   860   824   704   563   402   246   104 
   14    15    16    17    18    19    20    21    22    23    24    25    26 
   77    33     4     0     0     0     0     0     0     0     0     0     0 
   27    28    29    30    31    32    33    34    35    36    37    38    39 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
   40    41    42    43    44    45    46    47    48    49    50    51    52 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
   53    54    55    56    57    58    59    60    61    62    63    64    65 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
   66    67    68    69    70    71    72    73    74    75    76    77    78 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
   79    80    81    82    83    84    85    86    87    88    89    90    91 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
   92    93    94    95    96    97    98    99   100   101   102   103   104 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  105   106   107   108   109   110   111   112   113   114   115   116   117 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  118   119   120   121   122   123   124   125   126   127   128   129   130 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  131   132   133   134   135   136   137   138   139   140   141   142   143 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  144   145   146   147   148   149   150   151   152   153   154   155   156 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  157   158   159   160   161   162   163   164   165   166   167   168   169 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  170   171   172   173   174   175   176   177   178   179   180   181   182 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  183   184   185   186   187   188   189   190   191   192   193   194   195 
    0     0     0     0     0     0     0     0     0     0     0     0     0 
  196   197   198   199   200   201   202   203   204   Inf 
    0     0     0     0     0     0     0     0     0 13742 
> 
> 
> 
> cleanEx()
> nameEx("ergmMPLE")
> ### * ergmMPLE
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ergmMPLE
> ### Title: ERGM Predictors and response for logistic regression calculation
> ###   of MPLE
> ### Aliases: ergmMPLE
> ### Keywords: regression models
> 
> ### ** Examples
> 
> data(faux.mesa.high)
> formula <- faux.mesa.high ~ edges + nodematch("Sex") + nodefactor("Grade")
> mplesetup <- ergmMPLE(formula)
Warning: In ‘ergmMPLE’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
> 
> # Obtain MPLE coefficients "by hand":
> glm(mplesetup$response ~ . - 1, data = data.frame(mplesetup$predictor), 
+     weights = mplesetup$weights, family="binomial")$coefficients
              edges       nodematch.Sex  nodefactor.Grade.8  nodefactor.Grade.9 
        -4.54076644          0.63629788         -0.28190969         -0.47521808 
nodefactor.Grade.10 nodefactor.Grade.11 nodefactor.Grade.12 
        -0.54948991         -0.19484684         -0.05701667 
> 
> # Check that the coefficients agree with the output of the ergm function:
> ergmMPLE(formula, output="fit")$coef
Evaluating log-likelihood at the estimate. 
              edges       nodematch.Sex  nodefactor.Grade.8  nodefactor.Grade.9 
        -4.54076644          0.63629788         -0.28190969         -0.47521808 
nodefactor.Grade.10 nodefactor.Grade.11 nodefactor.Grade.12 
        -0.54948991         -0.19484684         -0.05701667 
> 
> # We can also format the predictor matrix into an array:
> mplearray <- ergmMPLE(formula, output="array")
> 
> # The resulting matrices are big, so only print the first 5 actors:
> mplearray$response[1:5,1:5]
  1 2 3 4 5
1 0 0 0 0 0
2 0 0 0 0 0
3 0 0 0 0 0
4 0 0 0 0 0
5 0 0 0 0 0
> mplearray$predictor[1:5,1:5,]
, , term = edges

    head
tail  1  2  3  4  5
   1 NA  1  1  1  1
   2 NA NA  1  1  1
   3 NA NA NA  1  1
   4 NA NA NA NA  1
   5 NA NA NA NA NA

, , term = nodematch.Sex

    head
tail  1  2  3  4  5
   1 NA  1  0  0  1
   2 NA NA  0  0  1
   3 NA NA NA  1  0
   4 NA NA NA NA  0
   5 NA NA NA NA NA

, , term = nodefactor.Grade.8

    head
tail  1  2  3  4  5
   1 NA  0  0  1  0
   2 NA NA  0  1  0
   3 NA NA NA  1  0
   4 NA NA NA NA  1
   5 NA NA NA NA NA

, , term = nodefactor.Grade.9

    head
tail  1  2  3  4  5
   1 NA  0  0  0  0
   2 NA NA  0  0  0
   3 NA NA NA  0  0
   4 NA NA NA NA  0
   5 NA NA NA NA NA

, , term = nodefactor.Grade.10

    head
tail  1  2  3  4  5
   1 NA  0  0  0  1
   2 NA NA  0  0  1
   3 NA NA NA  0  1
   4 NA NA NA NA  1
   5 NA NA NA NA NA

, , term = nodefactor.Grade.11

    head
tail  1  2  3  4  5
   1 NA  0  1  0  0
   2 NA NA  1  0  0
   3 NA NA NA  1  1
   4 NA NA NA NA  0
   5 NA NA NA NA NA

, , term = nodefactor.Grade.12

    head
tail  1  2  3  4  5
   1 NA  0  0  0  0
   2 NA NA  0  0  0
   3 NA NA NA  0  0
   4 NA NA NA NA  0
   5 NA NA NA NA NA

> mplearray$weights[1:5,1:5]
     [,1] [,2] [,3] [,4] [,5]
[1,]    0    1    1    1    1
[2,]    0    0    1    1    1
[3,]    0    0    0    1    1
[4,]    0    0    0    0    1
[5,]    0    0    0    0    0
> 
> formula2 <- faux.mesa.high ~ gwesp(0.5,fix=FALSE)
> 
> # The term is treated as fixed: only the gwesp term is returned:
> colnames(ergmMPLE(formula2, as.initialfit=TRUE)$predictor)
[1] "gwesp"
> 
> # The term is treated as curved: individual esp# terms are returned:
> colnames(ergmMPLE(formula2, as.initialfit=FALSE)$predictor)
 [1] "esp#1"  "esp#2"  "esp#3"  "esp#4"  "esp#5"  "esp#6"  "esp#7"  "esp#8" 
 [9] "esp#9"  "esp#10" "esp#11" "esp#12" "esp#13" "esp#14" "esp#15" "esp#16"
[17] "esp#17" "esp#18" "esp#19" "esp#20" "esp#21" "esp#22" "esp#23" "esp#24"
[25] "esp#25" "esp#26" "esp#27" "esp#28" "esp#29" "esp#30"
> 
> 
> 
> cleanEx()
> nameEx("fix.curved")
> ### * fix.curved
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix.curved
> ### Title: Convert a curved ERGM into a corresponding "fixed" ERGM.
> ### Aliases: fix.curved.formula fix.curved.ergm fix.curved
> ### Keywords: model
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("g4")
> ### * g4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: g4
> ### Title: Goodreau's four node network as a "network" object
> ### Aliases: g4
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(g4)
> summary(ergm(g4 ~ odegree(3), estimate="MPLE"))
Evaluating log-likelihood at the estimate. 

==========================
Summary of model fit
==========================

Formula:   g4 ~ odegree(3)

Iterations:  NA 

Maximum Pseudolikelihood Results:
         Estimate Std. Error MCMC % p-value
odegree3    19.16    5066.66      0   0.997

Warning:  The standard errors are based on naive pseudolikelihood and are suspect.

     Null Pseudo-deviance: 16.64  on 12  degrees of freedom
 Residual Pseudo-deviance: 12.48  on 11  degrees of freedom
 
AIC: 14.48    BIC: 14.96    (Smaller is better.) 
> summary(ergm(g4 ~ odegree(3), control=control.ergm(init=0)))
Starting maximum likelihood estimation via MCMLE:
Iteration 1 of at most 20: 
The log-likelihood improved by 0.2553 
Step length converged once. Increasing MCMC sample size.
Iteration 2 of at most 20: 
The log-likelihood improved by 0.0243 
Step length converged twice. Stopping.
Evaluating log-likelihood at the estimate. Warning: In ‘ergm.bridge.dindstart.llk’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘ergm.bridge.llr’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Using 20 bridges: 1 Warning: In ‘simulate.formula’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 .

This model was fit using MCMC.  To examine model diagnostics and check for degeneracy, use the mcmc.diagnostics() function.

==========================
Summary of model fit
==========================

Formula:   g4 ~ odegree(3)

Iterations:  2 out of 20 

Monte Carlo MLE Results:
         Estimate Std. Error MCMC % p-value
odegree3   0.8081     1.0867      0   0.473

     Null Deviance: 16.64  on 12  degrees of freedom
 Residual Deviance: 16.15  on 11  degrees of freedom
 
AIC: 18.15    BIC: 18.63    (Smaller is better.) 
> 
> 
> 
> cleanEx()
> nameEx("get.node.attr")
> ### * get.node.attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get.node.attr
> ### Title: Retrieve and check assumptions about vertex attributes (nodal
> ###   covariates) in a network
> ### Aliases: get.node.attr
> 
> ### ** Examples
> 
> data(faux.mesa.high)
> get.node.attr(faux.mesa.high,'Grade')
  [1]  7  7 11  8 10 10  8 11  9  9  9 11  9 11  8 10 10  7 10  7 12  8  8  9  7
 [26]  9  9  9  8 11  7  9 12 10 11  8  8  7  7 10  8  9  7 12  9 10 10  8  8  8
 [51]  8  7 11  9  8  7  7 12 11  7 11 10  7  8 11  8  9 10 10  7  7  7  7 12 10
 [76]  8  7  7  9  7 11  8 11  7  8  8  7  7 11  7 10  7  9  8  7  7  8  9  9  7
[101]  9 12  8 11  8  8 10  9  9  7  9  7  9  7  9 11  7  8  7 11  8  9  8 11  7
[126] 12  7  8  7  7 11  7  7  7  9 11  7  7  8 12  8  9  9 11  8  9  7 10  9  7
[151]  7  7  9 10  7  7  8  7  9 11  7  8 10  9  9 11  8 11  9  9  8  8  9  7  7
[176] 12 12  9  7  7  9 12  7  7  7 10 10  8  8  7 10  9  8 10  7  7  9  7  9 10
[201] 12 11 10 10  9
> 
> 
> 
> cleanEx()
> nameEx("gof.ergm")
> ### * gof.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: gof
> ### Title: Conduct Goodness-of-Fit Diagnostics on a Exponential Family
> ###   Random Graph Model
> ### Aliases: gof.ergm gof.default gof.formula gof.ergm gof
> ### Keywords: models
> 
> ### ** Examples
> 
> 
> 
> 
> cleanEx()
> nameEx("logLik.ergm")
> ### * logLik.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: logLik.ergm
> ### Title: A 'logLik' method for 'ergm'.
> ### Aliases: logLik.ergm logLikNull logLikNull.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
> # See help(ergm) for a description of this model. The likelihood will
> # not be evaluated.
> data(florentine)
> ## Not run: 
> ##D # The default maximum number of iterations is currently 20. We'll only
> ##D # use 2 here for speed's sake.
> ##D gest <- ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle, eval.loglik=FALSE)
> ##D 
> ##D gest <- ergm(flomarriage ~ kstar(1:2) + absdiff("wealth") + triangle, eval.loglik=FALSE,
> ##D              control=control.ergm(MCMLE.maxit=2))
> ##D # Log-likelihood is not evaluated, so no deviance, AIC, or BIC:
> ##D summary(gest)
> ##D # Evaluate the log-likelihood and attach it to the object.
> ##D 
> ##D # The default number of bridges is currently 20. We'll only use 3 here
> ##D # for speed's sake.
> ##D gest.logLik <- logLik(gest, add=TRUE)
> ##D 
> ##D gest.logLik <- logLik(gest, add=TRUE, control=control.logLik.ergm(nsteps=3))
> ##D # Deviances, AIC, and BIC are now shown:
> ##D summary(gest.logLik)
> ##D # Null model likelihood can also be evaluated, but not for all constraints:
> ##D logLikNull(gest) # == network.dyadcount(flomarriage)*log(1/2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mcmc.diagnostics.ergm")
> ### * mcmc.diagnostics.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mcmc.diagnostics
> ### Title: Conduct MCMC diagnostics on an ergm fit
> ### Aliases: mcmc.diagnostics.ergm mcmc.diagnostics
> ###   mcmc.diagnostics.default plot.mcmc.list.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #
> ##D data(florentine)
> ##D #
> ##D # test the mcmc.diagnostics function
> ##D #
> ##D gest <- ergm(flomarriage ~ edges + kstar(2))
> ##D summary(gest)
> ##D 
> ##D #
> ##D # Plot the probabilities first
> ##D #
> ##D mcmc.diagnostics(gest)
> ##D #
> ##D # Use coda directly
> ##D #
> ##D library(coda)
> ##D #
> ##D plot(gest$sample, ask=FALSE)
> ##D #
> ##D # A full range of diagnostics is available 
> ##D # using codamenu()
> ##D #
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("network.update")
> ### * network.update
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: network.update
> ### Title: Replaces the sociomatrix in a network object
> ### Aliases: network.update
> ### Keywords: models
> 
> ### ** Examples
> 
> #
> data(florentine)
> #
> # test the network.update function
> #
> # Create a Bernoulli network
> rand.net <- network(network.size(flomarriage))
> # store the sociomatrix 
> rand.mat <- rand.net[,]
> # Update the network
> network.update(flomarriage, rand.mat, matrix.type="adjacency")
 Network attributes:
  vertices = 16 
  directed = FALSE 
  hyper = FALSE 
  loops = FALSE 
  multiple = FALSE 
  bipartite = FALSE 
  total edges= 4 
    missing edges= 0 
    non-missing edges= 4 

 Vertex attribute names: 
    priorates totalties vertex.names wealth 

No edge attributes
> # Try this with an edgelist
> rand.mat <- as.matrix.network.edgelist(flomarriage)[1:5,]
> network.update(flomarriage, rand.mat, matrix.type="edgelist")
 Network attributes:
  vertices = 16 
  directed = FALSE 
  hyper = FALSE 
  loops = FALSE 
  multiple = FALSE 
  bipartite = FALSE 
  total edges= 5 
    missing edges= 0 
    non-missing edges= 5 

 Vertex attribute names: 
    priorates totalties vertex.names wealth 

No edge attributes
> 
> 
> 
> cleanEx()
> nameEx("plot.ergm")
> ### * plot.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.ergm
> ### Title: Plotting Method for class ergm
> ### Aliases: plot.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #
> ##D # The example assumes you have the 'latentnet' package installed.
> ##D #
> ##D # Using Sampson's Monk data, lets fit a 
> ##D # simple latent position model
> ##D #
> ##D data(sampson)
> ##D #
> ##D # Get the group labels
> ##D #
> ##D samp.labs <- substr(get.vertex.attribute(samplike,"group"),1,1)
> ##D #
> ##D samp.fit <- ergm(samplike ~ latent(k=2), burnin=10000,
> ##D                  MCMCsamplesize=2000, interval=30)
> ##D #
> ##D # See if we have convergence in the MCMC
> ##D mcmc.diagnostics(samp.fit)
> ##D #
> ##D # Plot the fit
> ##D #
> ##D plot(samp.fit,label=samp.labs, vertex.col="group")
> ##D #
> ##D # Using Sampson's Monk data, lets fit a latent clustering model
> ##D #
> ##D samp.fit <- ergm(samplike ~ latentcluster(k=2, ngroups=3), burnin=10000,
> ##D                  MCMCsamplesize=2000, interval=30)
> ##D #
> ##D # See if we have convergence in the MCMC
> ##D mcmc.diagnostics(samp.fit)
> ##D #
> ##D # Lets look at the goodness of fit:
> ##D #
> ##D plot(samp.fit,label=samp.labs, vertex.col="group")
> ##D plot(samp.fit,pie=TRUE,label=samp.labs)
> ##D plot(samp.fit,density=c(2,2))
> ##D plot(samp.fit,contours=5,contour.color="red")
> ##D plot(samp.fit,density=TRUE,drawarrows=TRUE)
> ##D add.contours(samp.fit,nlevels=8,lwd=2)
> ##D points(samp.fit$Z.mkl,pch=19,col=samp.fit$class)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot.gofobject")
> ### * plot.gofobject
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.gofobject
> ### Title: Plot Goodness-of-Fit Diagnostics on a Exponential Family Random
> ###   Graph Model
> ### Aliases: plot.gofobject
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #
> ##D data(florentine)
> ##D #
> ##D # test the gof.ergm function
> ##D #
> ##D gest <- ergm(flomarriage ~ edges + kstar(2))
> ##D gest
> ##D summary(gest)
> ##D 
> ##D #
> ##D # Plot the probabilities first
> ##D #
> ##D gofflo <- gof(gest)
> ##D gofflo
> ##D plot(gofflo)
> ##D #
> ##D # And now the odds 
> ##D #
> ##D plot(gofflo, plotlogodds=TRUE)
> ##D #
> ##D # Use the formula version
> ##D #
> ##D gof(flomarriage ~ edges + kstar(2), coef=c(-1.6339, 0.0049))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("plot.network.ergm")
> ### * plot.network.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.network.ergm
> ### Title: Two-Dimensional Visualization of Networks
> ### Aliases: plot.network.ergm
> ### Keywords: hplot graphs
> 
> ### ** Examples
> 
> data(florentine)
> plot(flomarriage)  #Plot the Florentine Marriage data
> plot(network(10))  #Plot a random network
> ## Not run: plot(flomarriage,interactive="points")
> 
> 
> 
> cleanEx()
> nameEx("print.ergm")
> ### * print.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.ergm
> ### Title: Exponential Random Graph Models
> ### Aliases: print.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
>  data(florentine)
> 
>  x <- ergm(flomarriage ~ density)
Evaluating log-likelihood at the estimate. 
>  class(x)
[1] "ergm"
>  x

MLE Coefficients:
density  
 -193.1  
> 
> 
> 
> cleanEx()
> nameEx("search.ergmTerms")
> ### * search.ergmTerms
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: search.ergmTerms
> ### Title: Search the ergm-terms documentation for appropriate terms
> ### Aliases: search.ergmTerms
> 
> ### ** Examples
> 
> # find all of the terms that mention triangles
> search.ergmTerms('triangle')
Found  10  matching ergm terms:
ctriple(attrname=NULL)
 Cyclic triples

ctriad()
 Cyclic triples

cycle(k)
 Cycles

localtriangle(x)
 Triangles within neighborhoods:

opentriad()
 Open triads

threetrail(keep=1:4)
 Three-trails

triangle(attrname=NULL)
 Triangles

tripercent(attrname=NULL)
 Triangle percentage

ttriple(attrname=NULL)
 Transitive triples

ttriad()
 Transitive triples
> 
> # two ways to search for bipartite terms:
> 
> # search using a bipartite net as a template
> myNet<-network.initialize(5,bipartite=3)
> search.ergmTerms(net=myNet)
Found  0  matching ergm terms:
> 
> # or request the bipartite category
> search.ergmTerms(categories='bipartite')
Found  27  matching ergm terms:
b1concurrent(by=NULL)
 Concurrent node count for the first mode in a bipartite (aka two-mode) network

b1cov(attrname, transform, transformname)
 Main effect of a covariate for the first mode in a bipartite (aka two-mode) network

b1cov(attrname, transform, transformname, form="sum")
 Main effect of a covariate for the first mode in a bipartite (aka two-mode) network

b1degrange(from, to=+Inf, by=NULL, homophily=FALSE)
 Degree range for the first mode in a bipartite (a.k.a. two-mode) network

b1degree(d, by=NULL)
 Degree for the first mode in a bipartite (aka two-mode) network

b1factor(attrname, base=1)
 Factor attribute effect for the first mode in a bipartite (aka two-mode) network

b1factor(attrname, base=1, form="sum")
 Factor attribute effect for the first mode in a bipartite (aka two-mode) network

b1mindegree(d)
 Minimum degree for the first mode in a bipartite (aka two-mode) network

b1nodematch(attrname, diff=FALSE, keep=NULL, by=NULL, alpha=1, beta=1, )
 Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network

b1star(k, attrname=NULL)
 k-Stars for the first mode in a bipartite (aka two-mode) network:

b1starmix(k, attrname, base=NULL, diff=TRUE)
 Mixing matrix for k-stars centered on the first mode of a bipartite network

b1twostar(b1attrname, b2attrname, base=NULL)
 Two-star census for central nodes centered on the first mode of a bipartite network

b2concurrent(by=NULL)
 Concurrent node count for the second mode in a bipartite (aka two-mode) network

b2cov(attrname, transform, transformname)
 Main effect of a covariate for the second mode in a bipartite (aka two-mode) network

b2cov(attrname, transform, transformname, form="sum")
 Main effect of a covariate for the second mode in a bipartite (aka two-mode) network

b2degrange(from, to=+Inf, by=NULL, homophily=FALSE)
 Degree range for the second mode in a bipartite (a.k.a. two-mode) network

b2degree(d, by=NULL)
 Degree for the second mode in a bipartite (aka two-mode) network

b2factor(attrname, base=1)
 Factor attribute effect for the second mode in a bipartite (aka two-mode) network 

b2factor(attrname, base=1, form="sum")
 Factor attribute effect for the second mode in a bipartite (aka two-mode) network 

b2mindegree(d)
 Minimum degree for the second mode in a bipartite (aka two-mode) network

b2nodematch(attrname, diff=FALSE, keep=NULL, by=NULL, alpha=1, beta=1, )
 Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network

b2star(k, attrname=NULL)
 k-Stars for the second mode in a bipartite (aka two-mode) network:

b2starmix(k, attrname, base=NULL, diff=TRUE)
 Mixing matrix for k-stars centered on the second mode of a bipartite network

b2twostar(b1attrname, b2attrname, base=NULL)
 Two-star census for central nodes centered on the second mode of a bipartite
 network

coincidence(d=NULL,active=0)
 Coincident node count for the second mode in a bipartite (aka two-mode) network

gwb1degree(decay, fixed=FALSE, cutoff=30)
 Geometrically weighted degree distribution for the first mode in a bipartite (aka two-mode)
 network

gwb2degree(decay, fixed=FALSE, cutoff=30)
 Geometrically weighted degree distribution for the second mode in a bipartite (aka two-mode)
 network
> 
> # search on multiple categories
> search.ergmTerms(categories=c('bipartite','dyad-independent'))
Found  10  matching ergm terms:
b1cov(attrname, transform, transformname)
 Main effect of a covariate for the first mode in a bipartite (aka two-mode) network

b1cov(attrname, transform, transformname, form="sum")
 Main effect of a covariate for the first mode in a bipartite (aka two-mode) network

b1factor(attrname, base=1)
 Factor attribute effect for the first mode in a bipartite (aka two-mode) network

b1factor(attrname, base=1, form="sum")
 Factor attribute effect for the first mode in a bipartite (aka two-mode) network

b1nodematch(attrname, diff=FALSE, keep=NULL, by=NULL, alpha=1, beta=1, )
 Nodal attribute-based homophily effect for the first mode in a bipartite (aka two-mode) network

b2cov(attrname, transform, transformname)
 Main effect of a covariate for the second mode in a bipartite (aka two-mode) network

b2cov(attrname, transform, transformname, form="sum")
 Main effect of a covariate for the second mode in a bipartite (aka two-mode) network

b2factor(attrname, base=1)
 Factor attribute effect for the second mode in a bipartite (aka two-mode) network 

b2factor(attrname, base=1, form="sum")
 Factor attribute effect for the second mode in a bipartite (aka two-mode) network 

b2nodematch(attrname, diff=FALSE, keep=NULL, by=NULL, alpha=1, beta=1, )
 Nodal attribute-based homophily effect for the second mode in a bipartite (aka two-mode) network
> 
> # print out the content for a specific term
> search.ergmTerms(name='b2factor')
Definitions for term(s)  b2factor :
b2factor(attrname, base=1)
     _Factor attribute effect for the second mode in a bipartite (aka two-mode) network :_ The ‘attrname’ argument is a character string giving the name of a categorical attribute in the network's vertex attribute list. This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the ‘attrname’ attribute. Each of these statistics gives the number of times a node with that attribute in the second mode of the network appears in an edge. The second mode of a bipartite network object is sometimes known as the "event" mode. To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including ‘edges’. Thus, the ‘base’ argument tells which value(s) (numbered in order according to the ‘sort’ function) should be omitted. The default value, ‘base=1’, means that the smallest (i.e., first in sorted order) attribute value is omitted. For example, if the “fruit” factor has levels “orange”, “apple”, “banana”, and “pear”, then to add just two terms, one for “apple” and one for “pear”, then set “banana” and “orange” to the base (remember to sort the values first) by using ‘nodefactor("fruit", base=2:3)’. This term can only be used with undirected bipartite networks. 
    Categories: binary, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used 

b2factor(attrname, base=1, form="sum")
     _Factor attribute effect for the second mode in a bipartite (aka two-mode) network :_ The ‘attrname’ argument is a character string giving the name of a categorical attribute in the network's vertex attribute list. This term adds multiple network statistics to the model, one for each of (a subset of) the unique values of the ‘attrname’ attribute. Each of these statistics gives the number of times a node with that attribute in the second mode of the network appears in an edge. The second mode of a bipartite network object is sometimes known as the "event" mode. To include all attribute values is usually not a good idea, because the sum of all such statistics equals the number of edges and hence a linear dependency would arise in any model also including ‘edges’. Thus, the ‘base’ argument tells which value(s) (numbered in order according to the ‘sort’ function) should be omitted. The default value, ‘base=1’, means that the smallest (i.e., first in sorted order) attribute value is omitted. For example, if the “fruit” factor has levels “orange”, “apple”, “banana”, and “pear”, then to add just two terms, one for “apple” and one for “pear”, then set “banana” and “orange” to the base (remember to sort the values first) by using ‘nodefactor("fruit", base=2:3)’. This term can only be used with undirected bipartite networks. 
    Categories: valued, bipartite, undirected, dyad-independent, categorical nodal attribute, frequently-used 

> 
> 
> 
> 
> cleanEx()
> nameEx("simulate.ergm")
> ### * simulate.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simulate.ergm
> ### Title: Draw from the distribution of an Exponential Family Random Graph
> ###   Model
> ### Aliases: simulate.ergm simulate.formula simulate.formula.ergm
> ### Keywords: models
> 
> ### ** Examples
> 
> #
> # Let's draw from a Bernoulli model with 16 nodes
> # and density 0.5 (i.e., coef = c(0,0))
> #
> g.sim <- simulate(network(16) ~ edges + mutual, coef=c(0, 0))
> #
> # What are the statistics like?
> #
> summary(g.sim ~ edges + mutual)
 edges mutual 
   133     35 
> #
> # Now simulate a network with higher mutuality
> #
> g.sim <- simulate(network(16) ~ edges + mutual, coef=c(0,2))
> #
> # How do the statistics look?
> #
> summary(g.sim ~ edges + mutual)
 edges mutual 
   188     81 
> #
> # Let's draw from a Bernoulli model with 16 nodes
> # and tie probability 0.1
> #
> g.use <- network(16,density=0.1,directed=FALSE)
> #
> # Starting from this network let's draw 3 realizations
> # of a edges and 2-star network
> #
> g.sim <- simulate(~edges+kstar(2), nsim=3, coef=c(-1.8,0.03),
+                basis=g.use, control=control.simulate(
+                  MCMC.burnin=1000,
+                  MCMC.interval=100))
> g.sim
Number of Networks: 3 
Model: ~edges + kstar(2) 
Reference: ~Bernoulli 
Constraints: ~. 
Parameters:
[1] -1.80  0.03

> summary(g.sim)
Number of Networks: 3 
Model: ~edges + kstar(2) 
Reference: ~Bernoulli 
Constraints: ~. 
Parameters:
[1] -1.80  0.03

Stored network statistics:
     edges kstar2
[1,]    22     63
[2,]    19     41
[3,]    28     93

> #
> # attach the Florentine Marriage data
> #
> data(florentine)
> #
> # fit an edges and 2-star model using the ergm function
> #
> gest <- ergm(flomarriage ~ edges + kstar(2))
Starting maximum likelihood estimation via MCMLE:
Iteration 1 of at most 20: 
The log-likelihood improved by 0.0004978 
Step length converged once. Increasing MCMC sample size.
Iteration 2 of at most 20: 
The log-likelihood improved by 0.0004722 
Step length converged twice. Stopping.
Evaluating log-likelihood at the estimate. Using 20 bridges: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 .

This model was fit using MCMC.  To examine model diagnostics and check for degeneracy, use the mcmc.diagnostics() function.
> summary(gest)

==========================
Summary of model fit
==========================

Formula:   flomarriage ~ edges + kstar(2)

Iterations:  2 out of 20 

Monte Carlo MLE Results:
       Estimate Std. Error MCMC % p-value  
edges  -1.64142    0.84762      0  0.0552 .
kstar2  0.00806    0.17474      0  0.9633  
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

     Null Deviance: 166.4  on 120  degrees of freedom
 Residual Deviance: 108.1  on 118  degrees of freedom
 
AIC: 112.1    BIC: 117.7    (Smaller is better.) 
> #
> # Draw from the fitted model (satatistics only), and observe the number
> # of triangles as well.
> #
> g.sim <- simulate(gest, nsim=10, 
+             monitor=~triangles, statsonly=TRUE,
+             control=control.simulate.ergm(MCMC.burnin=1000, MCMC.interval=100))
Warning: In ‘simulate.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
Warning: In ‘control.simulate.ergm’: Autodetection of acceptable control parameter generators and of the calling function name has been deprecated and will be removed in a future version. They must be set explicitly.
> g.sim
      edges kstar2 triangle
 [1,]    26     87        6
 [2,]    24     63        5
 [3,]    20     38        1
 [4,]    23     65        4
 [5,]    25     76        5
 [6,]    25     69        4
 [7,]    22     60        1
 [8,]    14     21        1
 [9,]    25     76        4
[10,]    19     39        1
> 
> 
> 
> cleanEx()
> nameEx("standardize.network")
> ### * standardize.network
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: standardize.network
> ### Title: Copy a network object enforcing ergm-appropriate guarantees
> ###   about its internal representation
> ### Aliases: standardize.network
> ### Keywords: internal
> 
> ### ** Examples
> 
> test<-network.initialize(5,directed=FALSE)
> test[2,1]<-1  #ergm wont like this
> test$mel[[1]] # peek at internal representation
$inl
[1] 1

$outl
[1] 2

$atl
$atl$na
[1] FALSE


> 
> test2<-standardize.network(test) # enforce!
> test2$mel[[2]]  # 1 and 2 have traded places
$inl
[1] 2

$outl
[1] 1

$atl
$atl$na
[1] FALSE


> 
> 
> 
> 
> cleanEx()
> nameEx("summary.ergm")
> ### * summary.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.ergm
> ### Title: Summarizing ERGM Model Fits
> ### Aliases: summary.ergm print.summary.ergm
> ### Keywords: regression models
> 
> ### ** Examples
> 
>  data(florentine)
> 
>  x <- ergm(flomarriage ~ density)
Evaluating log-likelihood at the estimate. 
>  summary(x)

==========================
Summary of model fit
==========================

Formula:   flomarriage ~ density

Iterations:  5 out of 20 

Monte Carlo MLE Results:
        Estimate Std. Error MCMC % p-value    
density  -193.13      29.39      0  <1e-04 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

     Null Deviance: 166.4  on 120  degrees of freedom
 Residual Deviance: 108.1  on 119  degrees of freedom
 
AIC: 110.1    BIC: 112.9    (Smaller is better.) 
> 
> 
> 
> cleanEx()
> nameEx("summary.gofobject")
> ### * summary.gofobject
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.gofobject
> ### Title: Summaries the Goodness-of-Fit Diagnostics on a Exponential
> ###   Family Random Graph Model
> ### Aliases: summary.gofobject print.gofobject
> ### Keywords: graphs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #
> ##D data(florentine)
> ##D #
> ##D # test the gof.ergm function
> ##D #
> ##D gest <- ergm(flomarriage ~ edges + kstar(2))
> ##D gest
> ##D summary(gest)
> ##D 
> ##D #
> ##D # Plot the probabilities first
> ##D #
> ##D gofflo <- gof(gest)
> ##D gofflo
> ##D summary(gofflo)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("summary.network.list")
> ### * summary.network.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.network.list
> ### Title: Summarizing network.list objects
> ### Aliases: summary.network.list print.network.list network.list
> ### Keywords: regression models
> 
> ### ** Examples
> 
> # Draw from a Bernoulli model with 16 nodes
> # and tie probability 0.1
> #
> g.use <- network(16, density=0.1, directed=FALSE)
> #
> # Starting from this network let's draw 3 realizations
> # of a model with edges and 2-star terms
> #
> g.sim <- simulate(~edges+kstar(2), nsim=3, coef=c(-1.8, 0.03),
+                basis=g.use, control=control.simulate(
+                  MCMC.burnin=100000,
+                  MCMC.interval=1000))
> print(g.sim)
Number of Networks: 3 
Model: ~edges + kstar(2) 
Reference: ~Bernoulli 
Constraints: ~. 
Parameters:
[1] -1.80  0.03

> summary(g.sim)
Number of Networks: 3 
Model: ~edges + kstar(2) 
Reference: ~Bernoulli 
Constraints: ~. 
Parameters:
[1] -1.80  0.03

Stored network statistics:
     edges kstar2
[1,]    23     70
[2,]    20     46
[3,]    17     32

> 
> 
> 
> cleanEx()
> nameEx("summary.statistics")
> ### * summary.statistics
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summary.statistics
> ### Title: Calculation of network or graph statistics
> ### Aliases: summary.statistics summary.statistics.matrix
> ###   summary.statistics.network summary.statistics.network.list
> ###   summary.statistics.default summary.statistics.formula
> ###   summary.statistics.ergm summary.formula summary
> ### Keywords: models
> 
> ### ** Examples
> 
> #
> # Lets look at the Florentine marriage data
> #
> data(florentine)
> #
> # test the summary.statistics function
> #
> summary(flomarriage ~ edges + kstar(2))
 edges kstar2 
    20     47 
> m <- as.matrix(flomarriage)
> summary(m ~ edges)  # twice as large as it should be
edges 
   40 
> summary(m ~ edges, directed=FALSE) # Now it's correct
edges 
   40 
> 
> 
> 
> cleanEx()
> nameEx("vcov.ergm")
> ### * vcov.ergm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vcov.ergm
> ### Title: Extract Model Covariance Matrix
> ### Aliases: vcov.ergm
> 
> ### ** Examples
> 
> data(florentine)
> fit <- ergm(flomarriage ~ edges + concurrent)
Starting maximum likelihood estimation via MCMLE:
Iteration 1 of at most 20: 
The log-likelihood improved by 0.6647 
Step length converged once. Increasing MCMC sample size.
Iteration 2 of at most 20: 
The log-likelihood improved by 0.02877 
Step length converged twice. Stopping.
Evaluating log-likelihood at the estimate. Using 20 bridges: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 .

This model was fit using MCMC.  To examine model diagnostics and check for degeneracy, use the mcmc.diagnostics() function.
> vcov(fit, sources="model")
                edges concurrent
edges       0.1895914 -0.3039859
concurrent -0.3039859  0.6399547
> vcov(fit, sources="estimation")
                   edges    concurrent
edges       4.629827e-05 -7.423344e-05
concurrent -7.423344e-05  1.562771e-04
> vcov(fit, sources="all") # the default
                edges concurrent
edges       0.1896377 -0.3040601
concurrent -0.3040601  0.6401110
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  35.992 0.292 37.081 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
