
R Under development (unstable) (2018-01-09 r74101) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "SpaDES.core"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('SpaDES.core')
Loading required package: quickPlot
Loading required package: reproducible

Attaching package: ‘SpaDES.core’

The following objects are masked from ‘package:stats’:

    end, start

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("POM")
> ### * POM
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: POM
> ### Title: Use Pattern Oriented Modeling to fit unknown parameters
> ### Aliases: POM POM,simList,character-method
> 
> ### ** Examples
> 
> if (interactive()) {
+   set.seed(89462)
+   library(parallel)
+   library(raster)
+   mySim <- simInit(
+     times = list(start = 0.0, end = 2.0, timeunit = "year"),
+     params = list(
+       .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
+       fireSpread = list(nFires = 5),
+       randomLandscapes = list(nx = 300, ny = 300)
+     ),
+     modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
+     paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
+   )
+ 
+   # Since this is a made up example, we don't have real data
+   #  to run POM against. Instead, we will run the model once,
+   #  take the values at the end of the simulation as if they
+   #  are real data, then rerun the POM function next,
+   #  comparing these "data" with the simulated values
+   #  using Mean Absolute Deviation
+   outData <- spades(Copy(mySim), .plotInitialTime = NA)
+ 
+   # Extract the "true" data, in this case, the "proportion of cells burned"
+   # Function defined that will use landscape$Fires map from simList,
+   #  i.e., sim$landscape$Fires
+   #  the return value being compared via MAD with propCellBurnedData
+   propCellBurnedFn <- function(landscape) {
+     sum(getValues(landscape$Fires) > 0) / ncell(landscape$Fires)
+   }
+   # visualize the burned maps of true "data"
+   propCellBurnedData <- propCellBurnedFn(outData$landscape)
+   clearPlot()
+   if (interactive()) {
+     Fires <- outData$landscape$Fires # Plot doesn't do well with many nested layers
+     Plot(Fires)
+   }
+ 
+   # Example 1 - 1 parameter
+   # In words, this says, "find the best value of spreadprob such that
+   #  the proportion of the area burned in the simulation
+   #  is as close as possible to the proportion area burned in
+   #  the "data", using \code{DEoptim()}.
+ 
+   # Can use cluster if computer is multi-threaded (but not yet via cl arg, which is not
+   #                                                implemented yet in DEoptim)
+   # This example uses parallelType = 1 in DEoptim. For this, you must manually
+   #  pass all packages and variables as character strings.
+   # cl <- makeCluster(detectCores() - 1) # not implemented yet in DEoptim
+   out1 <- POM(mySim, "spreadprob",
+               list(propCellBurnedData = propCellBurnedFn), # data = pattern pair
+               #optimControl = list(parallelType = 1),
+               logObjFnVals = TRUE)
+ 
+   ## Once cl arg is available from DEoptim, this will work:
+   # out1 <- POM(mySim, "spreadprob", cl = cl,
+   #            list(propCellBurnedData = propCellBurnedFn)) # data = pattern pair
+ 
+   # Example 2 - 2 parameters
+   # Function defined that will use caribou from sim$caribou, with
+   #  the return value being compared via MAD with NPattern
+   #  module, parameter N, is from 10 to 1000)
+   caribouFn <- function(caribou) length(caribou)
+ 
+   # Extract "data" from simList object (normally, this would be actual data)
+   NPattern <- caribouFn(outData$caribou)
+ 
+   aTime <- Sys.time()
+   parsToVary <- c("spreadprob", "N")
+   out2 <- POM(mySim, parsToVary,
+               list(propCellBurnedData = propCellBurnedFn,
+                    NPattern = caribouFn), logObjFnVals = TRUE)
+                    #optimControl = list(parallelType = 1))
+                    #cl = cl) # not yet implemented, waiting for DEoptim
+   bTime <- Sys.time()
+   # check that population overlaps known values (0.225 and 100)
+   apply(out2$member$pop, 2, quantile, c(0.025, 0.975))
+   hists <- apply(out2$member$pop, 2, hist, plot = FALSE)
+   clearPlot()
+   for (i in seq_along(hists)) Plot(hists[[i]], addTo = parsToVary[i],
+                                    title = parsToVary[i], axes = TRUE)
+ 
+   print(paste("DEoptim", format(bTime - aTime)))
+   #stopCluster(cl) # not yet implemented, waiting for DEoptim
+ 
+   # Example 3 - using objFn instead of objects
+ 
+   # list all the parameters in the simList, from these, we select to vary
+   params(mySim)
+ 
+   # Objective Function Example:
+   #   objective function must have several elements
+   #   - first argument must be parameter vector, passed to and used by DEoptim
+   #   - likely needs to take sim object, likely needs a copy
+   #      because of pass-by-reference semantics of sim objects
+   #   - pass data that will be used internally for objective function
+   objFnEx <- function(pars, # param values
+                       sim, # simList object
+                       NPattern, propCellBurnedData, caribouFn, propCellBurnedFn) {
+     ### data
+ 
+     # make a copy of simList because it will possibly be altered by spades call
+     sim1 <- Copy(sim)
+ 
+     # take the parameters and assign them to simList
+     params(sim1)$fireSpread$spreadprob <- pars[1]
+     params(sim1)$caribouMovement$N <- pars[2]
+ 
+     # run spades, without plotting
+     out <- spades(sim1, .plotInitialTime = NA)
+ 
+     # calculate outputs
+     propCellBurnedOut <- propCellBurnedFn(out$landscape)
+     NPattern_Out <- caribouFn(out$caribou)
+ 
+     minimizeFn <- abs(NPattern_Out - NPattern) +
+                   abs(propCellBurnedOut - propCellBurnedData)
+ 
+     # have more info reported to console, if desired
+     # cat(minimizeFn)
+     # cat(" ")
+     # cat(pars)
+     # cat("\n")
+ 
+     return(minimizeFn)
+   }
+ 
+   # Run DEoptim with custom objFn, identifying 2 parameters to allow
+   #  to vary, and pass all necessary objects required for the
+   #  objFn
+ 
+   # choose 2 of them to vary. Need to identify them in params & inside objFn
+   # Change optimization parameters to alter how convergence is achieved
+   out5 <- POM(mySim, params = c("spreadprob", "N"),
+               objFn = objFnEx,
+               NPattern = NPattern,
+               propCellBurnedData = propCellBurnedData,
+               caribouFn = caribouFn,
+               propCellBurnedFn = propCellBurnedFn,
+               #cl = cl, # uncomment for cluster # not yet implemented, waiting for DEoptim
+               # see ?DEoptim.control for explanation of these options
+               optimControl = list(
+                 NP = 100, # run 100 populations, allowing quantiles to be calculated
+                 initialpop = matrix(c(runif(100, 0.2, 0.24), runif(100, 80, 120)), ncol = 2),
+                 parallelType = 1
+               )
+             )
+ 
+   # Can also use an optimizer directly -- miss automatic parameter bounds,
+   #  and automatic objective function using option 2
+   library(DEoptim)
+   out7 <- DEoptim(fn = objFnEx,
+                  sim = mySim,
+                  NPattern = NPattern,
+                  propCellBurnedData = propCellBurnedData,
+                  caribouFn = caribouFn,
+                  propCellBurnedFn = propCellBurnedFn,
+                  # cl = cl, # uncomment for cluster
+                  # see ?DEoptim.control for explanation of these options
+                  control = DEoptim.control(
+                    steptol = 3,
+                    parallelType = 1, # parallelType = 3,
+                    packages = list("raster", "SpaDES.core", "RColorBrewer"),
+                    parVar = list("objFnEx"),
+                    initialpop = matrix(c(runif(40, 0.2, 0.24),
+                                          runif(40, 80, 120)), ncol = 2)),
+                  lower = c(0.2, 80), upper = c(0.24, 120))
+ }
> 
> 
> 
> cleanEx()
> nameEx("append_attr")
> ### * append_attr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: append_attr
> ### Title: Add a module to a 'moduleList'
> ### Aliases: append_attr append_attr,list,list-method
> 
> ### ** Examples
> 
> library(igraph) # igraph exports magrittr's pipe operator

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

> tmp1 <- list("apple", "banana") %>% lapply(., `attributes<-`, list(type = "fruit"))
> tmp2 <- list("carrot") %>% lapply(., `attributes<-`, list(type = "vegetable"))
> append_attr(tmp1, tmp2)
[[1]]
[1] "apple"
attr(,"type")
[1] "fruit"

[[2]]
[1] "banana"
attr(,"type")
[1] "fruit"

[[3]]
[1] "carrot"
attr(,"type")
[1] "vegetable"

> rm(tmp1, tmp2)
> 
> 
> 
> cleanEx()

detaching ‘package:igraph’

> nameEx("checksums")
> ### * checksums
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: checksums
> ### Title: Calculate checksums for a module's data files
> ### Aliases: checksums checksums,character,character,logical-method
> ###   checksums,character,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D moduleName <- "my_module"
> ##D modulePath <- file.path("path", "to", "modules")
> ##D 
> ##D ## verify checksums of all data files
> ##D checksums(moduleName, modulePath)
> ##D 
> ##D ## write new CHECKSUMS.txt file
> ##D 
> ##D # 1. verify that all data files are present (and no extra files are present)
> ##D list.files(file.path(modulePath, moduleName, "data"))
> ##D 
> ##D # 2. calculate file checksums and write to file (this will overwrite CHECKSUMS.txt)
> ##D checksums(moduleName, modulePath, write = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("classFilter")
> ### * classFilter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: classFilter
> ### Title: Filter objects by class
> ### Aliases: classFilter
> ###   classFilter,character,character,character,environment-method
> ###   classFilter,character,character,character,missing-method
> ###   classFilter,character,character,missing,environment-method
> ###   classFilter,character,character,missing,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## from global environment
> ##D   a <- list(1:10)     # class `list`
> ##D   b <- letters        # class `character`
> ##D   d <- stats::runif(10)      # class `numeric`
> ##D   f <- sample(1L:10L) # class `numeric`, `integer`
> ##D   g <- lm( jitter(d) ~ d ) # class `lm`
> ##D   h <- glm( jitter(d) ~ d ) # class `lm`, `glm`
> ##D   classFilter(ls(), include=c("character", "list"))
> ##D   classFilter(ls(), include = "numeric")
> ##D   classFilter(ls(), include = "numeric", exclude = "integer")
> ##D   classFilter(ls(), include = "lm")
> ##D   classFilter(ls(), include = "lm", exclude = "glm")
> ##D   rm(a, b, d, f, g, h)
> ## End(Not run)
> 
> ## from local (e.g., function) environment
> local({
+   e <- environment()
+   a <- list(1:10)     # class `list`
+   b <- letters        # class `character`
+   d <- stats::runif(10)      # class `numeric`
+   f <- sample(1L:10L) # class `numeric`, `integer`
+   g <- lm( jitter(d) ~ d ) # class `lm`
+   h <- glm( jitter(d) ~ d ) # class `lm`, `glm`
+   classFilter(ls(), include=c("character", "list"), envir = e)
+   classFilter(ls(), include = "numeric", envir = e)
+   classFilter(ls(), include = "numeric", exclude = "integer", envir = e)
+   classFilter(ls(), include = "lm", envir = e)
+   classFilter(ls(), include = "lm", exclude = "glm", envir = e)
+   rm(a, b, d, e, f, g, h)
+ })
> 
> ## from another environment
> e = new.env(parent = emptyenv())
> e$a <- list(1:10)     # class `list`
> e$b <- letters        # class `character`
> e$d <- stats::runif(10)      # class `numeric`
> e$f <- sample(1L:10L) # class `numeric`, `integer`
> e$g <- lm( jitter(e$d) ~ e$d ) # class `lm`
> e$h <- glm( jitter(e$d) ~ e$d ) # class `lm`, `glm`
> classFilter(ls(e), include=c("character", "list"), envir = e)
[1] "a" "b"
> classFilter(ls(e), include = "numeric", envir = e)
[1] "d" "f"
> classFilter(ls(e), include = "numeric", exclude = "integer", envir = e)
[1] "d"
> classFilter(ls(e), include = "lm", envir = e)
[1] "g" "h"
> classFilter(ls(e), include = "lm", exclude = "glm", envir = e)
[1] "g"
> rm(a, b, d, f, g, h, envir = e)
> rm(e)
> 
> 
> 
> 
> cleanEx()
> nameEx("copyModule")
> ### * copyModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: copyModule
> ### Title: Create a copy of an existing module
> ### Aliases: copyModule copyModule,character,character,character-method
> ###   copyModule,character,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: copyModule(from, to)
> 
> 
> 
> 
> cleanEx()
> nameEx("createsOutput")
> ### * createsOutput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: createsOutput
> ### Title: Define an output object of a module
> ### Aliases: createsOutput createsOutput,ANY,ANY,ANY-method
> ###   createsOutput,character,character,character-method
> 
> ### ** Examples
> 
> outputObjects <- dplyr::bind_rows(
+   createsOutput(objectName = "outputObject1", objectClass = "character",
+                 desc = "this is for example"),
+   createsOutput(objectName = "outputObject2", objectClass = "numeric",
+                 desc = "this is for example",
+                 otherInformation = "I am the second output object")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("defineModule")
> ### * defineModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defineModule
> ### Title: Define a new module.
> ### Aliases: defineModule defineModule,.simList,list-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## a default version of the defineModule is created with a call to newModule
> ##D   newModule("test", path = tempdir())
> ##D 
> ##D   ## view the resulting module file
> ##D   if (interactive()) file.edit(file.path(tempdir(), "test", "test.R"))
> ##D 
> ##D   # The default defineModule created by newModule is currently (SpaDES version 1.3.1.9044):
> ##D   defineModule(sim, list(
> ##D     name = "test",
> ##D     description = "insert module description here",
> ##D     keywords = c("insert key words here"),
> ##D     authors = c(person(c("First", "Middle"), "Last",
> ##D                        email = "email@example.com", role = c("aut", "cre"))),
> ##D     childModules = character(0),
> ##D     version = list(SpaDES = "1.3.1.9044", test = "0.0.1"),
> ##D     spatialExtent = raster::extent(rep(NA_real_, 4)),
> ##D     timeframe = as.POSIXlt(c(NA, NA)),
> ##D     timeunit = NA_character_, # e.g., "year",
> ##D     citation = list("citation.bib"),
> ##D     documentation = list("README.txt", "test.Rmd"),
> ##D     reqdPkgs = list(),
> ##D     parameters = rbind(
> ##D       #defineParameter("paramName", "paramClass", value, min, max,
> ##D       # "parameter description")),
> ##D       defineParameter(".plotInitialTime", "numeric", NA, NA, NA,
> ##D       "This describes the simulation time at which the first plot event should occur"),
> ##D       defineParameter(".plotInterval", "numeric", NA, NA, NA,
> ##D       "This describes the simulation time at which the first plot event should occur"),
> ##D       defineParameter(".saveInitialTime", "numeric", NA, NA, NA,
> ##D       "This describes the simulation time at which the first save event should occur"),
> ##D       defineParameter(".saveInterval", "numeric", NA, NA, NA,
> ##D       "This describes the simulation time at which the first save event should occur")
> ##D     ),
> ##D     inputObjects = bind_rows(
> ##D       expectsInput(objectName = NA_character_, objectClass = NA_character_,
> ##D         sourceURL = NA_character_, desc = NA_character_, other = NA_character_)
> ##D     ),
> ##D     outputObjects = bind_rows(
> ##D       createsOutput(objectName = NA_character_, objectClass = NA_character_,
> ##D         desc = NA_character_, other = NA_character_)
> ##D     )
> ##D   ))
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("defineParameter")
> ### * defineParameter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: defineParameter
> ### Title: Define a parameter used in a module
> ### Aliases: defineParameter
> ###   defineParameter,character,character,ANY,ANY,ANY,character-method
> ###   defineParameter,character,character,ANY,missing,missing,character-method
> ###   defineParameter,missing,missing,missing,missing,missing,missing-method
> 
> ### ** Examples
> 
> parameters = rbind(
+   defineParameter("lambda", "numeric", 1.23, desc = "intrinsic rate of increase"),
+   defineParameter("P", "numeric", 0.2, 0, 1, "probability of attack")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("dwrpnorm2")
> ### * dwrpnorm2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dwrpnorm2
> ### Title: Vectorized wrapped normal density function
> ### Aliases: dwrpnorm2
> 
> ### ** Examples
> 
> # Values for which to evaluate density
> theta <- c(1:500) * 2 * pi / 500
> # Compute wrapped normal density function
> density <- c(1:500)
> for(i in 1:500) density[i] <- dwrpnorm2(theta[i], pi, .75)
> if (interactive()) plot(theta, density)
> # Approximate area under density curve
> sum(density * 2 * pi / 500)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("expectsInput")
> ### * expectsInput
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expectsInput
> ### Title: Define an input object that the module expects.
> ### Aliases: expectsInput expectsInput,ANY,ANY,ANY,ANY-method
> ###   expectsInput,character,character,character,character-method
> ###   expectsInput,character,character,character,missing-method
> 
> ### ** Examples
> 
> inputObjects <- dplyr::bind_rows(
+   expectsInput(objectName = "inputObject1", objectClass = "character",
+                desc = "this is for example", sourceURL = "not available"),
+   expectsInput(objectName = "inputObject2", objectClass = "numeric",
+                desc = "this is for example", sourceURL = "not available",
+                otherInformation = "I am the second input object")
+ )
> 
> 
> 
> 
> cleanEx()
> nameEx("experiment")
> ### * experiment
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: experiment
> ### Title: Run an experiment using 'spades'
> ### Aliases: experiment experiment,simList-method
> 
> ### ** Examples
> 
> if (interactive()) {
+   library(igraph) # use %>% in a few examples
+   library(raster)
+ 
+   tmpdir <- file.path(tempdir(), "examples")
+ 
+   # Create a default simList object for use through these examples
+   mySim <- simInit(
+     times = list(start = 0.0, end = 2.0, timeunit = "year"),
+     params = list(
+       .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
+       # Turn off interactive plotting
+       fireSpread = list(.plotInitialTime = NA),
+       caribouMovement = list(.plotInitialTime = NA),
+       randomLandscapes = list(.plotInitialTime = NA)
+     ),
+     modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
+     paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
+                  outputPath = tmpdir),
+     # Save final state of landscape and caribou
+     outputs = data.frame(objectName = c("landscape", "caribou"), stringsAsFactors = FALSE)
+   )
+ 
+   # Example 1 - test alternative parameter values
+   # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
+   #    and 2 levels of 1 param in caribouMovement)
+ 
+   # Here is a list of alternative values for each parameter. They are length one
+   #   numerics here -- e.g., list(0.2, 0.23) for spreadprob in fireSpread module,
+   #   but they can be anything, as long as it is a list.
+   experimentParams <- list(fireSpread = list(spreadprob = list(0.2, 0.23),
+                                              nFires = list(20, 10)),
+                            caribouMovement = list(N = list(100, 1000)))
+ 
+   sims <- experiment(mySim, params = experimentParams)
+ 
+   # see experiment:
+   attr(sims, "experiment")
+ 
+   # Read in outputs from sims object
+   FireMaps <- do.call(stack, lapply(1:NROW(attr(sims, "experiment")$expDesign),
+                                     function(x) sims[[x]]$landscape$Fires))
+   if (interactive()) Plot(FireMaps, new = TRUE)
+ 
+   # Or reload objects from files, useful if sim objects too large to store in RAM
+   caribouMaps <- lapply(sims, function(sim) {
+     caribou <- readRDS(outputs(sim)$file[outputs(sim)$objectName == "caribou"])
+   })
+   names(caribouMaps) <- paste0("caribou", 1:8)
+   # Plot whole named list
+   if (interactive()) Plot(caribouMaps, size = 0.1)
+ 
+   # Example 2 - test alternative modules
+   # Example of changing modules, i.e., caribou with and without fires
+   # Create an experiment - here, 2 x 2 x 2 (2 levels of 2 params in fireSpread,
+   #    and 2 levels of 1 param in caribouMovement)
+   experimentModules <- list(
+     c("randomLandscapes", "fireSpread", "caribouMovement"),
+     c("randomLandscapes", "caribouMovement"))
+   sims <- experiment(mySim, modules = experimentModules)
+   attr(sims, "experiment")$expVals # shows 2 alternative experiment levels
+ 
+   # Example 3 - test alternative parameter values and modules
+   # Note, this isn't fully factorial because all parameters are not
+   #   defined inside smaller module list
+   sims <- experiment(mySim, modules = experimentModules, params = experimentParams)
+   attr(sims, "experiment")$expVals # shows 10 alternative experiment levels
+ 
+   # Example 4 - manipulate manipulate directory names -
+   #  "simNum" is special value for dirPrefix, it is converted to 1, 2, ...
+   sims <- experiment(mySim, params = experimentParams, dirPrefix = c("expt", "simNum"))
+   attr(sims, "experiment")$expVals # shows 8 alternative experiment levels, 24 unique
+                                    #   parameter values
+ 
+   # Example 5 - doing replicate runs -
+   sims <- experiment(mySim, replicates = 2)
+   attr(sims, "experiment")$expDesign # shows 2 replicates of same experiment
+ 
+   # Example 6 - doing replicate runs, but within a sub-directory
+   sims <- experiment(mySim, replicates = 2, dirPrefix = c("expt"))
+   lapply(sims, outputPath) # shows 2 replicates of same experiment, within a sub directory
+ 
+   # Example 7 - doing replicate runs, of a complex, non factorial experiment.
+   # Here we do replication, parameter variation, and module variation all together.
+   # This creates 20 combinations.
+   # The experiment function tries to make fully factorial, but won't
+   # if all the levels don't make sense. Here, changing parameter values
+   # in the fireSpread module won't affect the simulation when the fireSpread
+   # module is not loaded:
+ 
+   # library(raster)
+   # beginCluster(20) # if you have multiple clusters available, use them here to save time
+   sims <- experiment(mySim, replicates = 2, params = experimentParams,
+                      modules = experimentModules,
+                      dirPrefix = c("expt", "simNum"))
+   # endCluster() # end the clusters
+   attr(sims, "experiment")
+ 
+   # Example 8 - Use replication to build a probability map.
+   # For this to be meaningful, we need to provide a fixed input landscape,
+   #   not a randomLandscape for each experiment level. So requires 2 steps.
+   # Step 1 - run randomLandscapes module twice to get 2 randomly
+   #  generated landscape maps. We will use 1 right away, and we will
+   #  use the two further below
+   mySimRL <- simInit(
+     times = list(start = 0.0, end = 0.1, timeunit = "year"),
+     params = list(
+       .globals = list(stackName = "landscape"),
+       # Turn off interactive plotting
+       randomLandscapes = list(.plotInitialTime = NA)
+     ),
+     modules = list("randomLandscapes"),
+     paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
+                  outputPath = file.path(tmpdir, "landscapeMaps1")),
+     outputs = data.frame(objectName = "landscape", saveTime = 0, stringsAsFactors = FALSE)
+   )
+   # Run it twice to get two copies of the randomly generated landscape
+   mySimRLOut <- experiment(mySimRL, replicate = 2)
+ 
+   # extract one of the random landscapes, which will be passed into next as an object
+   landscape <- mySimRLOut[[1]]$landscape
+ 
+   # here we don't run the randomLandscapes module; instead we pass in a landscape
+   #  as an object, i.e., a fixed input
+   mySimNoRL <- simInit(
+     times = list(start = 0.0, end = 1, timeunit = "year"), # only 1 year to save time
+     params = list(
+       .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
+       # Turn off interactive plotting
+       fireSpread = list(.plotInitialTime = NA),
+       caribouMovement = list(.plotInitialTime = NA)
+     ),
+     modules = list("fireSpread", "caribouMovement"), # No randomLandscapes modules
+     paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
+                  outputPath = tmpdir),
+     objects = c("landscape"), # Pass in the object here
+     # Save final state (the default if saveTime is not specified) of landscape and caribou
+     outputs = data.frame(objectName = c("landscape", "caribou"), stringsAsFactors = FALSE)
+   )
+ 
+   # Put outputs into a specific folder to keep them easy to find
+   outputPath(mySimNoRL) <- file.path(tmpdir, "example8")
+   sims <- experiment(mySimNoRL, replicates = 8) # Run experiment
+   attr(sims, "experiment") # shows the experiment, which in this case is just replicates
+ 
+   # list all files that were saved called 'landscape'
+   landscapeFiles <- dir(outputPath(mySimNoRL), recursive = TRUE, pattern = "landscape",
+                         full.names = TRUE)
+ 
+   # Can read in Fires layers from disk since they were saved, or from the sims
+   #  object
+   # Fires <- lapply(sims, function(x) x$landscape$Fires) %>% stack
+   Fires <- lapply(landscapeFiles, function(x) readRDS(x)$Fires) %>% stack()
+   Fires[Fires > 0] <- 1 # convert to 1s and 0s
+   fireProb <- sum(Fires) / nlayers(Fires) # sum them and convert to probability
+   if (interactive()) Plot(fireProb, new = TRUE)
+ 
+   # Example 9 - Pass in inputs, i.e., input data objects taken from disk
+   #  Here, we, again, don't provide randomLandscapes module, so we need to
+   #  provide an input stack called lanscape. We point to the 2 that we have
+   #  saved to disk in Example 8
+   mySimInputs <- simInit(
+     times = list(start = 0.0, end = 2.0, timeunit = "year"),
+     params = list(
+       .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
+       # Turn off interactive plotting
+       fireSpread = list(.plotInitialTime = NA),
+       caribouMovement = list(.plotInitialTime = NA)
+     ),
+     modules = list("fireSpread", "caribouMovement"),
+     paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
+                  outputPath = tmpdir),
+     # Save final state of landscape and caribou
+     outputs = data.frame(objectName = c("landscape", "caribou"), stringsAsFactors = FALSE)
+   )
+   landscapeFiles <- dir(tmpdir, pattern = "landscape_year0", recursive = TRUE, full.names = TRUE)
+ 
+   # Varying inputs files - This could be combined with params, modules, replicates also
+   outputPath(mySimInputs) <- file.path(tmpdir, "example9")
+   sims <- experiment(mySimInputs,
+                      inputs = lapply(landscapeFiles, function(filenames) {
+                        data.frame(file = filenames, loadTime = 0,
+                                   objectName = "landscape",
+                                   stringsAsFactors = FALSE)
+                      })
+    )
+ 
+   # load in experimental design object
+   experiment <- load(file = file.path(tmpdir, "example9", "experiment.RData")) %>% get()
+   print(experiment) # shows input files and details
+ 
+   # Example 10 - Use a very simple output dir name using substrLength = 0,
+   #   i.e., just the simNum is used for outputPath of each spades call
+   outputPath(mySim) <- file.path(tmpdir, "example10")
+   sims <- experiment(mySim, modules = experimentModules, replicates = 2,
+                      substrLength = 0)
+   lapply(sims, outputPath) # shows that the path is just the simNum
+   experiment <- load(file = file.path(tmpdir, "example10", "experiment.RData")) %>% get()
+   print(experiment) # shows input files and details
+ 
+   # Example 11 - use clearSimEnv = TRUE to remove objects from simList
+   # This will shrink size of return object, which may be useful because the
+   #  return from experiment function may be a large object (it is a list of
+   # simLists). To see size of a simList, you have to look at the objects
+   #  contained in the  envir(simList).  These can be obtained via objs(sim)
+   sapply(sims, function(x) object.size(objs(x))) %>% sum + object.size(sims)
+   # around 3 MB
+   # rerun with clearSimEnv = TRUE
+   sims <- experiment(mySim, modules = experimentModules, replicates = 2,
+                      substrLength = 0, clearSimEnv = TRUE)
+   sapply(sims, function(x) object.size(objs(x))) %>% sum + object.size(sims)
+   # around 250 kB, i.e., all the simList contents except the objects.
+ 
+   # Example 12 - pass in objects
+   experimentObj <- list(landscape = lapply(landscapeFiles, readRDS) %>%
+                                     setNames(paste0("landscape", 1:2)))
+   # Pass in this list of landscape objects
+   sims <- experiment(mySimNoRL, objects = experimentObj)
+ 
+   # Remove all temp files
+   unlink(tmpdir, recursive = TRUE)
+ }
> 
> 
> 
> cleanEx()
> nameEx("loadFiles")
> ### * loadFiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: .fileExtensions
> ### Title: File extensions map
> ### Aliases: .fileExtensions loadFiles loadFiles,simList,missing-method
> ###   loadFiles,missing,ANY-method loadFiles,missing,missing-method
> ###   .saveFileExtensions saveSimList
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # Load random maps included with package
> ##D filelist <- data.frame(
> ##D     files = dir(system.file("maps", package = "quickPlot"),
> ##D             full.names = TRUE, pattern = "tif"),
> ##D     functions = "rasterToMemory", package = "quickPlot"
> ##D )
> ##D sim1 <- loadFiles(filelist = filelist)
> ##D clearPlot()
> ##D if (interactive()) Plot(sim1$DEM)
> ##D 
> ##D # Second, more sophisticated. All maps loaded at time = 0, and the last one is reloaded
> ##D #  at time = 10 and 20 (via "intervals").
> ##D # Also, pass the single argument as a list to all functions...
> ##D #  specifically, when add "native = TRUE" as an argument to the raster function
> ##D files = dir(system.file("maps", package = "quickPlot"),
> ##D             full.names = TRUE, pattern = "tif")
> ##D arguments = I(rep(list(native = TRUE), length(files)))
> ##D filelist = data.frame(
> ##D    files = files,
> ##D    functions = "raster::raster",
> ##D    objectName = NA,
> ##D    arguments = arguments,
> ##D    loadTime = 0,
> ##D    intervals = c(rep(NA, length(files)-1), 10)
> ##D )
> ##D 
> ##D sim2 <- loadFiles(filelist = filelist)
> ##D 
> ##D # if we extend the end time and continue running, it will load an object scheduled
> ##D #  at time = 10, and it will also schedule a new object loading at 20 because
> ##D #  interval = 10
> ##D end(sim2) <- 20
> ##D sim2 <- spades(sim2) # loads the percentPine map 2 more times, once at 10, once at 20
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("loadPackages")
> ### * loadPackages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: loadPackages
> ### Title: Load packages.
> ### Aliases: loadPackages loadPackages,character-method
> ###   loadPackages,list-method loadPackages,NULL-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   pkgs <- list("raster", "lme4")
> ##D   loadPackages(pkgs) # loads packages if installed
> ##D   loadPackages(pkgs, install = TRUE) # loads packages after installation (if needed)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("moduleCoverage")
> ### * moduleCoverage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleCoverage
> ### Title: Calculate module coverage of unit tests
> ### Aliases: moduleCoverage moduleCoverage,character,character-method
> ###   moduleCoverage,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  library(igraph) # for %>%
> ##D  library(SpaDES.core)
> ##D  tmpdir <- file.path(tempdir(), "coverage")
> ##D  modulePath <- file.path(tmpdir, "Modules") %>% checkPath(create = TRUE)
> ##D  moduleName <- "forestAge" # sample module to test
> ##D  downloadModule(name = moduleName, path = modulePath) # download sample module
> ##D  testResults <- moduleCoverage(name = moduleName, path = modulePath)
> ##D  shine(testResults$moduleCoverage)
> ##D  shine(testResults$functionCoverage)
> ##D  unlink(tmpdir, recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("moduleMetadata")
> ### * moduleMetadata
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleMetadata
> ### Title: Parse and extract module metadata
> ### Aliases: moduleMetadata
> ###   moduleMetadata,character,character,missing-method
> ###   moduleMetadata,character,missing,missing-method
> ###   moduleMetadata,ANY,missing,simList-method
> 
> ### ** Examples
> 
> path <- system.file("sampleModules", package = "SpaDES.core")
> sampleModules <- dir(path)
> x <- moduleMetadata(sampleModules[3], path)
> 
> # using simList
> mySim <- simInit(
+    times = list(start = 2000.0, end = 2002.0, timeunit = "year"),
+    params = list(
+      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
+    ),
+    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
+    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
+ )
> moduleMetadata(sim = mySim)
$randomLandscapes
$randomLandscapes$name
[1] "randomLandscapes"

$randomLandscapes$description
[1] "Generate RasterStack of random maps representative of a forest landscape (DEM, forestAge, forestCover, habitatQuality, percentPine). Requires a global simulation parameter `stackName` be set."

$randomLandscapes$keywords
[1] "random map"       "random landscape"

$randomLandscapes$childModules
character(0)

$randomLandscapes$authors
[1] "Alex M Chubaty <alexander.chubaty@canada.ca> [aut, cre]" 
[2] "Eliot J B McIntire <eliot.mcintire@canada.ca> [aut, cre]"

$randomLandscapes$version
$randomLandscapes$version$SpaDES.core
[1] "0.1.0"

$randomLandscapes$version$SpaDES.tools
[1] "0.1.0"

$randomLandscapes$version$randomLandscapes
[1] "1.6.0"


$randomLandscapes$spatialExtent
class       : Extent 
xmin        : NA 
xmax        : NA 
ymin        : NA 
ymax        : NA 

$randomLandscapes$timeframe
[1] NA NA

$randomLandscapes$timeunit
[1] "year"

$randomLandscapes$citation
list()

$randomLandscapes$documentation
list()

$randomLandscapes$reqdPkgs
$randomLandscapes$reqdPkgs[[1]]
[1] "raster"

$randomLandscapes$reqdPkgs[[2]]
[1] "RColorBrewer"

$randomLandscapes$reqdPkgs[[3]]
[1] "tkrplot"

$randomLandscapes$reqdPkgs[[4]]
[1] "RandomFields"

$randomLandscapes$reqdPkgs[[5]]
[1] "SpaDES.tools"


$randomLandscapes$parameters
         paramName paramClass    default        min   max
1            inRAM    logical      FALSE       TRUE FALSE
2               nx    numeric        100         10   500
3               ny    numeric        100         10   500
4        stackName  character  landscape         NA    NA
5 .plotInitialTime    numeric start(sim) start(sim)    NA
6    .plotInterval    numeric         NA         NA    NA
7 .saveInitialTime    numeric         NA         NA    NA
8    .saveInterval    numeric         NA         NA    NA
9        .useCache    logical      FALSE init, plot    NA
                                          paramDesc
1            should the raster be stored in memory?
2 size of map (number of pixels) in the x dimension
3 size of map (number of pixels) in the y dimension
4                           name of the RasterStack
5                 time to schedule first plot event
6                 time interval between plot events
7                 time to schedule first save event
8                 time interval between save events
9 should the module result be cached for future use

$randomLandscapes$inputObjects
  objectName objectClass desc sourceURL other
1       <NA>        <NA> <NA>      <NA>    NA

$randomLandscapes$outputObjects
                            objectName objectClass desc other
1 P(sim, "randomLandscapes")$stackName RasterStack <NA>    NA


$caribouMovement
$caribouMovement$name
[1] "caribouMovement"

$caribouMovement$description
[1] "Simulate caribou movement via correlated random walk."

$caribouMovement$keywords
[1] "caribou"                         "individual based movement model"
[3] "correlated random walk"         

$caribouMovement$childModules
character(0)

$caribouMovement$authors
[1] "Eliot J B McIntire <eliot.mcintire@canada.ca> [aut, cre]"

$caribouMovement$version
$caribouMovement$version$SpaDES.core
[1] "0.1.0"

$caribouMovement$version$SpaDES.tools
[1] "0.1.0"

$caribouMovement$version$caribouMovement
[1] "1.6.0"


$caribouMovement$spatialExtent
class       : Extent 
xmin        : NA 
xmax        : NA 
ymin        : NA 
ymax        : NA 

$caribouMovement$timeframe
[1] NA NA

$caribouMovement$timeunit
[1] "month"

$caribouMovement$citation
list()

$caribouMovement$documentation
list()

$caribouMovement$reqdPkgs
$caribouMovement$reqdPkgs[[1]]
[1] "grid"

$caribouMovement$reqdPkgs[[2]]
[1] "raster"

$caribouMovement$reqdPkgs[[3]]
[1] "sp"

$caribouMovement$reqdPkgs[[4]]
[1] "stats"

$caribouMovement$reqdPkgs[[5]]
[1] "SpaDES.tools"


$caribouMovement$parameters
         paramName paramClass      default          min      max
1        stackName  character    landscape           NA       NA
2  moveInitialTime    numeric start(si.... start(si.... end(sim)
3     moveInterval    numeric            1            1        1
4                N    numeric          100           10     1000
5            torus    logical        FALSE        FALSE     TRUE
6 .plotInitialTime    numeric   start(sim)         -Inf      Inf
7    .plotInterval    numeric            1         -Inf      Inf
8 .saveInitialTime    numeric           NA         -Inf      Inf
9    .saveInterval    numeric           NA         -Inf      Inf
                                 paramDesc
1                  name of the RasterStack
2    time to schedule first movement event
3    time interval between movoment events
4                initial number of caribou
5 should the map wrap around like a torus?
6        time to schedule first plot event
7        time interval between plot events
8        time to schedule first save event
9        time interval between save events

$caribouMovement$inputObjects
                           objectName objectClass                         desc
1 P(sim, "caribouMovement")$stackName RasterStack layername = "habitatQuality"
  sourceURL
1      <NA>

$caribouMovement$outputObjects
                           objectName            objectClass
1 P(sim, "caribouMovement")$stackName            RasterStack
2                             caribou SpatialPointsDataFrame
                          desc
1 layername = "habitatQuality"
2                         <NA>


$fireSpread
$fireSpread$name
[1] "fireSpread"

$fireSpread$description
[1] "Simulate fire ignition and spread on a landscape, where spread probability varies according to percent pine. Fire size statistics are collected immediately after each burn event. Requires a global simulation parameter `stackName` be set."

$fireSpread$keywords
[1] "fire"              "percolation model" "spread algorithm" 

$fireSpread$childModules
character(0)

$fireSpread$authors
[1] "Alex M Chubaty <alexander.chubaty@canada.ca> [aut, cre]" 
[2] "Eliot J B McIntire <eliot.mcintire@canada.ca> [aut, cre]"
[3] "Steve Cumming <Steve.Cumming@sbf.ulaval.ca> [aut]"       

$fireSpread$version
$fireSpread$version$SpaDES.core
[1] "0.1.0"

$fireSpread$version$SpaDES.tools
[1] "0.1.0"

$fireSpread$version$fireSpread
[1] "1.6.0"


$fireSpread$spatialExtent
class       : Extent 
xmin        : NA 
xmax        : NA 
ymin        : NA 
ymax        : NA 

$fireSpread$timeframe
[1] NA NA

$fireSpread$timeunit
[1] "year"

$fireSpread$citation
list()

$fireSpread$documentation
list()

$fireSpread$reqdPkgs
$fireSpread$reqdPkgs[[1]]
[1] "methods"

$fireSpread$reqdPkgs[[2]]
[1] "raster"

$fireSpread$reqdPkgs[[3]]
[1] "RColorBrewer"

$fireSpread$reqdPkgs[[4]]
[1] "SpaDES.tools"


$fireSpread$parameters
          paramName paramClass      default        min          max
1         stackName  character    landscape         NA           NA
2            nFires    numeric           10          1          100
3               its    numeric        1e+06      1e+06        1e+06
4       persistprob    numeric            0          0            1
5    returnInterval    numeric            1          1            1
6        spreadprob    numeric        0.225       0.05          0.5
7         startTime    numeric start(si....          0     end(sim)
8  .plotInitialTime    numeric   start(sim) start(sim) end(sim) + 1
9     .plotInterval    numeric            1          1            1
10 .saveInitialTime    numeric           NA         NA           NA
11    .saveInterval    numeric           NA         NA           NA
                                    paramDesc
1                     name of the RasterStack
2                 number of fires to initiate
3        number of iterations for fire spread
4   probability of fire persisting in a pixel
5                        fire return interval
6  probability of fire spreading into a pixel
7               time of initial fire ignition
8           time to schedule first plot event
9           time interval between plot events
10          time to schedule first save event
11          time interval between save events

$fireSpread$inputObjects
                      objectName objectClass desc sourceURL
1 P(sim, "fireSpread")$stackName RasterStack <NA>      <NA>
2         globals(sim)$burnStats     numeric <NA>      <NA>

$fireSpread$outputObjects
                      objectName objectClass desc other
1 P(sim, "fireSpread")$stackName RasterStack <NA>    NA
2         globals(sim)$burnStats     numeric <NA>    NA


> 
> 
> 
> cleanEx()
> nameEx("moduleVersion")
> ### * moduleVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moduleVersion
> ### Title: Parse and extract a module's version
> ### Aliases: moduleVersion moduleVersion,character,character,missing-method
> ###   moduleVersion,character,missing,missing-method
> ###   moduleVersion,character,missing,simList-method
> 
> ### ** Examples
> 
> path <- system.file("sampleModules", package = "SpaDES.core")
> 
> # using filepath
> moduleVersion("caribouMovement", path)
[1] ‘1.6.0’
> 
> # using simList
> mySim <- simInit(
+    times = list(start = 2000.0, end = 2002.0, timeunit = "year"),
+    params = list(
+      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
+    ),
+    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
+    paths = list(modulePath = path)
+ )
> moduleVersion("caribouMovement", sim = mySim)
[1] ‘1.6.0’
> 
> 
> 
> cleanEx()
> nameEx("newModule")
> ### * newModule
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: newModule
> ### Title: Create new module from template
> ### Aliases: newModule newModule,character,character-method
> ###   newModule,character,missing-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   ## create a "myModule" module in the "modules" subdirectory.
> ##D   newModule("myModule", "modules")
> ##D 
> ##D   ## create a new parent module in the "modules" subdirectory.
> ##D   newModule("myParentModule", "modules", type = "parent", children = c("child1", "child2"))
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("openModules")
> ### * openModules
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: openModules
> ### Title: Open all modules nested within a base directory
> ### Aliases: openModules openModules,character,character-method
> ###   openModules,missing,missing-method
> ###   openModules,missing,character-method
> ###   openModules,character,missing-method
> ###   openModules,simList,missing-method
> 
> ### ** Examples
> 
> ## Not run: openModules("~\SpaDESModules")
> 
> 
> 
> 
> cleanEx()
> nameEx("paddedFloatToChar")
> ### * paddedFloatToChar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paddedFloatToChar
> ### Title: Convert numeric to character with padding
> ### Aliases: paddedFloatToChar
> 
> ### ** Examples
> 
> paddedFloatToChar(1.25)
[1] "1.250"
> paddedFloatToChar(1.25, padL = 3, padR = 5)
[1] "001.25000"
> 
> 
> 
> 
> cleanEx()
> nameEx("params")
> ### * params
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: params
> ### Title: Get and set simulation parameters.
> ### Aliases: params simList-accessors-params params,.simList-method
> ###   params<- params<- params<-,.simList-method P simList-accessors-params
> ###   P,.simList-method parameters parameters,.simList-method
> 
> ### ** Examples
> 
> modules <- list("randomLandscapes")
> paths <- list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
> mySim <- simInit(modules = modules, paths = paths,
+                  params = list(.globals = list(stackName = "landscape")))
> parameters(mySim)
$randomLandscapes
$randomLandscapes$inRAM
  paramClass default  min   max                              paramDesc
1    logical   FALSE TRUE FALSE should the raster be stored in memory?

$randomLandscapes$nx
  paramClass default min max                                         paramDesc
2    numeric     100  10 500 size of map (number of pixels) in the x dimension

$randomLandscapes$ny
  paramClass default min max                                         paramDesc
3    numeric     100  10 500 size of map (number of pixels) in the y dimension

$randomLandscapes$stackName
  paramClass   default min max               paramDesc
4  character landscape  NA  NA name of the RasterStack

$randomLandscapes$.plotInitialTime
  paramClass default min max                         paramDesc
5    numeric       0   0  NA time to schedule first plot event

$randomLandscapes$.plotInterval
  paramClass default min max                         paramDesc
6    numeric      NA  NA  NA time interval between plot events

$randomLandscapes$.saveInitialTime
  paramClass default min max                         paramDesc
7    numeric      NA  NA  NA time to schedule first save event

$randomLandscapes$.saveInterval
  paramClass default min max                         paramDesc
8    numeric      NA  NA  NA time interval between save events

$randomLandscapes$.useCache
  paramClass default        min max
9    logical   FALSE init, plot  NA
                                          paramDesc
9 should the module result be cached for future use


> 
> 
> 
> 
> cleanEx()
> nameEx("progress")
> ### * progress
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: progressInterval
> ### Title: Get and set simulation progress bar details
> ### Aliases: progressInterval progressInterval,.simList-method
> ###   progressInterval<- progressInterval<-
> ###   progressInterval<-,.simList-method progressType
> ###   progressType,.simList-method progressType<- progressType<-
> ###   progressType<-,.simList-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D mySim <- simInit(
> ##D   times = list(start=0.0, end=100.0),
> ##D   params = list(.globals = list(stackName = "landscape"),
> ##D   .progress = list(type = "text", interval = 10),
> ##D   .checkpoint = list(interval = 10, file = "chkpnt.RData")),
> ##D   modules = list("randomLandscapes"),
> ##D   paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core")))
> ##D 
> ##D # progress bar
> ##D progressType(mySim) # "text"
> ##D progressInterval(mySim) # 10
> ##D 
> ##D # parameters
> ##D params(mySim) # returns all parameters in all modules
> ##D               # including .global, .progress, .checkpoint
> ##D globals(mySim) # returns only global parameters
> ##D 
> ##D # checkpoint
> ##D checkpointFile(mySim) # returns the name of the checkpoint file
> ##D                       # In this example, "chkpnt.RData"
> ##D checkpointInterval(mySim) # 10
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rndstr")
> ### * rndstr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rndstr
> ### Title: Generate random strings
> ### Aliases: rndstr rndstr,numeric,numeric,logical-method
> ###   rndstr,numeric,numeric,missing-method
> ###   rndstr,numeric,missing,logical-method
> ###   rndstr,missing,numeric,logical-method
> ###   rndstr,numeric,missing,missing-method
> ###   rndstr,missing,numeric,missing-method
> ###   rndstr,missing,missing,logical-method
> ###   rndstr,missing,missing,missing-method
> 
> ### ** Examples
> 
> set.seed(11)
> rndstr()
[1] "o0v04X5h"
> rndstr(len = 10)
[1] "T7arUQJztk"
> rndstr(characterFirst = FALSE)
[1] "9tcGml3t"
> rndstr(n = 5, len = 10)
[1] "u17ovkpcOD" "o6f3fduEkR" "H0wPvBqjdr" "vOaB8KazKb" "cubCGqqcWx"
> rndstr(n = 5)
[1] "okmd3uve" "QpbEOdmL" "atOeLbAd" "OFppcgGJ" "D8H5rOFi"
> rndstr(n = 5, characterFirst = TRUE)
[1] "WrwfchZa" "x41RHDXG" "lw8tgHMZ" "JyrGdwAk" "TiyLfLFD"
> rndstr(len = 10, characterFirst = TRUE)
[1] "hbEztiCfgO"
> rndstr(n = 5, len = 10, characterFirst = TRUE)
[1] "j2ZbgP6LHD" "kN4mS69oPh" "phHSmcUZ7J" "VzgLkiAcIU" "xa1GIVGA9Z"
> 
> 
> 
> 
> cleanEx()
> nameEx("saveFiles")
> ### * saveFiles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: saveFiles
> ### Title: Save objects using '.saveObjects' in 'params' slot of 'simInit'
> ### Aliases: saveFiles
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D # This will save the "caribou" object at the save interval of 1 unit of time
> ##D #  in the outputPath location
> ##D outputPath <- file.path(tempdir(), "test_save")
> ##D times <- list(start = 0, end = 6, "month")
> ##D parameters <- list(
> ##D   .globals = list(stackName = "landscape"),
> ##D   caribouMovement = list(
> ##D     .saveObjects = "caribou",
> ##D     .saveInitialTime = 1, .saveInterval = 1
> ##D   ),
> ##D   randomLandscapes = list(.plotInitialTime = NA, nx = 20, ny = 20))
> ##D 
> ##D modules <- list("randomLandscapes", "caribouMovement")
> ##D paths <- list(
> ##D   modulePath = system.file("sampleModules", package = "SpaDES.core"),
> ##D   outputPath = savePath
> ##D )
> ##D mySim <- simInit(times = times, params = parameters, modules = modules,
> ##D                  paths = paths)
> ##D 
> ##D # The caribou module has a saveFiles(sim) call, so it will save caribou
> ##D spades(mySim)
> ##D dir(outputPath)
> ##D 
> ##D # remove the files
> ##D file.remove(dir(savePath, full.names = TRUE))
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("scheduleEvent")
> ### * scheduleEvent
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scheduleEvent
> ### Title: Schedule a simulation event
> ### Aliases: scheduleEvent
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn") # default priority
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn", .normal()) # default priority
> ##D 
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn", .normal()-1) # higher priority
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn", .normal()+1) # lower priority
> ##D 
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn", .highest()) # highest priority
> ##D  scheduleEvent(x, time(sim) + 1.0, "firemodule", "burn", .lowest()) # lowest priority
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("setPaths")
> ### * setPaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setPaths
> ### Title: Get and set default working directories
> ### Aliases: setPaths .paths getPaths setPaths
> ### Keywords: internal
> 
> ### ** Examples
> 
> ## Not run: 
> ##D getPaths()                       ## returns the current default working paths
> ##D setPaths(cachePath = tempdir())  ## sets custom cachePath with other paths default
> ##D setPaths(inputPath = tempdir())  ## sets custom inputPath with other paths default
> ##D setPaths(modulePath = tempdir()) ## sets custom modulePath with other paths default
> ##D setPaths(outputPath = tempdir()) ## sets custom outputPath with other paths default
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("simInit")
> ### * simInit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: simInit
> ### Title: Initialize a new simulation
> ### Aliases: simInit
> ###   simInit,list,list,list,list,list,data.frame,data.frame,character-method
> ###   simInit,ANY,ANY,ANY,character,ANY,ANY,ANY,ANY-method
> ###   simInit,ANY,ANY,character,ANY,ANY,ANY,ANY,ANY-method
> ###   simInit,ANY,ANY,ANY,ANY,ANY,ANY,ANY,ANY-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D mySim <- simInit(
> ##D  times = list(start = 0.0, end = 2.0, timeunit = "year"),
> ##D  params = list(
> ##D    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
> ##D  ),
> ##D  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
> ##D )
> ##D spades(mySim, .plotInitialTime = NA)
> ##D 
> ##D # Change more parameters, removing plotting
> ##D mySim <- simInit(
> ##D  times = list(start = 0.0, end = 2.0, timeunit = "year"),
> ##D  params = list(
> ##D    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned"),
> ##D    fireSpread = list(.plotInitialTime = NA)
> ##D  ),
> ##D  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
> ##D )
> ##D outSim <- spades(mySim)
> ##D 
> ##D # A little more complicated with inputs and outputs
> ##D if (require(rgdal)) {
> ##D  mapPath <- system.file("maps", package = "quickPlot")
> ##D  mySim <- simInit(
> ##D    times = list(start = 0.0, end = 2.0, timeunit = "year"),
> ##D    params = list(
> ##D      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
> ##D    ),
> ##D    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
> ##D                 outputPath = tempdir()),
> ##D    inputs = data.frame(
> ##D      files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
> ##D      functions = "raster",
> ##D      package = "raster",
> ##D      loadTime = 1,
> ##D      stringsAsFactors = FALSE),
> ##D    outputs = data.frame(
> ##D      expand.grid(objectName = c("caribou","landscape"),
> ##D      saveTime = 1:2,
> ##D      stringsAsFactors = FALSE))
> ##D  )
> ##D 
> ##D  # Use accessors for inputs, outputs
> ##D  mySim2 <- simInit(
> ##D    times = list(current = 0, start = 0.0, end = 2.0, timeunit = "year"),
> ##D    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D    params = list(.globals = list(stackName = "landscape", burnStats = "nPixelsBurned")),
> ##D    paths = list(
> ##D      modulePath = system.file("sampleModules", package = "SpaDES.core"),
> ##D      outputPath = tempdir()
> ##D    )
> ##D  )
> ##D 
> ##D  # add by accessor is equivalent
> ##D  inputs(mySim2) <- data.frame(
> ##D      files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
> ##D      functions = "raster",
> ##D      package = "raster",
> ##D      loadTime = 1,
> ##D      stringsAsFactors = FALSE)
> ##D  outputs(mySim2) <- data.frame(
> ##D      expand.grid(objectName = c("caribou", "landscape"),
> ##D      saveTime = 1:2,
> ##D      stringsAsFactors = FALSE))
> ##D  all.equal(mySim, mySim2) # TRUE
> ##D 
> ##D  # Use accessors for times -- does not work as desired because times are
> ##D  #   adjusted to the input timeunit during simInit
> ##D  mySim2 <- simInit(
> ##D    params = list(
> ##D      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
> ##D    ),
> ##D    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"),
> ##D                 outputPath = tempdir()),
> ##D    inputs = data.frame(
> ##D      files = dir(file.path(mapPath), full.names = TRUE, pattern = "tif")[1:2],
> ##D      functions = "raster",
> ##D      package = "raster",
> ##D      loadTime = 1,
> ##D      stringsAsFactors = FALSE),
> ##D    outputs = data.frame(
> ##D      expand.grid(objectName = c("caribou","landscape"),
> ##D      saveTime = 1:2,
> ##D      stringsAsFactors = FALSE))
> ##D  )
> ##D 
> ##D  # add times by accessor fails all.equal test because "year" was not
> ##D  #   declared during module loading, so month became the default
> ##D  times(mySim2) <- list(current = 0, start = 0.0, end = 2.0, timeunit = "year")
> ##D  all.equal(mySim, mySim2) # fails because time units are all different, so
> ##D                           # several parameters that have time units in
> ##D                           # "months" because they were loaded that way
> ##D  params(mySim)$fireSpread$.plotInitialTime
> ##D  params(mySim2)$fireSpread$.plotInitialTime
> ##D  events(mySim) # load event is at time 1 year
> ##D  events(mySim2) # load event is at time 1 month, reported in years because of
> ##D                 #   update to times above
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("simList-accessors-inout")
> ### * simList-accessors-inout
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inputs
> ### Title: Inputs and outputs
> ### Aliases: inputs simList-accessors-inout inputs,.simList-method inputs<-
> ###   inputs<- inputs<-,.simList-method outputs outputs,.simList-method
> ###   outputs<- outputs<- outputs<-,.simList-method inputArgs
> ###   inputArgs,.simList-method inputArgs<- inputArgs<-
> ###   inputArgs<-,.simList-method outputArgs outputArgs,.simList-method
> ###   outputArgs<- outputArgs<- outputArgs<-,.simList-method
> 
> ### ** Examples
> 
> #######################
> # inputs
> #######################
> 
> # Start with a basic empty simList
> sim <- simInit()
> 
> test <- 1:10
> library(igraph) # for %>%

Attaching package: ‘igraph’

The following objects are masked from ‘package:stats’:

    decompose, spectrum

The following object is masked from ‘package:base’:

    union

> library(reproducible) # for checkPath
> tmpdir <- file.path(tempdir(), "inputs") %>% checkPath(create = TRUE)
> tmpFile <- file.path(tmpdir, "test.rds")
> saveRDS(test, file = tmpFile)
> inputs(sim) <- data.frame(file = tmpFile) # using only required column, "file"
> inputs(sim) # see that it is not yet loaded, but when it is scheduled to be loaded
                             file     fun package objectName loadTime loaded
1 /tmp/RtmpZtWrEW/inputs/test.rds readRDS    base       test        0     NA
  arguments intervals
1        NA        NA
> simOut <- spades(sim)
test read from /tmp/RtmpZtWrEW/inputs/test.rds using readRDS
> inputs(simOut) # confirm it was loaded
                             file     fun package objectName loadTime loaded
1 /tmp/RtmpZtWrEW/inputs/test.rds readRDS    base       test        0   TRUE
  arguments intervals
1        NA        NA
> simOut$test
 [1]  1  2  3  4  5  6  7  8  9 10
> 
> # can put data.frame for inputs directly inside simInit call
> allTifs <- dir(system.file("maps", package = "quickPlot"),
+                full.names = TRUE, pattern = "tif")
> 
> # next: .objectNames are taken from the filenames (without the extension)
> # This will load all 5 tifs in the SpaDES sample directory, using
> #   the raster fuction in the raster package, all at time = 0
> if (require("rgdal", quietly = TRUE)) {
+   sim <- simInit(
+     inputs = data.frame(
+       files = allTifs,
+       functions = "raster",
+       package = "raster",
+       loadTime = 0,
+       stringsAsFactors = FALSE)
+     )
+ 
+   ##############################
+   #A fully described inputs object, including arguments:
+   files <- dir(system.file("maps", package = "quickPlot"),
+                full.names = TRUE, pattern = "tif")
+   # arguments must be a list of lists. This may require I() to keep it as a list
+   #   once it gets coerced into the data.frame.
+   arguments = I(rep(list(native = TRUE), length(files)))
+   filelist = data.frame(
+      objectName = paste0("Maps", 1:5),
+      files = files,
+      functions = "raster::raster",
+      arguments = arguments,
+      loadTime = 0,
+      intervals = c(rep(NA, length(files) - 1), 10)
+   )
+   inputs(sim) <- filelist
+   spades(sim)
+ }
rgdal: version: 1.2-16, (SVN revision 701)
 Geospatial Data Abstraction Library extensions to R successfully loaded
 Loaded GDAL runtime: GDAL 2.1.2, released 2016/10/24
 Path to GDAL shared files: /usr/share/gdal/2.1
 GDAL binary built with GEOS: TRUE 
 Loaded PROJ.4 runtime: Rel. 4.9.3, 15 August 2016, [PJ_VERSION: 493]
 Path to PROJ.4 shared files: (autodetected)
 Linking to sp version: 1.2-5 
DEM read from /home/tomas/cran/rcnst/lib/quickPlot/maps/DEM.tif using raster(inMemory=FALSE)
forestAge read from /home/tomas/cran/rcnst/lib/quickPlot/maps/forestAge.tif using raster(inMemory=FALSE)
forestCover read from /home/tomas/cran/rcnst/lib/quickPlot/maps/forestCover.tif using raster(inMemory=FALSE)
habitatQuality read from /home/tomas/cran/rcnst/lib/quickPlot/maps/habitatQuality.tif using raster(inMemory=FALSE)
percentPine read from /home/tomas/cran/rcnst/lib/quickPlot/maps/percentPine.tif using raster(inMemory=FALSE)
Maps1 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/DEM.tif using raster(inMemory=FALSE)
Maps2 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/forestAge.tif using raster(inMemory=FALSE)
Maps3 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/forestCover.tif using raster(inMemory=FALSE)
Maps4 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/habitatQuality.tif using raster(inMemory=FALSE)
Maps5 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/percentPine.tif using raster(inMemory=FALSE)
Maps5 read from /home/tomas/cran/rcnst/lib/quickPlot/maps/percentPine.tif using raster(inMemory=FALSE)
  at time 10
> 
> 
> # Clean up after
> unlink(tmpdir, recursive = TRUE)
> 
> #######################
> # outputs
> #######################
> 
> library(igraph) # for %>%
> tmpdir <- file.path(tempdir(), "outputs") %>% checkPath(create = TRUE)
> tmpFile <- file.path(tmpdir, "temp.rds")
> tempObj <- 1:10
> 
> # Can add data.frame of outputs directly into simInit call
> sim <- simInit(objects = c("tempObj"),
+                outputs = data.frame(objectName = "tempObj"),
+                paths = list(outputPath = tmpdir))
> outputs(sim) # To see what will be saved, when, what filename
  objectName                                         file     fun package
1    tempObj /tmp/RtmpZtWrEW/outputs/tempObj_second10.rds saveRDS    base
  saveTime saved arguments
1       10    NA        NA
> sim <- spades(sim)
> outputs(sim) # To see that it was saved, when, what filename
  objectName                                         file     fun package
1    tempObj /tmp/RtmpZtWrEW/outputs/tempObj_second10.rds saveRDS    base
  saveTime saved arguments
1       10  TRUE        NA
> 
> # Also can add using assignment after a simList object has been made
> sim <- simInit(objects = c("tempObj"), paths = list(outputPath = tmpdir))
> outputs(sim) <- data.frame(objectName = "tempObj", saveTime = 1:10)
> sim <- spades(sim)
> outputs(sim) # To see that it was saved, when, what filename.
   objectName saveTime                                         file     fun
1     tempObj        1 /tmp/RtmpZtWrEW/outputs/tempObj_second01.rds saveRDS
2     tempObj        2 /tmp/RtmpZtWrEW/outputs/tempObj_second02.rds saveRDS
3     tempObj        3 /tmp/RtmpZtWrEW/outputs/tempObj_second03.rds saveRDS
4     tempObj        4 /tmp/RtmpZtWrEW/outputs/tempObj_second04.rds saveRDS
5     tempObj        5 /tmp/RtmpZtWrEW/outputs/tempObj_second05.rds saveRDS
6     tempObj        6 /tmp/RtmpZtWrEW/outputs/tempObj_second06.rds saveRDS
7     tempObj        7 /tmp/RtmpZtWrEW/outputs/tempObj_second07.rds saveRDS
8     tempObj        8 /tmp/RtmpZtWrEW/outputs/tempObj_second08.rds saveRDS
9     tempObj        9 /tmp/RtmpZtWrEW/outputs/tempObj_second09.rds saveRDS
10    tempObj       10 /tmp/RtmpZtWrEW/outputs/tempObj_second10.rds saveRDS
   package saved arguments
1     base  TRUE        NA
2     base  TRUE        NA
3     base  TRUE        NA
4     base  TRUE        NA
5     base  TRUE        NA
6     base  TRUE        NA
7     base  TRUE        NA
8     base  TRUE        NA
9     base  TRUE        NA
10    base  TRUE        NA
> 
> # can do highly variable saving
> tempObj2 <- paste("val",1:10)
> df1 <- data.frame(col1 = tempObj, col2 = tempObj2)
> sim <- simInit(objects = c("tempObj", "tempObj2", "df1"),
+   paths=list(outputPath = tmpdir))
> outputs(sim) = data.frame(
+      objectName = c(rep("tempObj", 2), rep("tempObj2", 3), "df1"),
+      saveTime = c(c(1,4), c(2,6,7), end(sim)),
+      fun = c(rep("saveRDS", 5), "write.csv"),
+      package = c(rep("base", 5), "utils"),
+      stringsAsFactors = FALSE)
> # since write.csv has a default of adding a column, x, with rownames, must add additional
> #   argument for 6th row in data.frame (corresponding to the write.csv function)
> outputArgs(sim)[[6]] <- list(row.names=FALSE)
> sim <- spades(sim)
> outputs(sim)
  objectName saveTime       fun package
1    tempObj        1   saveRDS    base
2    tempObj        4   saveRDS    base
3   tempObj2        2   saveRDS    base
4   tempObj2        6   saveRDS    base
5   tempObj2        7   saveRDS    base
6        df1       10 write.csv   utils
                                           file saved arguments
1  /tmp/RtmpZtWrEW/outputs/tempObj_second01.rds  TRUE        NA
2  /tmp/RtmpZtWrEW/outputs/tempObj_second04.rds  TRUE        NA
3 /tmp/RtmpZtWrEW/outputs/tempObj2_second02.rds  TRUE        NA
4 /tmp/RtmpZtWrEW/outputs/tempObj2_second06.rds  TRUE        NA
5 /tmp/RtmpZtWrEW/outputs/tempObj2_second07.rds  TRUE        NA
6      /tmp/RtmpZtWrEW/outputs/df1_second10.csv  TRUE     FALSE
> 
> # read one back in just to test it all worked as planned
> newObj <- read.csv(dir(tmpdir, pattern = "second10.csv", full.name = TRUE))
> newObj
   col1   col2
1     1  val 1
2     2  val 2
3     3  val 3
4     4  val 4
5     5  val 5
6     6  val 6
7     7  val 7
8     8  val 8
9     9  val 9
10   10 val 10
> 
> # using saving with SpaDES-aware methods
> # To see current ones SpaDES can do
> .saveFileExtensions()
  exts         fun package
1  rds     saveRDS    base
4  grd writeRaster  raster
3  csv   write.csv   utils
2  txt write.table   utils
> 
> library(raster)
> if (require(rgdal)) {
+   ras <- raster(ncol = 4, nrow = 5)
+   ras[] <- 1:20
+ 
+   sim <- simInit(objects = c("ras"), paths = list(outputPath = tmpdir))
+   outputs(sim) = data.frame(
+     file = "test",
+     fun = "writeRaster",
+     package = "raster",
+     objectName = "ras",
+     stringsAsFactors = FALSE)
+ 
+   outputArgs(sim)[[1]] <- list(format = "GTiff") # see ?raster::writeFormats
+   simOut <- spades(sim)
+   outputs(simOut)
+   newRas <- raster(dir(tmpdir, full.name = TRUE, pattern = ".tif"))
+   all.equal(newRas, ras) # Should be TRUE
+ }
[1] TRUE
> # Clean up after
> unlink(tmpdir, recursive = TRUE)
> 
> 
> 
> cleanEx()

detaching ‘package:raster’, ‘package:rgdal’, ‘package:sp’,
  ‘package:igraph’

> nameEx("spades")
> ### * spades
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: spades
> ### Title: setMethod( "scheduleEvent", signature( sim = "simList",
> ###   eventTime = "NULL", moduleName = "character", eventType =
> ###   "character", eventPriority = "numeric" ), definition = function(sim,
> ###   eventTime, moduleName, eventType, eventPriority) warning( paste(
> ###   "Invalid or missing eventTime. This is usually", "caused by an
> ###   attempt to scheduleEvent at time NULL", "or by using an undefined
> ###   parameter."  ) ) return(invisible(sim)) )
> ### Aliases: spades spades,simList,ANY,ANY,missing-method
> ###   spades,ANY,ANY,ANY,logical-method
> 
> ### ** Examples
> 
> ## Not run: 
> ##D mySim <- simInit(
> ##D  times = list(start = 0.0, end = 2.0, timeunit = "year"),
> ##D  params = list(
> ##D    .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
> ##D  ),
> ##D  modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D  paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
> ##D )
> ##D spades(mySim)
> ##D 
> ##D # Different debug options
> ##D spades(mySim, debug = TRUE) # Fastest
> ##D spades(mySim, debug = "simList")
> ##D spades(mySim, debug = "print(table(sim$landscape$Fires[]))")
> ##D 
> ##D # Can turn off plotting, and inspect the output simList instead
> ##D out <- spades(mySim, .plotInitialTime = NA) # much faster
> ##D completed(out) # shows completed events
> ##D 
> ##D # use cache -- simInit should generally be rerun each time a spades call is made
> ##D #   to guarantee that it is identical. Here, run spades call twice, first
> ##D #   time to establish cache, second time to return cached result
> ##D for (i in 1:2) {
> ##D  mySim <- simInit(
> ##D    times = list(start = 0.0, end = 2.0, timeunit = "year"),
> ##D    params = list(
> ##D      .globals = list(stackName = "landscape", burnStats = "nPixelsBurned")
> ##D    ),
> ##D    modules = list("randomLandscapes", "fireSpread", "caribouMovement"),
> ##D    paths = list(modulePath = system.file("sampleModules", package = "SpaDES.core"))
> ##D  )
> ##D  print(system.time(out <- spades(mySim, cache = TRUE)))
> ##D }
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("updateList")
> ### * updateList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: updateList
> ### Title: Update elements of a named list with elements of a second named
> ###   list
> ### Aliases: updateList updateList,list,list-method
> ###   updateList,NULL,list-method updateList,list,NULL-method
> ###   updateList,NULL,NULL-method
> 
> ### ** Examples
> 
> L1 <- list(a = "hst", b = NA_character_, c = 43)
> L2 <- list(a = "gst", c = 42, d = list(letters))
> updateList(L1, L2)
$a
[1] "gst"

$b
[1] NA

$c
[1] 42

$d
$d[[1]]
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"


> 
> updateList(L1, NULL)
$a
[1] "hst"

$b
[1] NA

$c
[1] 43

> updateList(NULL, L2)
$a
[1] "gst"

$c
[1] 42

$d
$d[[1]]
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"


> updateList(NULL, NULL) # should return empty list
list()
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  32.492 2.632 34.188 0 0.036 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
