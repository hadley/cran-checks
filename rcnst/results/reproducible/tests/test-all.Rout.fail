
R Under development (unstable) (2020-02-13 r77801) -- "Unsuffered Consequences"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(testthat)
> test_check("reproducible")
Loading required package: reproducible
ERROR: modification of compiler constant of type character, length 1
ERROR: the modified value of the constant is:
[1] "NULL"
attr(,".Cache")
attr(,".Cache")$newCache
[1] TRUE

attr(,"tags")
[1] "cacheId:6fb496697e14a2c7"
attr(,"call")
[1] ""
ERROR: the original value of the constant is:
[1] "NULL"
ERROR: the modified constant is at index 563
ERROR: the modified constant is in this function body:
{
    if (!is.null(list(...)$objects)) {
        message("Please use .objects (if trying to pass to Cache) instead of objects which is being deprecated")
    }
    if (missing(FUN)) 
        stop("Cache requires the FUN argument")
    fnDetails <- .fnCleanup(FUN = FUN, callingFun = "Cache", 
        ...)
    FUN <- fnDetails$FUN
    modifiedDots <- fnDetails$modifiedDots
    originalDots <- fnDetails$originalDots
    if (isFALSE(useCache) || isTRUE(0 == useCache)) {
        message(crayon::green("useCache is FALSE, skipping Cache.", 
            "To turn Caching on, use options(reproducible.useCache = TRUE)"))
        if (fnDetails$isDoCall) {
            do.call(modifiedDots$what, args = modifiedDots$args)
        }
        else {
            do.call(FUN, args = modifiedDots)
        }
    }
    else {
        startCacheTime <- verboseTime(verbose)
        if (!missing(compareRasterFileLength)) {
            message("compareRasterFileLength argument being deprecated. Use 'length'")
            length <- compareRasterFileLength
        }
        if (!missing(digestPathContent)) {
            message("digestPathContent argument being deprecated. Use 'quick'.")
            quick <- !digestPathContent
        }
        nestedTags <- determineNestedTags(envir = environment(), 
            mc = match.call(expand.dots = TRUE), userTags = userTags)
        userTags <- unique(c(userTags, .reproEnv$userTags))
        if (any(!nestedTags$objOverride)) {
            on.exit({
                if (any(!nestedTags$prevVals)) {
                  suppressWarnings(rm(list = nestedTags$namesUserCacheArgs, 
                    envir = .reproEnv))
                  if (nestedTags$prevUserTags) .reproEnv$userTags <- nestedTags$oldUserTags
                }
                if (nestedTags$prevUserTags) {
                  .reproEnv$userTags <- nestedTags$oldUserTags
                }
            }, add = TRUE)
        }
        cacheRepos <- getCacheRepos(cacheRepo, modifiedDots)
        cacheRepo <- cacheRepos[[1]]
        if (fnDetails$isPipe) {
            pipeRes <- .CachePipeFn1(modifiedDots, fnDetails, 
                FUN)
            modifiedDots <- pipeRes$modifiedDots
            fnDetails <- pipeRes$fnDetails
        }
        modifiedDots$.FUN <- fnDetails$.FUN
        scalls <- if (!is(FUN, "function")) 
            .CacheFn1(FUN, sys.calls())
        else NULL
        otherFns <- .getOtherFnNamesAndTags(scalls = scalls)
        if (missing(notOlderThan)) 
            notOlderThan <- NULL
        userTags <- c(userTags, unlist(lapply(modifiedDots, .tagsByClass)))
        if (sideEffect != FALSE) 
            if (isTRUE(sideEffect)) 
                sideEffect <- cacheRepo
        isIntactRepo <- unlist(lapply(cacheRepos, function(cacheRepo) {
            all(file.exists(file.path(cacheRepo, c("gallery", 
                "backpack.db"))))
        }))
        if (any(!isIntactRepo)) 
            ret <- lapply(seq(cacheRepos)[!isIntactRepo], function(cacheRepoInd) {
                archivist::createLocalRepo(cacheRepos[[cacheRepoInd]], 
                  force = isIntactRepo[cacheRepoInd])
            })
        if (sideEffect != FALSE) {
            priorRepo <- list.files(sideEffect, full.names = TRUE)
        }
        if (!is.null(modifiedDots$progress)) 
            if (!is.na(modifiedDots$progress)) 
                modifiedDots$progress <- NULL
        if (!is.null(omitArgs)) {
            modifiedDots[omitArgs] <- NULL
        }
        dotPipe <- startsWith(names(modifiedDots), "._")
        preDigestByClass <- lapply(seq_along(modifiedDots[!dotPipe]), 
            function(x) {
                .preDigestByClass(modifiedDots[!dotPipe][[x]])
            })
        startHashTime <- verboseTime(verbose)
        argsToOmitForDigest <- dotPipe | (names(modifiedDots) %in% 
            .defaultCacheOmitArgs)
        cacheDigest <- CacheDigest(modifiedDots[!argsToOmitForDigest], 
            .objects = .objects, length = length, algo = algo, 
            quick = quick, classOptions = classOptions)
        preDigest <- cacheDigest$preDigest
        outputHash <- cacheDigest$outputHash
        preDigestUnlistTrunc <- unlist(.unlistToCharacter(preDigest, 
            getOption("reproducible.showSimilarDepth", 3)))
        if (verbose > 1) {
            a <- .CacheVerboseFn1(preDigest, fnDetails, startHashTime, 
                modifiedDots, dotPipe, quick = quick)
            on.exit({
                assign("cacheTimings", .reproEnv$verboseTiming, 
                  envir = .reproEnv)
                print(.reproEnv$verboseTiming)
                message("This object is also available from .reproEnv$cacheTimings")
                if (exists("verboseTiming", envir = .reproEnv)) rm("verboseTiming", 
                  envir = .reproEnv)
            }, add = TRUE)
        }
        if (length(debugCache)) {
            if (!is.na(pmatch(debugCache, "quick"))) 
                return(list(hash = preDigest, content = list(...)))
        }
        if (!is.null(cacheId)) {
            outputHashManual <- cacheId
            if (identical(outputHashManual, outputHash)) {
                message("cacheId is same as calculated hash")
            }
            else {
                message("cacheId is not same as calculated hash. Manually searching for cacheId:", 
                  cacheId)
            }
            outputHash <- outputHashManual
        }
        tries <- 1
        if (useCloud) {
            cloudFolderID <- checkAndMakeCloudFolderID(cloudFolderID)
            message("Retrieving file list in cloud folder")
            gdriveLs <- retry(drive_ls(path = as_id(cloudFolderID), 
                pattern = outputHash))
        }
        while (tries <= length(cacheRepos)) {
            repo <- cacheRepos[[tries]]
            tries <- tries + 1
            localTags <- getLocalTags(repo)
            isInRepo <- localTags[localTags$tag == paste0("cacheId:", 
                outputHash), , drop = FALSE]
            if (NROW(isInRepo) > 1) 
                isInRepo <- isInRepo[NROW(isInRepo), ]
            if (NROW(isInRepo) > 0) {
                cacheRepo <- repo
                break
            }
        }
        userTags <- c(userTags, if (!is.na(fnDetails$functionName)) paste0("function:", 
            fnDetails$functionName))
        outputHashNew <- outputHash
        needFindByTags <- identical("devMode", useCache) && NROW(isInRepo) == 
            0
        if (identical("devMode", useCache) && NROW(isInRepo) == 
            0) {
            devModeOut <- devModeFn1(localTags, userTags, scalls, 
                preDigestUnlistTrunc, useCache, verbose, isInRepo, 
                outputHash)
            outputHash <- devModeOut$outputHash
            isInRepo <- devModeOut$isInRepo
            needFindByTags <- devModeOut$needFindByTags
        }
        if (identical("overwrite", useCache) && NROW(isInRepo) > 
            0 || needFindByTags) {
            suppressMessages(clearCache(x = cacheRepo, userTags = outputHash, 
                ask = FALSE))
            if (identical("devMode", useCache)) {
                isInRepo <- isInRepo[!isInRepo$tag %in% userTags, 
                  , drop = FALSE]
                outputHash <- outputHashNew
                message("Overwriting Cache entry with userTags: '", 
                  paste(userTags, collapse = ", "), "'")
            }
            else {
                isInRepo <- isInRepo[isInRepo$tag != paste0("cacheId:", 
                  outputHash), , drop = FALSE]
                message("Overwriting Cache entry with function '", 
                  fnDetails$functionName, "'")
            }
        }
        if (NROW(isInRepo) > 0) {
            lastEntry <- max(isInRepo$createdDate)
            lastOne <- order(isInRepo$createdDate, decreasing = TRUE)[1]
            if (is.null(notOlderThan) || (notOlderThan < lastEntry)) {
                objSize <- file.size(file.path(cacheRepo, "gallery", 
                  paste0(isInRepo$artifact, ".rda")))
                class(objSize) <- "object_size"
                if (objSize > 1e+06) 
                  message(crayon::blue(paste0("  ...(Object to retrieve is large: ", 
                    format(objSize, units = "auto"), ")")))
                output <- try(.getFromRepo(FUN, isInRepo = isInRepo, 
                  notOlderThan = notOlderThan, lastOne = lastOne, 
                  cacheRepo = cacheRepo, fnDetails = fnDetails, 
                  modifiedDots = modifiedDots, debugCache = debugCache, 
                  verbose = verbose, sideEffect = sideEffect, 
                  quick = quick, algo = algo, preDigest = preDigest, 
                  startCacheTime = startCacheTime, ...))
                if (is(output, "try-error")) {
                  cID <- gsub("cacheId:", "", isInRepo$tag)
                  stop("Error in trying to recover cacheID: ", 
                    cID, "\nYou will likely need to remove that item from Cache, e.g., ", 
                    "\nclearCache(userTags = '", cID, "')")
                }
                if (useCloud) {
                  isInCloud <- cloudUpload(isInRepo, outputHash, 
                    gdriveLs, cacheRepo, cloudFolderID, output)
                }
                return(output)
            }
        }
        else {
            if (!is.null(showSimilar)) {
                if (!isFALSE(showSimilar)) {
                  .findSimilar(localTags, showSimilar, scalls, 
                    preDigestUnlistTrunc, userTags, useCache = useCache)
                }
            }
        }
        startRunTime <- verboseTime(verbose)
        .CacheIsNew <- TRUE
        if (useCloud) {
            newFileName <- paste0(outputHash, ".rda")
            isInCloud <- gsub(gdriveLs$name, pattern = "\\.rda", 
                replacement = "") %in% outputHash
            if (any(isInCloud)) {
                output <- cloudDownload(outputHash, newFileName, 
                  gdriveLs, cacheRepo, cloudFolderID)
                if (is.null(output)) {
                  retry(drive_rm(as_id(gdriveLs$id[isInCloud])))
                  isInCloud[isInCloud] <- FALSE
                }
                else {
                  .CacheIsNew <- FALSE
                }
            }
        }
        if (!exists("output", inherits = FALSE) || is.null(output)) {
            if (fnDetails$isPipe) {
                output <- eval(modifiedDots$._pipe, envir = modifiedDots$._envir)
            }
            else {
                output <- FUN(...)
            }
        }
        output <- .addChangedAttr(output, preDigest, origArguments = modifiedDots[!dotPipe], 
            .objects = outputObjects, length = length, algo = algo, 
            quick = quick, classOptions = classOptions, ...)
        verboseDF1(verbose, fnDetails$functionName, startRunTime)
        if (nrow(isInRepo) > 0) {
            if (notOlderThan >= lastEntry) {
                suppressMessages(clearCache(userTags = isInRepo$artifact[lastOne], 
                  x = cacheRepo, ask = FALSE))
            }
        }
        isNullOutput <- if (is.null(output)) 
            TRUE
        else FALSE
        if (isNullOutput) 
            output <- "NULL"
        .setSubAttrInList(output, ".Cache", "newCache", .CacheIsNew)
        setattr(output, "tags", paste0("cacheId:", outputHash))
        setattr(output, "call", "")
        if (!identical(attr(output, ".Cache")$newCache, .CacheIsNew)) 
            stop("attributes are not correct 3")
        if (!identical(attr(output, "call"), "")) 
            stop("attributes are not correct 4")
        if (!identical(attr(output, "tags"), paste0("cacheId:", 
            outputHash))) 
            stop("attributes are not correct 5")
        if (sideEffect != FALSE) {
            output <- .CacheSideEffectFn2(sideEffect, cacheRepo, 
                priorRepo, algo, output, makeCopy, quick)
        }
        if (isS4(FUN)) {
            setattr(output, "function", FUN@generic)
            if (!identical(attr(output, "function"), FUN@generic)) 
                stop("There is an unknown error 03")
        }
        outputToSave <- .addTagsToOutput(output, outputObjects, 
            FUN, preDigestByClass)
        alreadyIn <- gsub(otherFns, pattern = "otherFunctions:", 
            replacement = "") %in% as.character(attr(output, 
            "function"))
        if (isTRUE(any(alreadyIn))) 
            otherFns <- otherFns[!alreadyIn]
        outputToSaveIsList <- is(outputToSave, "list")
        if (outputToSaveIsList) {
            rasters <- unlist(lapply(outputToSave, is, "Raster"))
        }
        else {
            rasters <- is(outputToSave, "Raster")
        }
        if (any(rasters)) {
            if (outputToSaveIsList) {
                outputToSave[rasters] <- lapply(outputToSave[rasters], 
                  function(x) .prepareFileBackedRaster(x, repoDir = cacheRepo, 
                    overwrite = FALSE))
            }
            else {
                outputToSave <- .prepareFileBackedRaster(outputToSave, 
                  repoDir = cacheRepo, overwrite = FALSE)
            }
            setattr(outputToSave, "tags", attr(output, "tags"))
            .setSubAttrInList(outputToSave, ".Cache", "newCache", 
                attr(output, ".Cache")$newCache)
            setattr(outputToSave, "call", attr(output, "call"))
            if (!identical(attr(outputToSave, ".Cache")$newCache, 
                attr(output, ".Cache")$newCache)) 
                stop("attributes are not correct 6")
            if (!identical(attr(outputToSave, "call"), attr(output, 
                "call"))) 
                stop("attributes are not correct 7")
            if (!identical(attr(outputToSave, "tags"), attr(output, 
                "tags"))) 
                stop("attributes are not correct 8")
            if (isS4(FUN)) {
                setattr(outputToSave, "function", attr(output, 
                  "function"))
                if (!identical(attr(outputToSave, "function"), 
                  attr(output, "function"))) 
                  stop("There is an unknown error 04")
            }
            output <- outputToSave
        }
        if (length(debugCache)) {
            if (!is.na(pmatch(debugCache, "complete"))) {
                output <- .debugCache(output, preDigest, ...)
                outputToSave <- .debugCache(outputToSave, preDigest, 
                  ...)
            }
        }
        startSaveTime <- verboseTime(verbose)
        objSize <- .objSizeInclEnviros(outputToSave)
        userTags <- c(userTags, paste0("object.size:", objSize), 
            paste0("accessed:", Sys.time()), paste0(otherFns), 
            paste("preDigest", names(preDigestUnlistTrunc), preDigestUnlistTrunc, 
                sep = ":"))
        written <- 0
        useFuture <- FALSE
        .onLinux <- .Platform$OS.type == "unix" && unname(Sys.info()["sysname"]) == 
            "Linux"
        if (.onLinux) {
            if (!isFALSE(getOption("reproducible.futurePlan")) && 
                requireNamespace("future", quietly = TRUE)) {
                useFuture <- TRUE
            }
        }
        if (useFuture) {
            if (exists("futureEnv", envir = .reproEnv)) 
                .reproEnv$futureEnv <- new.env()
            if (isTRUE(getOption("reproducible.futurePlan"))) {
                message("options(\"reproducible.futurePlan\") is TRUE. Setting it to \"multiprocess\"\n", 
                  "Please specify a plan by name, e.g., options(\"reproducible.futurePlan\" = \"multiprocess\")")
                future::plan("multiprocess")
            }
            else {
                if (!is(future::plan(), getOption("reproducible.futurePlan"))) {
                  thePlan <- getOption("reproducible.futurePlan")
                  future::plan(thePlan)
                }
            }
            .reproEnv$futureEnv[[paste0("future_", rndstr(1, 
                10))]] <- future::futureCall(FUN = writeFuture, 
                args = list(written, outputToSave, cacheRepo, 
                  userTags), globals = list(written = written, 
                  saveToLocalRepo = archivist::saveToLocalRepo, 
                  outputToSave = outputToSave, cacheRepo = cacheRepo, 
                  userTags = userTags))
            if (is.null(.reproEnv$alreadyMsgFuture)) {
                message("  Cache saved in a separate 'future' process. ", 
                  "Set options('reproducible.futurePlan' = FALSE), if there is strange behaviour.", 
                  "This message will not be shown again until next reload of reproducible")
                .reproEnv$alreadyMsgFuture <- TRUE
            }
        }
        else {
            while (written >= 0) {
                otsObjSize <- gsub(grep("object.size", userTags, 
                  value = TRUE), pattern = "object.size:", replacement = "")
                otsObjSize <- as.numeric(otsObjSize)
                class(otsObjSize) <- "object_size"
                if (otsObjSize > 1e+07) 
                  message("Saving large object to Cache: ", format(otsObjSize, 
                    units = "auto"))
                saved <- suppressWarnings(try(silent = TRUE, 
                  saveToLocalRepo(outputToSave, repoDir = cacheRepo, 
                    artifactName = NULL, archiveData = FALSE, 
                    archiveSessionInfo = FALSE, archiveMiniature = FALSE, 
                    rememberName = FALSE, silent = TRUE, userTags = userTags)))
                written <- if (is(saved, "try-error")) {
                  Sys.sleep(sum(runif(written + 1, 0.05, 0.1)))
                  written + 1
                }
                else {
                  -1
                }
            }
        }
        if (useCloud) {
            cloudUploadFromCache(isInCloud, outputHash, saved, 
                cacheRepo, cloudFolderID, outputToSave, rasters)
        }
        verboseDF2(verbose, fnDetails$functionName, startSaveTime)
        verboseDF3(verbose, fnDetails$functionName, startCacheTime)
        if (isNullOutput) 
            return(NULL)
        else return(output)
    }
}
S4 Method Cache:reproducible defined in namespace reproducible with signature ANY has this body.
Fatal error: compiler constants were modified!

