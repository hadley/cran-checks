
R Under development (unstable) (2021-02-17 r80023) -- "Unsuffered Consequences"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "tsibble"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('tsibble')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("as-tibble")
> ### * as-tibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_tibble.tbl_ts
> ### Title: Coerce to a tibble or data frame
> ### Aliases: as_tibble.tbl_ts
> 
> ### ** Examples
> 
> as_tibble(pedestrian)
# A tibble: 66,037 x 5
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 66,027 more rows
> 
> 
> 
> cleanEx()
> nameEx("as-tsibble")
> ### * as-tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as_tsibble
> ### Title: Coerce to a tsibble object
> ### Aliases: as_tsibble as_tsibble.ts as_tsibble.mts
> 
> ### ** Examples
> 
> # coerce tibble to tsibble w/o a key
> tbl1 <- tibble(
+   date = as.Date("2017-01-01") + 0:9,
+   value = rnorm(10)
+ )
> as_tsibble(tbl1)
Using `date` as index variable.
# A tsibble: 10 x 2 [1D]
   date        value
   <date>      <dbl>
 1 2017-01-01 -0.626
 2 2017-01-02  0.184
 3 2017-01-03 -0.836
 4 2017-01-04  1.60 
 5 2017-01-05  0.330
 6 2017-01-06 -0.820
 7 2017-01-07  0.487
 8 2017-01-08  0.738
 9 2017-01-09  0.576
10 2017-01-10 -0.305
> # supply the index to suppress the message
> as_tsibble(tbl1, index = date)
# A tsibble: 10 x 2 [1D]
   date        value
   <date>      <dbl>
 1 2017-01-01 -0.626
 2 2017-01-02  0.184
 3 2017-01-03 -0.836
 4 2017-01-04  1.60 
 5 2017-01-05  0.330
 6 2017-01-06 -0.820
 7 2017-01-07  0.487
 8 2017-01-08  0.738
 9 2017-01-09  0.576
10 2017-01-10 -0.305
> 
> # coerce tibble to tsibble with a single variable for key
> # use `yearquarter()` to represent quarterly data
> tbl2 <- tibble(
+   qtr = rep(yearquarter("2010 Q1") + 0:9, 3),
+   group = rep(c("x", "y", "z"), each = 10),
+   value = rnorm(30)
+ )
> # "qtr" is automatically considered as the index var
> as_tsibble(tbl2, key = group)
Using `qtr` as index variable.
# A tsibble: 30 x 3 [1Q]
# Key:       group [3]
       qtr group   value
     <qtr> <chr>   <dbl>
 1 2010 Q1 x      1.51  
 2 2010 Q2 x      0.390 
 3 2010 Q3 x     -0.621 
 4 2010 Q4 x     -2.21  
 5 2011 Q1 x      1.12  
 6 2011 Q2 x     -0.0449
 7 2011 Q3 x     -0.0162
 8 2011 Q4 x      0.944 
 9 2012 Q1 x      0.821 
10 2012 Q2 x      0.594 
# … with 20 more rows
> as_tsibble(tbl2, key = group, index = qtr)
# A tsibble: 30 x 3 [1Q]
# Key:       group [3]
       qtr group   value
     <qtr> <chr>   <dbl>
 1 2010 Q1 x      1.51  
 2 2010 Q2 x      0.390 
 3 2010 Q3 x     -0.621 
 4 2010 Q4 x     -2.21  
 5 2011 Q1 x      1.12  
 6 2011 Q2 x     -0.0449
 7 2011 Q3 x     -0.0162
 8 2011 Q4 x      0.944 
 9 2012 Q1 x      0.821 
10 2012 Q2 x      0.594 
# … with 20 more rows
> 
> # create a tsibble with multiple variables for key
> # use `yearmonth()` to represent monthly data
> tbl3 <- tibble(
+   mth = rep(yearmonth("2010 Jan") + 0:8, each = 3),
+   xyz = rep(c("x", "y", "z"), each = 9),
+   abc = rep(letters[1:3], times = 9),
+   value = rnorm(27)
+ )
> as_tsibble(tbl3, key = c(xyz, abc))
Using `mth` as index variable.
# A tsibble: 27 x 4 [1M]
# Key:       xyz, abc [9]
        mth xyz   abc    value
      <mth> <chr> <chr>  <dbl>
 1 2010 Jan x     a     -0.165
 2 2010 Feb x     a      0.557
 3 2010 Mar x     a      0.365
 4 2010 Jan x     b     -0.253
 5 2010 Feb x     b     -0.689
 6 2010 Mar x     b      0.769
 7 2010 Jan x     c      0.697
 8 2010 Feb x     c     -0.707
 9 2010 Mar x     c     -0.112
10 2010 Apr y     a      0.881
# … with 17 more rows
> # coerce ts to tsibble
> as_tsibble(AirPassengers)
# A tsibble: 144 x 2 [1M]
      index value
      <mth> <dbl>
 1 1949 Jan   112
 2 1949 Feb   118
 3 1949 Mar   132
 4 1949 Apr   129
 5 1949 May   121
 6 1949 Jun   135
 7 1949 Jul   148
 8 1949 Aug   148
 9 1949 Sep   136
10 1949 Oct   119
# … with 134 more rows
> as_tsibble(sunspot.year)
# A tsibble: 289 x 2 [1Y]
   index value
   <dbl> <dbl>
 1  1700     5
 2  1701    11
 3  1702    16
 4  1703    23
 5  1704    36
 6  1705    58
 7  1706    29
 8  1707    20
 9  1708    10
10  1709     8
# … with 279 more rows
> as_tsibble(sunspot.month)
# A tsibble: 3,177 x 2 [1M]
      index value
      <mth> <dbl>
 1 1749 Jan  58  
 2 1749 Feb  62.6
 3 1749 Mar  70  
 4 1749 Apr  55.7
 5 1749 May  85  
 6 1749 Jun  83.5
 7 1749 Jul  94.8
 8 1749 Aug  66.3
 9 1749 Sep  75.9
10 1749 Oct  75.5
# … with 3,167 more rows
> as_tsibble(austres)
# A tsibble: 89 x 2 [1Q]
     index  value
     <qtr>  <dbl>
 1 1971 Q2 13067.
 2 1971 Q3 13130.
 3 1971 Q4 13198.
 4 1972 Q1 13254.
 5 1972 Q2 13304.
 6 1972 Q3 13354.
 7 1972 Q4 13409.
 8 1973 Q1 13459.
 9 1973 Q2 13504.
10 1973 Q3 13553.
# … with 79 more rows
> # coerce mts to tsibble
> z <- ts(matrix(rnorm(300), 100, 3), start = c(1961, 1), frequency = 12)
> as_tsibble(z)
# A tsibble: 300 x 3 [1M]
# Key:       key [3]
      index key       value
      <mth> <chr>     <dbl>
 1 1961 Jan Series 1  1.47 
 2 1961 Feb Series 1  0.153
 3 1961 Mar Series 1  2.17 
 4 1961 Apr Series 1  0.476
 5 1961 May Series 1 -0.710
 6 1961 Jun Series 1  0.611
 7 1961 Jul Series 1 -0.934
 8 1961 Aug Series 1 -1.25 
 9 1961 Sep Series 1  0.291
10 1961 Oct Series 1 -0.443
# … with 290 more rows
> as_tsibble(z, pivot_longer = FALSE)
# A tsibble: 100 x 4 [1M]
      index `Series 1` `Series 2` `Series 3`
      <mth>      <dbl>      <dbl>      <dbl>
 1 1961 Jan      1.47     -1.42       -1.19 
 2 1961 Feb      0.153    -0.144      -0.331
 3 1961 Mar      2.17      0.208      -0.940
 4 1961 Apr      0.476     2.31       -0.259
 5 1961 May     -0.710     0.106       0.394
 6 1961 Jun      0.611     0.457      -0.852
 7 1961 Jul     -0.934    -0.0772      2.65 
 8 1961 Aug     -1.25     -0.334       0.156
 9 1961 Sep      0.291    -0.0347      1.13 
10 1961 Oct     -0.443     0.788      -2.29 
# … with 90 more rows
> 
> 
> 
> cleanEx()
> nameEx("as.ts.tbl_ts")
> ### * as.ts.tbl_ts
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: as.ts.tbl_ts
> ### Title: Coerce a tsibble to a time series
> ### Aliases: as.ts.tbl_ts
> 
> ### ** Examples
> 
> # a monthly series
> x1 <- as_tsibble(AirPassengers)
> as.ts(x1)
     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
1949 112 118 132 129 121 135 148 148 136 119 104 118
1950 115 126 141 135 125 149 170 170 158 133 114 140
1951 145 150 178 163 172 178 199 199 184 162 146 166
1952 171 180 193 181 183 218 230 242 209 191 172 194
1953 196 196 236 235 229 243 264 272 237 211 180 201
1954 204 188 235 227 234 264 302 293 259 229 203 229
1955 242 233 267 269 270 315 364 347 312 274 237 278
1956 284 277 317 313 318 374 413 405 355 306 271 306
1957 315 301 356 348 355 422 465 467 404 347 305 336
1958 340 318 362 348 363 435 491 505 404 359 310 337
1959 360 342 406 396 420 472 548 559 463 407 362 405
1960 417 391 419 461 472 535 622 606 508 461 390 432
> 
> 
> 
> cleanEx()
> nameEx("build_tsibble")
> ### * build_tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: build_tsibble
> ### Title: Low-level constructor for a tsibble object
> ### Aliases: build_tsibble
> 
> ### ** Examples
> 
> # Prepare `pedestrian` to use a new index `Date` ----
> pedestrian %>%
+   build_tsibble(
+     key = !!key_vars(.), index = !!index(.), index2 = Date,
+     interval = interval(.)
+   )
# A tsibble: 66,037 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
# Groups:    @ Date [731]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 66,027 more rows
> 
> 
> 
> cleanEx()
> nameEx("count_gaps")
> ### * count_gaps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count_gaps
> ### Title: Count implicit gaps
> ### Aliases: count_gaps
> 
> ### ** Examples
> 
> ped_gaps <- pedestrian %>%
+   count_gaps(.full = TRUE)
> ped_gaps
# A tibble: 19 x 4
   Sensor                        .from               .to                    .n
   <chr>                         <dttm>              <dttm>              <int>
 1 Birrarung Marr                2015-04-05 02:00:00 2015-04-05 02:00:00     1
 2 Birrarung Marr                2015-05-07 00:00:00 2015-05-31 23:00:00   600
 3 Birrarung Marr                2015-10-06 00:00:00 2015-10-31 23:00:00   624
 4 Birrarung Marr                2015-11-05 00:00:00 2015-11-06 23:00:00    48
 5 Birrarung Marr                2015-11-20 00:00:00 2015-11-24 23:00:00   120
 6 Birrarung Marr                2015-11-26 00:00:00 2015-12-04 23:00:00   216
 7 Birrarung Marr                2016-04-03 02:00:00 2016-04-03 02:00:00     1
 8 Birrarung Marr                2016-04-08 00:00:00 2016-05-03 23:00:00   624
 9 Birrarung Marr                2016-10-29 00:00:00 2016-11-28 23:00:00   744
10 Bourke Street Mall (North)    2015-01-01 00:00:00 2015-02-16 23:00:00  1128
11 Bourke Street Mall (North)    2015-04-05 02:00:00 2015-04-05 02:00:00     1
12 Bourke Street Mall (North)    2016-04-03 02:00:00 2016-04-03 02:00:00     1
13 QV Market-Elizabeth St (West) 2015-04-05 02:00:00 2015-04-05 02:00:00     1
14 QV Market-Elizabeth St (West) 2015-12-31 00:00:00 2015-12-31 23:00:00    24
15 QV Market-Elizabeth St (West) 2016-04-03 02:00:00 2016-04-03 02:00:00     1
16 Southern Cross Station        2015-04-05 02:00:00 2015-04-05 02:00:00     1
17 Southern Cross Station        2016-03-08 02:00:00 2016-03-08 02:00:00     1
18 Southern Cross Station        2016-03-29 02:00:00 2016-03-29 03:00:00     2
19 Southern Cross Station        2016-04-03 02:00:00 2016-04-03 02:00:00     1
> if (!requireNamespace("ggplot2", quietly = TRUE)) {
+   stop("Please install the ggplot2 package to run these following examples.")
+ }
> library(ggplot2)
> ggplot(ped_gaps, aes(x = Sensor, colour = Sensor)) +
+   geom_linerange(aes(ymin = .from, ymax = .to)) +
+   geom_point(aes(y = .from)) +
+   geom_point(aes(y = .to)) +
+   coord_flip() +
+   theme(legend.position = "bottom")
> 
> 
> 
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("difference")
> ### * difference
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: difference
> ### Title: Lagged differences
> ### Aliases: difference
> 
> ### ** Examples
> 
> # examples from base
> difference(1:10, 2)
 [1] NA NA  2  2  2  2  2  2  2  2
> difference(1:10, 2, 2)
 [1] NA NA NA NA  0  0  0  0  0  0
> x <- cumsum(cumsum(1:10))
> difference(x, lag = 2)
 [1]  NA  NA   9  16  25  36  49  64  81 100
> difference(x, differences = 2)
 [1] NA NA  3  4  5  6  7  8  9 10
> # Use order_by if data not already ordered (example from dplyr)
> library(dplyr, warn.conflicts = FALSE)
> tsbl <- tsibble(year = 2000:2005, value = (0:5)^2, index = year)
> scrambled <- tsbl %>% slice(sample(nrow(tsbl)))
Warning: Current temporal ordering may yield unexpected results.
ℹ Suggest to sort by ``, `year` first.
> 
> wrong <- mutate(scrambled, diff = difference(value))
Warning: Current temporal ordering may yield unexpected results.
ℹ Suggest to sort by ``, `year` first.
> arrange(wrong, year)
# A tsibble: 6 x 3 [1Y]
   year value  diff
  <int> <dbl> <dbl>
1  2000     0    NA
2  2001     1   -24
3  2002     4    -5
4  2003     9     9
5  2004    16    15
6  2005    25    21
> 
> right <- mutate(scrambled, diff = difference(value, order_by = year))
Warning: Current temporal ordering may yield unexpected results.
ℹ Suggest to sort by ``, `year` first.
> arrange(right, year)
# A tsibble: 6 x 3 [1Y]
   year value  diff
  <int> <dbl> <dbl>
1  2000     0    NA
2  2001     1     1
3  2002     4     3
4  2003     9     5
5  2004    16     7
6  2005    25     9
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("duplicates")
> ### * duplicates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_duplicated
> ### Title: Test duplicated observations determined by key and index
> ###   variables
> ### Aliases: is_duplicated are_duplicated duplicates
> 
> ### ** Examples
> 
> harvest <- tibble(
+   year = c(2010, 2011, 2013, 2011, 2012, 2014, 2014),
+   fruit = c(rep(c("kiwi", "cherry"), each = 3), "cherry"),
+   kilo = sample(1:10, size = 7)
+ )
> is_duplicated(harvest, key = fruit, index = year)
[1] TRUE
> are_duplicated(harvest, key = fruit, index = year)
[1] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE
> are_duplicated(harvest, key = fruit, index = year, from_last = TRUE)
[1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE
> duplicates(harvest, key = fruit, index = year)
# A tibble: 2 x 3
   year fruit   kilo
  <dbl> <chr>  <int>
1  2014 cherry     5
2  2014 cherry     3
> 
> 
> 
> cleanEx()
> nameEx("fill_gaps")
> ### * fill_gaps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fill_gaps
> ### Title: Turn implicit missing values into explicit missing values
> ### Aliases: fill_gaps
> 
> ### ** Examples
> 
> harvest <- tsibble(
+   year = c(2010, 2011, 2013, 2011, 2012, 2014),
+   fruit = rep(c("kiwi", "cherry"), each = 3),
+   kilo = sample(1:10, size = 6),
+   key = fruit, index = year
+ )
> 
> # gaps as default `NA`
> fill_gaps(harvest, .full = TRUE)
# A tsibble: 10 x 3 [1Y]
# Key:       fruit [2]
    year fruit   kilo
   <dbl> <chr>  <int>
 1  2010 cherry    NA
 2  2011 cherry     1
 3  2012 cherry     2
 4  2013 cherry    NA
 5  2014 cherry     5
 6  2010 kiwi       9
 7  2011 kiwi       4
 8  2012 kiwi      NA
 9  2013 kiwi       7
10  2014 kiwi      NA
> fill_gaps(harvest, .full = start())
# A tsibble: 9 x 3 [1Y]
# Key:       fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2010 cherry    NA
2  2011 cherry     1
3  2012 cherry     2
4  2013 cherry    NA
5  2014 cherry     5
6  2010 kiwi       9
7  2011 kiwi       4
8  2012 kiwi      NA
9  2013 kiwi       7
> fill_gaps(harvest, .full = end())
# A tsibble: 9 x 3 [1Y]
# Key:       fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry     2
3  2013 cherry    NA
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi      NA
8  2013 kiwi       7
9  2014 kiwi      NA
> full_harvest <- fill_gaps(harvest, .full = FALSE)
> full_harvest
# A tsibble: 8 x 3 [1Y]
# Key:       fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry     2
3  2013 cherry    NA
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi      NA
8  2013 kiwi       7
> 
> # replace gaps with a specific value
> harvest %>%
+   fill_gaps(kilo = 0L)
# A tsibble: 8 x 3 [1Y]
# Key:       fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry     2
3  2013 cherry     0
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi       0
8  2013 kiwi       7
> 
> # replace gaps using a function by variable
> harvest %>%
+   fill_gaps(kilo = sum(kilo))
# A tsibble: 8 x 3 [1Y]
# Key:       fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry     2
3  2013 cherry    28
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi      28
8  2013 kiwi       7
> 
> # replace gaps using a function for each group
> harvest %>%
+   group_by_key() %>%
+   fill_gaps(kilo = sum(kilo))
# A tsibble: 8 x 3 [1Y]
# Key:       fruit [2]
# Groups:    fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry     2
3  2013 cherry     8
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi      20
8  2013 kiwi       7
> 
> # leaves existing `NA` untouched
> harvest[2, 3] <- NA
> harvest %>%
+   group_by_key() %>%
+   fill_gaps(kilo = sum(kilo, na.rm = TRUE))
# A tsibble: 8 x 3 [1Y]
# Key:       fruit [2]
# Groups:    fruit [2]
   year fruit   kilo
  <dbl> <chr>  <int>
1  2011 cherry     1
2  2012 cherry    NA
3  2013 cherry     6
4  2014 cherry     5
5  2010 kiwi       9
6  2011 kiwi       4
7  2012 kiwi      20
8  2013 kiwi       7
> 
> # replace NA
> pedestrian %>%
+   group_by_key() %>%
+   fill_gaps(Count = as.integer(median(Count)))
# A tsibble: 69,048 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
# Groups:    Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 69,038 more rows
> 
> if (!requireNamespace("tidyr", quietly = TRUE)) {
+   stop("Please install the 'tidyr' package to run these following examples.")
+ }
> # use fill() to fill `NA` by previous/next entry
> pedestrian %>%
+   group_by_key() %>%
+   fill_gaps() %>%
+   tidyr::fill(Count, .direction = "down")
# A tsibble: 69,048 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
# Groups:    Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 69,038 more rows
> 
> 
> 
> cleanEx()
> nameEx("filter_index")
> ### * filter_index
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: filter_index
> ### Title: A shorthand for filtering time index for a tsibble
> ### Aliases: filter_index
> 
> ### ** Examples
> 
> # from the starting time to the end of Feb, 2015
> pedestrian %>%
+   filter_index(~ "2015-02")
# A tsibble: 4,536 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 4,526 more rows
> 
> # entire Feb 2015, & from the beginning of Aug 2016 to the end
> pedestrian %>%
+   filter_index("2015-02", "2016-08" ~ .)
# A tsibble: 16,244 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-02-01 00:00:00 2015-02-01     0   178
 2 Birrarung Marr 2015-02-01 01:00:00 2015-02-01     1    39
 3 Birrarung Marr 2015-02-01 02:00:00 2015-02-01     2    41
 4 Birrarung Marr 2015-02-01 03:00:00 2015-02-01     3    32
 5 Birrarung Marr 2015-02-01 04:00:00 2015-02-01     4    33
 6 Birrarung Marr 2015-02-01 05:00:00 2015-02-01     5    39
 7 Birrarung Marr 2015-02-01 06:00:00 2015-02-01     6    45
 8 Birrarung Marr 2015-02-01 07:00:00 2015-02-01     7    45
 9 Birrarung Marr 2015-02-01 08:00:00 2015-02-01     8    96
10 Birrarung Marr 2015-02-01 09:00:00 2015-02-01     9   116
# … with 16,234 more rows
> 
> # multiple time windows
> pedestrian %>%
+   filter_index(~"2015-02", "2015-08" ~ "2015-09", "2015-12" ~ "2016-02")
# A tsibble: 19,008 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 18,998 more rows
> 
> # entire 2015
> pedestrian %>%
+   filter_index("2015")
# A tsibble: 32,276 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 32,266 more rows
> 
> # specific
> pedestrian %>%
+   filter_index("2015-03-23" ~ "2015-10")
# A tsibble: 20,180 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-03-23 00:00:00 2015-03-23     0    39
 2 Birrarung Marr 2015-03-23 01:00:00 2015-03-23     1    24
 3 Birrarung Marr 2015-03-23 02:00:00 2015-03-23     2     1
 4 Birrarung Marr 2015-03-23 03:00:00 2015-03-23     3     3
 5 Birrarung Marr 2015-03-23 04:00:00 2015-03-23     4    16
 6 Birrarung Marr 2015-03-23 05:00:00 2015-03-23     5    36
 7 Birrarung Marr 2015-03-23 06:00:00 2015-03-23     6   178
 8 Birrarung Marr 2015-03-23 07:00:00 2015-03-23     7   462
 9 Birrarung Marr 2015-03-23 08:00:00 2015-03-23     8   756
10 Birrarung Marr 2015-03-23 09:00:00 2015-03-23     9   289
# … with 20,170 more rows
> pedestrian %>%
+   filter_index("2015-03-23" ~ "2015-10-31")
# A tsibble: 20,180 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-03-23 00:00:00 2015-03-23     0    39
 2 Birrarung Marr 2015-03-23 01:00:00 2015-03-23     1    24
 3 Birrarung Marr 2015-03-23 02:00:00 2015-03-23     2     1
 4 Birrarung Marr 2015-03-23 03:00:00 2015-03-23     3     3
 5 Birrarung Marr 2015-03-23 04:00:00 2015-03-23     4    16
 6 Birrarung Marr 2015-03-23 05:00:00 2015-03-23     5    36
 7 Birrarung Marr 2015-03-23 06:00:00 2015-03-23     6   178
 8 Birrarung Marr 2015-03-23 07:00:00 2015-03-23     7   462
 9 Birrarung Marr 2015-03-23 08:00:00 2015-03-23     8   756
10 Birrarung Marr 2015-03-23 09:00:00 2015-03-23     9   289
# … with 20,170 more rows
> pedestrian %>%
+   filter_index("2015-03-23 10" ~ "2015-10-31 12")
# A tsibble: 20,107 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-03-23 10:00:00 2015-03-23    10   199
 2 Birrarung Marr 2015-03-23 11:00:00 2015-03-23    11   120
 3 Birrarung Marr 2015-03-23 12:00:00 2015-03-23    12   317
 4 Birrarung Marr 2015-03-23 13:00:00 2015-03-23    13   583
 5 Birrarung Marr 2015-03-23 14:00:00 2015-03-23    14   265
 6 Birrarung Marr 2015-03-23 15:00:00 2015-03-23    15   275
 7 Birrarung Marr 2015-03-23 16:00:00 2015-03-23    16   409
 8 Birrarung Marr 2015-03-23 17:00:00 2015-03-23    17   698
 9 Birrarung Marr 2015-03-23 18:00:00 2015-03-23    18   546
10 Birrarung Marr 2015-03-23 19:00:00 2015-03-23    19   276
# … with 20,097 more rows
> 
> 
> 
> cleanEx()
> nameEx("group_by_key")
> ### * group_by_key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: group_by_key
> ### Title: Group by key variables
> ### Aliases: group_by_key
> 
> ### ** Examples
> 
> tourism %>%
+   group_by_key()
# A tsibble: 24,320 x 5 [1Q]
# Key:       Region, State, Purpose [304]
# Groups:    Region, State, Purpose [304]
   Quarter Region   State           Purpose  Trips
     <qtr> <chr>    <chr>           <chr>    <dbl>
 1 1998 Q1 Adelaide South Australia Business  135.
 2 1998 Q2 Adelaide South Australia Business  110.
 3 1998 Q3 Adelaide South Australia Business  166.
 4 1998 Q4 Adelaide South Australia Business  127.
 5 1999 Q1 Adelaide South Australia Business  137.
 6 1999 Q2 Adelaide South Australia Business  200.
 7 1999 Q3 Adelaide South Australia Business  169.
 8 1999 Q4 Adelaide South Australia Business  134.
 9 2000 Q1 Adelaide South Australia Business  154.
10 2000 Q2 Adelaide South Australia Business  169.
# … with 24,310 more rows
> 
> 
> 
> cleanEx()
> nameEx("guess_frequency")
> ### * guess_frequency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: guess_frequency
> ### Title: Guess a time frequency from other index objects
> ### Aliases: guess_frequency
> 
> ### ** Examples
> 
> guess_frequency(yearquarter("2016 Q1") + 0:7)
[1] 4
> guess_frequency(yearmonth("2016 Jan") + 0:23)
[1] 12
> guess_frequency(seq(as.Date("2017-01-01"), as.Date("2017-01-31"), by = 1))
[1] 7
> guess_frequency(seq(
+   as.POSIXct("2017-01-01 00:00"), as.POSIXct("2017-01-10 23:00"),
+   by = "1 hour"
+ ))
[1] 24
> 
> 
> 
> cleanEx()
> nameEx("has_gaps")
> ### * has_gaps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has_gaps
> ### Title: Does a tsibble have implicit gaps in time?
> ### Aliases: has_gaps
> 
> ### ** Examples
> 
> harvest <- tsibble(
+   year = c(2010, 2011, 2013, 2011, 2012, 2013),
+   fruit = rep(c("kiwi", "cherry"), each = 3),
+   kilo = sample(1:10, size = 6),
+   key = fruit, index = year
+ )
> has_gaps(harvest)
# A tibble: 2 x 2
  fruit  .gaps
  <chr>  <lgl>
1 cherry FALSE
2 kiwi   TRUE 
> has_gaps(harvest, .full = TRUE)
# A tibble: 2 x 2
  fruit  .gaps
  <chr>  <lgl>
1 cherry TRUE 
2 kiwi   TRUE 
> has_gaps(harvest, .full = start())
# A tibble: 2 x 2
  fruit  .gaps
  <chr>  <lgl>
1 cherry TRUE 
2 kiwi   TRUE 
> has_gaps(harvest, .full = end())
# A tibble: 2 x 2
  fruit  .gaps
  <chr>  <lgl>
1 cherry FALSE
2 kiwi   TRUE 
> 
> 
> 
> cleanEx()
> nameEx("holiday_aus")
> ### * holiday_aus
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: holiday_aus
> ### Title: Australian national and state-based public holiday
> ### Aliases: holiday_aus
> 
> ### ** Examples
> 
> holiday_aus(2016, state = "VIC")
# A tibble: 12 x 2
   holiday          date      
   <chr>            <date>    
 1 New Year's Day   2016-01-01
 2 Australia Day    2016-01-26
 3 Labour Day       2016-03-14
 4 Good Friday      2016-03-25
 5 Easter Saturday  2016-03-26
 6 Easter Sunday    2016-03-27
 7 Easter Monday    2016-03-28
 8 ANZAC Day        2016-04-25
 9 Queen's Birthday 2016-06-13
10 Melbourne Cup    2016-11-01
11 Boxing Day       2016-12-26
12 Christmas Day    2016-12-27
> holiday_aus(2013:2016, state = "ACT")
# A tibble: 44 x 2
   holiday          date      
   <chr>            <date>    
 1 New Year's Day   2013-01-01
 2 Australia Day    2013-01-28
 3 Canberra Day     2013-03-11
 4 Good Friday      2013-03-29
 5 Easter Saturday  2013-03-30
 6 Easter Sunday    2013-03-31
 7 Easter Monday    2013-04-01
 8 ANZAC Day        2013-04-25
 9 Queen's Birthday 2013-06-10
10 Christmas Day    2013-12-25
# … with 34 more rows
> 
> 
> 
> cleanEx()
> nameEx("index-by")
> ### * index-by
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: index_by
> ### Title: Group by time index and collapse with 'summarise()'
> ### Aliases: index_by
> 
> ### ** Examples
> 
> pedestrian %>% index_by()
# A tsibble: 66,037 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
# Groups:    @ Date_Time [17,542]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 66,027 more rows
> # Monthly counts across sensors
> library(dplyr, warn.conflicts = FALSE)
> monthly_ped <- pedestrian %>%
+   group_by_key() %>%
+   index_by(Year_Month = ~ yearmonth(.)) %>%
+   summarise(
+     Max_Count = max(Count),
+     Min_Count = min(Count)
+   )
> monthly_ped
# A tsibble: 95 x 4 [1M]
# Key:       Sensor [4]
   Sensor         Year_Month Max_Count Min_Count
   <chr>               <mth>     <int>     <int>
 1 Birrarung Marr   2015 Jan      5524         1
 2 Birrarung Marr   2015 Feb     10121         1
 3 Birrarung Marr   2015 Mar      9858         1
 4 Birrarung Marr   2015 Apr      7293         1
 5 Birrarung Marr   2015 May      5129         1
 6 Birrarung Marr   2015 Jun      7556         0
 7 Birrarung Marr   2015 Jul     11224         1
 8 Birrarung Marr   2015 Aug      5684         0
 9 Birrarung Marr   2015 Sep      7757         0
10 Birrarung Marr   2015 Oct      7085         1
# … with 85 more rows
> index(monthly_ped)
Year_Month
> 
> # Using existing variable
> pedestrian %>%
+   group_by_key() %>%
+   index_by(Date) %>%
+   summarise(
+     Max_Count = max(Count),
+     Min_Count = min(Count)
+   )
# A tsibble: 2,752 x 4 [1D]
# Key:       Sensor [4]
   Sensor         Date       Max_Count Min_Count
   <chr>          <date>         <int>     <int>
 1 Birrarung Marr 2015-01-01      1630        44
 2 Birrarung Marr 2015-01-02       352         1
 3 Birrarung Marr 2015-01-03       226         3
 4 Birrarung Marr 2015-01-04       852         4
 5 Birrarung Marr 2015-01-05      1427         3
 6 Birrarung Marr 2015-01-06       937         5
 7 Birrarung Marr 2015-01-07       708         4
 8 Birrarung Marr 2015-01-08       568         9
 9 Birrarung Marr 2015-01-09      1629         5
10 Birrarung Marr 2015-01-10      2439        10
# … with 2,742 more rows
> 
> # Attempt to aggregate to 4-hour interval, with the effects of DST
> pedestrian %>%
+   group_by_key() %>%
+   index_by(Date_Time4 = ~ lubridate::floor_date(., "4 hour")) %>%
+   summarise(Total_Count = sum(Count))
# A tsibble: 16,528 x 3 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time4          Total_Count
   <chr>          <dttm>                    <int>
 1 Birrarung Marr 2015-01-01 00:00:00        3287
 2 Birrarung Marr 2015-01-01 04:00:00         316
 3 Birrarung Marr 2015-01-01 08:00:00         995
 4 Birrarung Marr 2015-01-01 12:00:00        2117
 5 Birrarung Marr 2015-01-01 16:00:00        1829
 6 Birrarung Marr 2015-01-01 20:00:00         406
 7 Birrarung Marr 2015-01-02 00:00:00          44
 8 Birrarung Marr 2015-01-02 04:00:00         555
 9 Birrarung Marr 2015-01-02 08:00:00        1193
10 Birrarung Marr 2015-01-02 12:00:00         822
# … with 16,518 more rows
> 
> library(lubridate, warn.conflicts = FALSE)
> # Annual trips by Region and State
> tourism %>%
+   index_by(Year = ~ year(.)) %>%
+   group_by(Region, State) %>%
+   summarise(Total = sum(Trips))
# A tsibble: 1,520 x 4 [1Y]
# Key:       Region, State [76]
# Groups:    Region [76]
   Region   State            Year Total
   <chr>    <chr>           <dbl> <dbl>
 1 Adelaide South Australia  1998 2226.
 2 Adelaide South Australia  1999 2218.
 3 Adelaide South Australia  2000 2418.
 4 Adelaide South Australia  2001 2264.
 5 Adelaide South Australia  2002 2275.
 6 Adelaide South Australia  2003 2203.
 7 Adelaide South Australia  2004 2437.
 8 Adelaide South Australia  2005 2034.
 9 Adelaide South Australia  2006 2225.
10 Adelaide South Australia  2007 2317.
# … with 1,510 more rows
> 
> # Rouding to financial year, using a custom function
> financial_year <- function(date) {
+   year <- year(date)
+   ifelse(quarter(date) <= 2, year, year + 1)
+ }
> tourism %>%
+   index_by(Year = ~ financial_year(.)) %>%
+   summarise(Total = sum(Trips))
# A tsibble: 21 x 2 [1Y]
    Year  Total
   <dbl>  <dbl>
 1  1998 43506.
 2  1999 84202.
 3  2000 82222.
 4  2001 84122.
 5  2002 85024.
 6  2003 86476.
 7  2004 86174.
 8  2005 82372.
 9  2006 81589.
10  2007 82407.
# … with 11 more rows
> 
> 
> 
> cleanEx()

detaching ‘package:lubridate’, ‘package:dplyr’

> nameEx("index-rd")
> ### * index-rd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: index
> ### Title: Return index variable from a tsibble
> ### Aliases: index index_var index2 index2_var
> 
> ### ** Examples
> 
> index(pedestrian)
Date_Time
> index_var(pedestrian)
[1] "Date_Time"
> 
> 
> 
> cleanEx()
> nameEx("index_valid")
> ### * index_valid
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: index_valid
> ### Title: Add custom index support for a tsibble
> ### Aliases: index_valid
> 
> ### ** Examples
> 
> index_valid(seq(as.Date("2017-01-01"), as.Date("2017-01-10"), by = 1))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("interval-pull")
> ### * interval-pull
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interval_pull
> ### Title: Pull time interval from a vector
> ### Aliases: interval_pull
> 
> ### ** Examples
> 
> x <- seq(as.Date("2017-10-01"), as.Date("2017-10-31"), by = 3)
> interval_pull(x)
<interval[1]>
[1] 3D
> 
> 
> 
> cleanEx()
> nameEx("is-tsibble")
> ### * is-tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is_tsibble
> ### Title: If the object is a tsibble
> ### Aliases: is_tsibble is_grouped_ts
> 
> ### ** Examples
> 
> # A tibble is not a tsibble ----
> tbl <- tibble(
+   date = seq(as.Date("2017-10-01"), as.Date("2017-10-31"), by = 1),
+   value = rnorm(31)
+ )
> is_tsibble(tbl)
[1] FALSE
> 
> # A tsibble ----
> tsbl <- as_tsibble(tbl, index = date)
> is_tsibble(tsbl)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("key-data")
> ### * key-data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: key_data
> ### Title: Key metadata
> ### Aliases: key_data key_rows key_size n_keys
> 
> ### ** Examples
> 
> key_data(pedestrian)
# A tibble: 4 x 2
  Sensor                              .rows
* <chr>                         <list<int>>
1 Birrarung Marr                   [14,566]
2 Bourke Street Mall (North)       [16,414]
3 QV Market-Elizabeth St (West)    [17,518]
4 Southern Cross Station           [17,539]
> 
> 
> 
> cleanEx()
> nameEx("key")
> ### * key
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: key
> ### Title: Return key variables
> ### Aliases: key key_vars
> 
> ### ** Examples
> 
> key(pedestrian)
[[1]]
Sensor

> key_vars(pedestrian)
[1] "Sensor"
> 
> key(tourism)
[[1]]
Region

[[2]]
State

[[3]]
Purpose

> key_vars(tourism)
[1] "Region"  "State"   "Purpose"
> 
> 
> 
> cleanEx()
> nameEx("measured-vars")
> ### * measured-vars
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: measures
> ### Title: Return measured variables
> ### Aliases: measures measured_vars
> 
> ### ** Examples
> 
> measures(pedestrian)
[[1]]
Date

[[2]]
Time

[[3]]
Count

> measures(tourism)
[[1]]
Trips

> 
> measured_vars(pedestrian)
[1] "Date"  "Time"  "Count"
> measured_vars(tourism)
[1] "Trips"
> 
> 
> 
> cleanEx()
> nameEx("new-data")
> ### * new-data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_data
> ### Title: New tsibble data and append new observations to a tsibble
> ### Aliases: new_data new_data.tbl_ts append_row append_case
> 
> ### ** Examples
> 
> new_data(pedestrian)
# A tsibble: 4 x 2 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
  Sensor                        Date_Time          
  <chr>                         <dttm>             
1 Birrarung Marr                2017-01-01 00:00:00
2 Bourke Street Mall (North)    2017-01-01 00:00:00
3 QV Market-Elizabeth St (West) 2017-01-01 00:00:00
4 Southern Cross Station        2017-01-01 00:00:00
> new_data(pedestrian, keep_all = TRUE)
# A tsibble: 4 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
  Sensor                        Date_Time           Date        Time Count
  <chr>                         <dttm>              <date>     <int> <int>
1 Birrarung Marr                2017-01-01 00:00:00 NA            NA    NA
2 Bourke Street Mall (North)    2017-01-01 00:00:00 NA            NA    NA
3 QV Market-Elizabeth St (West) 2017-01-01 00:00:00 NA            NA    NA
4 Southern Cross Station        2017-01-01 00:00:00 NA            NA    NA
> new_data(pedestrian, n = 3)
# A tsibble: 12 x 2 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor                        Date_Time          
   <chr>                         <dttm>             
 1 Birrarung Marr                2017-01-01 00:00:00
 2 Birrarung Marr                2017-01-01 01:00:00
 3 Birrarung Marr                2017-01-01 02:00:00
 4 Bourke Street Mall (North)    2017-01-01 00:00:00
 5 Bourke Street Mall (North)    2017-01-01 01:00:00
 6 Bourke Street Mall (North)    2017-01-01 02:00:00
 7 QV Market-Elizabeth St (West) 2017-01-01 00:00:00
 8 QV Market-Elizabeth St (West) 2017-01-01 01:00:00
 9 QV Market-Elizabeth St (West) 2017-01-01 02:00:00
10 Southern Cross Station        2017-01-01 00:00:00
11 Southern Cross Station        2017-01-01 01:00:00
12 Southern Cross Station        2017-01-01 02:00:00
> new_data(pedestrian, n = -2)
# A tsibble: 8 x 2 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
  Sensor                        Date_Time          
  <chr>                         <dttm>             
1 Birrarung Marr                2014-12-31 22:00:00
2 Birrarung Marr                2014-12-31 23:00:00
3 Bourke Street Mall (North)    2015-02-16 22:00:00
4 Bourke Street Mall (North)    2015-02-16 23:00:00
5 QV Market-Elizabeth St (West) 2014-12-31 22:00:00
6 QV Market-Elizabeth St (West) 2014-12-31 23:00:00
7 Southern Cross Station        2014-12-31 22:00:00
8 Southern Cross Station        2014-12-31 23:00:00
> 
> tsbl <- tsibble(
+   date = rep(as.Date("2017-01-01") + 0:2, each = 2),
+   group = rep(letters[1:2], 3),
+   value = rnorm(6),
+   key = group
+ )
Using `date` as index variable.
> append_row(tsbl)
# A tsibble: 8 x 3 [1D]
# Key:       group [2]
  date       group  value
  <date>     <chr>  <dbl>
1 2017-01-01 a     -0.626
2 2017-01-02 a     -0.836
3 2017-01-03 a      0.330
4 2017-01-04 a     NA    
5 2017-01-01 b      0.184
6 2017-01-02 b      1.60 
7 2017-01-03 b     -0.820
8 2017-01-04 b     NA    
> append_row(tsbl, n = 2)
# A tsibble: 10 x 3 [1D]
# Key:       group [2]
   date       group  value
   <date>     <chr>  <dbl>
 1 2017-01-01 a     -0.626
 2 2017-01-02 a     -0.836
 3 2017-01-03 a      0.330
 4 2017-01-04 a     NA    
 5 2017-01-05 a     NA    
 6 2017-01-01 b      0.184
 7 2017-01-02 b      1.60 
 8 2017-01-03 b     -0.820
 9 2017-01-04 b     NA    
10 2017-01-05 b     NA    
> append_row(tsbl, n = -2)
# A tsibble: 10 x 3 [1D]
# Key:       group [2]
   date       group  value
   <date>     <chr>  <dbl>
 1 2016-12-30 a     NA    
 2 2016-12-31 a     NA    
 3 2017-01-01 a     -0.626
 4 2017-01-02 a     -0.836
 5 2017-01-03 a      0.330
 6 2016-12-30 b     NA    
 7 2016-12-31 b     NA    
 8 2017-01-01 b      0.184
 9 2017-01-02 b      1.60 
10 2017-01-03 b     -0.820
> 
> 
> 
> cleanEx()
> nameEx("new-interval")
> ### * new-interval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: new_interval
> ### Title: Interval constructor for a tsibble
> ### Aliases: new_interval is_regular_interval gcd_interval
> 
> ### ** Examples
> 
> (x <- new_interval(hour = 1, minute = 30))
<interval[1]>
[1] 1h 30m
> (y <- new_interval(.regular = FALSE)) # irregular interval
<interval[1]>
[1] !
> new_interval() # unknown interval
<interval[1]>
[1] ?
> new_interval(.others = list(semester = 1)) # custom interval
<interval[1]>
[1] 1semester
> is_regular_interval(x)
[1] TRUE
> is_regular_interval(y)
[1] FALSE
> gcd_interval(c(1, 3, 5, 6))
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("pedestrian")
> ### * pedestrian
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: pedestrian
> ### Title: Pedestrian counts in the city of Melbourne
> ### Aliases: pedestrian
> ### Keywords: datasets
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> data(pedestrian)
> # make implicit missingness to be explicit ----
> pedestrian %>% fill_gaps()
# A tsibble: 69,048 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166
# … with 69,038 more rows
> # compute daily maximum counts across sensors ----
> pedestrian %>%
+   group_by_key() %>%
+   index_by(Date) %>% # group by Date and use it as new index
+   summarise(MaxC = max(Count))
# A tsibble: 2,752 x 3 [1D]
# Key:       Sensor [4]
   Sensor         Date        MaxC
   <chr>          <date>     <int>
 1 Birrarung Marr 2015-01-01  1630
 2 Birrarung Marr 2015-01-02   352
 3 Birrarung Marr 2015-01-03   226
 4 Birrarung Marr 2015-01-04   852
 5 Birrarung Marr 2015-01-05  1427
 6 Birrarung Marr 2015-01-06   937
 7 Birrarung Marr 2015-01-07   708
 8 Birrarung Marr 2015-01-08   568
 9 Birrarung Marr 2015-01-09  1629
10 Birrarung Marr 2015-01-10  2439
# … with 2,742 more rows
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("regular")
> ### * regular
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interval
> ### Title: Meta-information of a tsibble
> ### Aliases: interval is_regular is_ordered
> 
> ### ** Examples
> 
> interval(pedestrian)
<interval[1]>
[1] 1h
> is_regular(pedestrian)
[1] TRUE
> is_ordered(pedestrian)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("scan_gaps")
> ### * scan_gaps
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: scan_gaps
> ### Title: Scan a tsibble for implicit missing observations
> ### Aliases: scan_gaps
> 
> ### ** Examples
> 
> scan_gaps(pedestrian)
# A tsibble: 3,011 x 2 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time          
   <chr>          <dttm>             
 1 Birrarung Marr 2015-04-05 02:00:00
 2 Birrarung Marr 2015-05-07 00:00:00
 3 Birrarung Marr 2015-05-07 01:00:00
 4 Birrarung Marr 2015-05-07 02:00:00
 5 Birrarung Marr 2015-05-07 03:00:00
 6 Birrarung Marr 2015-05-07 04:00:00
 7 Birrarung Marr 2015-05-07 05:00:00
 8 Birrarung Marr 2015-05-07 06:00:00
 9 Birrarung Marr 2015-05-07 07:00:00
10 Birrarung Marr 2015-05-07 08:00:00
# … with 3,001 more rows
> 
> 
> 
> cleanEx()
> nameEx("slide_tsibble")
> ### * slide_tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: slide_tsibble
> ### Title: Perform sliding windows on a tsibble by row
> ### Aliases: slide_tsibble
> 
> ### ** Examples
> 
> harvest <- tsibble(
+   year = rep(2010:2012, 2),
+   fruit = rep(c("kiwi", "cherry"), each = 3),
+   kilo = sample(1:10, size = 6),
+   key = fruit, index = year
+ )
> harvest %>%
+   slide_tsibble(.size = 2)
# A tsibble: 8 x 4 [1Y]
# Key:       .id, fruit [4]
   year fruit   kilo   .id
  <int> <chr>  <int> <int>
1  2010 cherry     1     1
2  2011 cherry     2     1
3  2010 kiwi       9     1
4  2011 kiwi       4     1
5  2011 cherry     2     2
6  2012 cherry     5     2
7  2011 kiwi       4     2
8  2012 kiwi       7     2
> 
> 
> 
> cleanEx()
> nameEx("stretch_tsibble")
> ### * stretch_tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stretch_tsibble
> ### Title: Perform stretching windows on a tsibble by row
> ### Aliases: stretch_tsibble
> 
> ### ** Examples
> 
> harvest <- tsibble(
+   year = rep(2010:2012, 2),
+   fruit = rep(c("kiwi", "cherry"), each = 3),
+   kilo = sample(1:10, size = 6),
+   key = fruit, index = year
+ )
> harvest %>%
+   stretch_tsibble()
# A tsibble: 12 x 4 [1Y]
# Key:       .id, fruit [6]
    year fruit   kilo   .id
   <int> <chr>  <int> <int>
 1  2010 cherry     1     1
 2  2010 kiwi       9     1
 3  2010 cherry     1     2
 4  2011 cherry     2     2
 5  2010 kiwi       9     2
 6  2011 kiwi       4     2
 7  2010 cherry     1     3
 8  2011 cherry     2     3
 9  2012 cherry     5     3
10  2010 kiwi       9     3
11  2011 kiwi       4     3
12  2012 kiwi       7     3
> 
> 
> 
> cleanEx()
> nameEx("tile_tsibble")
> ### * tile_tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tile_tsibble
> ### Title: Perform tiling windows on a tsibble by row
> ### Aliases: tile_tsibble
> 
> ### ** Examples
> 
> harvest <- tsibble(
+   year = rep(2010:2012, 2),
+   fruit = rep(c("kiwi", "cherry"), each = 3),
+   kilo = sample(1:10, size = 6),
+   key = fruit, index = year
+ )
> harvest %>%
+   tile_tsibble(.size = 2)
# A tsibble: 6 x 4 [1Y]
# Key:       .id, fruit [4]
   year fruit   kilo   .id
  <int> <chr>  <int> <int>
1  2010 cherry     1     1
2  2011 cherry     2     1
3  2010 kiwi       9     1
4  2011 kiwi       4     1
5  2012 cherry     5     2
6  2012 kiwi       7     2
> 
> 
> 
> cleanEx()
> nameEx("time_in")
> ### * time_in
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: time_in
> ### Title: If time falls in the ranges using compact expressions
> ### Aliases: time_in
> 
> ### ** Examples
> 
> x <- unique(pedestrian$Date_Time)
> lgl <- time_in(x, ~"2015-02", "2015-08" ~ "2015-09", "2015-12" ~ "2016-02")
> lgl[1:10]
 [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
> # more specific
> lgl2 <- time_in(x, "2015-03-23 10" ~ "2015-10-31 12")
> lgl2[1:10]
 [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> pedestrian %>%
+   filter(time_in(Date_Time, "2015-03-23 10" ~ "2015-10-31 12"))
# A tsibble: 20,107 x 5 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count
   <chr>          <dttm>              <date>     <int> <int>
 1 Birrarung Marr 2015-03-23 10:00:00 2015-03-23    10   199
 2 Birrarung Marr 2015-03-23 11:00:00 2015-03-23    11   120
 3 Birrarung Marr 2015-03-23 12:00:00 2015-03-23    12   317
 4 Birrarung Marr 2015-03-23 13:00:00 2015-03-23    13   583
 5 Birrarung Marr 2015-03-23 14:00:00 2015-03-23    14   265
 6 Birrarung Marr 2015-03-23 15:00:00 2015-03-23    15   275
 7 Birrarung Marr 2015-03-23 16:00:00 2015-03-23    16   409
 8 Birrarung Marr 2015-03-23 17:00:00 2015-03-23    17   698
 9 Birrarung Marr 2015-03-23 18:00:00 2015-03-23    18   546
10 Birrarung Marr 2015-03-23 19:00:00 2015-03-23    19   276
# … with 20,097 more rows
> pedestrian %>%
+   filter(time_in(Date_Time, "2015")) %>%
+   mutate(Season = ifelse(
+     time_in(Date_Time, "2015-03" ~ "2015-08"),
+     "Autumn-Winter", "Spring-Summer"
+   ))
# A tsibble: 32,276 x 6 [1h] <Australia/Melbourne>
# Key:       Sensor [4]
   Sensor         Date_Time           Date        Time Count Season       
   <chr>          <dttm>              <date>     <int> <int> <chr>        
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630 Spring-Summer
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826 Spring-Summer
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567 Spring-Summer
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264 Spring-Summer
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139 Spring-Summer
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77 Spring-Summer
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44 Spring-Summer
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56 Spring-Summer
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113 Spring-Summer
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166 Spring-Summer
# … with 32,266 more rows
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("tourism")
> ### * tourism
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tourism
> ### Title: Australian domestic overnight trips
> ### Aliases: tourism
> ### Keywords: datasets
> 
> ### ** Examples
> 
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> data(tourism)
> # Total trips over geographical regions
> tourism %>%
+   group_by(Region, State) %>%
+   summarise(Total_Trips = sum(Trips))
# A tsibble: 6,080 x 4 [1Q]
# Key:       Region, State [76]
# Groups:    Region [76]
   Region   State           Quarter Total_Trips
   <chr>    <chr>             <qtr>       <dbl>
 1 Adelaide South Australia 1998 Q1        659.
 2 Adelaide South Australia 1998 Q2        450.
 3 Adelaide South Australia 1998 Q3        593.
 4 Adelaide South Australia 1998 Q4        524.
 5 Adelaide South Australia 1999 Q1        548.
 6 Adelaide South Australia 1999 Q2        569.
 7 Adelaide South Australia 1999 Q3        538.
 8 Adelaide South Australia 1999 Q4        562.
 9 Adelaide South Australia 2000 Q1        646.
10 Adelaide South Australia 2000 Q2        563.
# … with 6,070 more rows
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("tsibble-package")
> ### * tsibble-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tsibble-package
> ### Title: tsibble: tidy temporal data frames and tools
> ### Aliases: tsibble-package
> 
> ### ** Examples
> 
> # create a tsibble w/o a key ----
> tsibble(
+   date = as.Date("2017-01-01") + 0:9,
+   value = rnorm(10)
+ )
Using `date` as index variable.
# A tsibble: 10 x 2 [1D]
   date        value
   <date>      <dbl>
 1 2017-01-01 -0.626
 2 2017-01-02  0.184
 3 2017-01-03 -0.836
 4 2017-01-04  1.60 
 5 2017-01-05  0.330
 6 2017-01-06 -0.820
 7 2017-01-07  0.487
 8 2017-01-08  0.738
 9 2017-01-09  0.576
10 2017-01-10 -0.305
> 
> # create a tsibble with one key ----
> tsibble(
+   qtr = rep(yearquarter("2010-01") + 0:9, 3),
+   group = rep(c("x", "y", "z"), each = 10),
+   value = rnorm(30),
+   key = group
+ )
Using `qtr` as index variable.
# A tsibble: 30 x 3 [1Q]
# Key:       group [3]
       qtr group   value
     <qtr> <chr>   <dbl>
 1 2010 Q1 x      1.51  
 2 2010 Q2 x      0.390 
 3 2010 Q3 x     -0.621 
 4 2010 Q4 x     -2.21  
 5 2011 Q1 x      1.12  
 6 2011 Q2 x     -0.0449
 7 2011 Q3 x     -0.0162
 8 2011 Q4 x      0.944 
 9 2012 Q1 x      0.821 
10 2012 Q2 x      0.594 
# … with 20 more rows
> 
> 
> 
> cleanEx()
> nameEx("tsibble-tidyverse")
> ### * tsibble-tidyverse
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tsibble-tidyverse
> ### Title: Tidyverse methods for tsibble
> ### Aliases: tsibble-tidyverse
> 
> ### ** Examples
> 
> library(dplyr, warn.conflicts = FALSE)
> # `summarise()` a tsibble always aggregates over time
> # Sum over sensors
> pedestrian %>%
+   index_by() %>%
+   summarise(Total = sum(Count))
# A tsibble: 17,542 x 2 [1h] <Australia/Melbourne>
   Date_Time           Total
   <dttm>              <int>
 1 2015-01-01 00:00:00  2866
 2 2015-01-01 01:00:00  1535
 3 2015-01-01 02:00:00   994
 4 2015-01-01 03:00:00   569
 5 2015-01-01 04:00:00   311
 6 2015-01-01 05:00:00   159
 7 2015-01-01 06:00:00   129
 8 2015-01-01 07:00:00   146
 9 2015-01-01 08:00:00   258
10 2015-01-01 09:00:00   419
# … with 17,532 more rows
> # shortcut
> pedestrian %>%
+   summarise(Total = sum(Count))
# A tsibble: 17,542 x 2 [1h] <Australia/Melbourne>
   Date_Time           Total
   <dttm>              <int>
 1 2015-01-01 00:00:00  2866
 2 2015-01-01 01:00:00  1535
 3 2015-01-01 02:00:00   994
 4 2015-01-01 03:00:00   569
 5 2015-01-01 04:00:00   311
 6 2015-01-01 05:00:00   159
 7 2015-01-01 06:00:00   129
 8 2015-01-01 07:00:00   146
 9 2015-01-01 08:00:00   258
10 2015-01-01 09:00:00   419
# … with 17,532 more rows
> # Back to tibble
> pedestrian %>%
+   as_tibble() %>%
+   summarise(Total = sum(Count))
# A tibble: 1 x 1
     Total
     <int>
1 45483871
> 
> library(tidyr)
> stocks <- tsibble(
+   time = as.Date("2009-01-01") + 0:9,
+   X = rnorm(10, 0, 1),
+   Y = rnorm(10, 0, 2),
+   Z = rnorm(10, 0, 4)
+ )
Using `time` as index variable.
> (stocksm <- stocks %>%
+   pivot_longer(-time, names_to = "stock", values_to = "price"))
# A tsibble: 30 x 3 [1D]
# Key:       stock [3]
   time       stock  price
   <date>     <chr>  <dbl>
 1 2009-01-01 X     -0.626
 2 2009-01-01 Y      3.02 
 3 2009-01-01 Z      3.68 
 4 2009-01-02 X      0.184
 5 2009-01-02 Y      0.780
 6 2009-01-02 Z      3.13 
 7 2009-01-03 X     -0.836
 8 2009-01-03 Y     -1.24 
 9 2009-01-03 Z      0.298
10 2009-01-04 X      1.60 
# … with 20 more rows
> stocksm %>%
+   pivot_wider(names_from = stock, values_from = price)
# A tsibble: 10 x 4 [1D]
   time            X       Y      Z
   <date>      <dbl>   <dbl>  <dbl>
 1 2009-01-01 -0.626  3.02    3.68 
 2 2009-01-02  0.184  0.780   3.13 
 3 2009-01-03 -0.836 -1.24    0.298
 4 2009-01-04  1.60  -4.43   -7.96 
 5 2009-01-05  0.330  2.25    2.48 
 6 2009-01-06 -0.820 -0.0899 -0.225
 7 2009-01-07  0.487 -0.0324 -0.623
 8 2009-01-08  0.738  1.89   -5.88 
 9 2009-01-09  0.576  1.64   -1.91 
10 2009-01-10 -0.305  1.19    1.67 
> 
> 
> 
> cleanEx()

detaching ‘package:tidyr’, ‘package:dplyr’

> nameEx("tsibble")
> ### * tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tsibble
> ### Title: Create a tsibble object
> ### Aliases: tsibble
> 
> ### ** Examples
> 
> # create a tsibble w/o a key
> tsibble(
+   date = as.Date("2017-01-01") + 0:9,
+   value = rnorm(10)
+ )
Using `date` as index variable.
# A tsibble: 10 x 2 [1D]
   date        value
   <date>      <dbl>
 1 2017-01-01 -0.626
 2 2017-01-02  0.184
 3 2017-01-03 -0.836
 4 2017-01-04  1.60 
 5 2017-01-05  0.330
 6 2017-01-06 -0.820
 7 2017-01-07  0.487
 8 2017-01-08  0.738
 9 2017-01-09  0.576
10 2017-01-10 -0.305
> 
> # create a tsibble with a single variable for key
> tsibble(
+   qtr = rep(yearquarter("2010 Q1") + 0:9, 3),
+   group = rep(c("x", "y", "z"), each = 10),
+   value = rnorm(30),
+   key = group
+ )
Using `qtr` as index variable.
# A tsibble: 30 x 3 [1Q]
# Key:       group [3]
       qtr group   value
     <qtr> <chr>   <dbl>
 1 2010 Q1 x      1.51  
 2 2010 Q2 x      0.390 
 3 2010 Q3 x     -0.621 
 4 2010 Q4 x     -2.21  
 5 2011 Q1 x      1.12  
 6 2011 Q2 x     -0.0449
 7 2011 Q3 x     -0.0162
 8 2011 Q4 x      0.944 
 9 2012 Q1 x      0.821 
10 2012 Q2 x      0.594 
# … with 20 more rows
> 
> # create a tsibble with multiple variables for key
> tsibble(
+   mth = rep(yearmonth("2010 Jan") + 0:8, each = 3),
+   xyz = rep(c("x", "y", "z"), each = 9),
+   abc = rep(letters[1:3], times = 9),
+   value = rnorm(27),
+   key = c(xyz, abc)
+ )
Using `mth` as index variable.
# A tsibble: 27 x 4 [1M]
# Key:       xyz, abc [9]
        mth xyz   abc    value
      <mth> <chr> <chr>  <dbl>
 1 2010 Jan x     a     -0.165
 2 2010 Feb x     a      0.557
 3 2010 Mar x     a      0.365
 4 2010 Jan x     b     -0.253
 5 2010 Feb x     b     -0.689
 6 2010 Mar x     b      0.769
 7 2010 Jan x     c      0.697
 8 2010 Feb x     c     -0.707
 9 2010 Mar x     c     -0.112
10 2010 Apr y     a      0.881
# … with 17 more rows
> 
> # create a tsibble containing "key" and "index" as column names
> tsibble(!!!list(
+   index = rep(yearquarter("2010 Q1") + 0:9, 3),
+   key = rep(c("x", "y", "z"), each = 10),
+   value = rnorm(30)),
+   key = key, index = index
+ )
# A tsibble: 30 x 3 [1Q]
# Key:       key [3]
     index key    value
     <qtr> <chr>  <dbl>
 1 2010 Q1 x      1.47 
 2 2010 Q2 x      0.153
 3 2010 Q3 x      2.17 
 4 2010 Q4 x      0.476
 5 2011 Q1 x     -0.710
 6 2011 Q2 x      0.611
 7 2011 Q3 x     -0.934
 8 2011 Q4 x     -1.25 
 9 2012 Q1 x      0.291
10 2012 Q2 x     -0.443
# … with 20 more rows
> 
> 
> 
> cleanEx()
> nameEx("update_tsibble")
> ### * update_tsibble
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: update_tsibble
> ### Title: Update key and index for a tsibble
> ### Aliases: update_tsibble
> 
> ### ** Examples
> 
> # update index
> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> pedestrian %>%
+   group_by_key() %>%
+   mutate(Hour_Since = Date_Time - min(Date_Time)) %>%
+   update_tsibble(index = Hour_Since)
# A tsibble: 66,037 x 6 [1h]
# Key:       Sensor [4]
# Groups:    Sensor [4]
   Sensor         Date_Time           Date        Time Count Hour_Since
   <chr>          <dttm>              <date>     <int> <int> <drtn>    
 1 Birrarung Marr 2015-01-01 00:00:00 2015-01-01     0  1630     0 secs
 2 Birrarung Marr 2015-01-01 01:00:00 2015-01-01     1   826  3600 secs
 3 Birrarung Marr 2015-01-01 02:00:00 2015-01-01     2   567  7200 secs
 4 Birrarung Marr 2015-01-01 03:00:00 2015-01-01     3   264 10800 secs
 5 Birrarung Marr 2015-01-01 04:00:00 2015-01-01     4   139 14400 secs
 6 Birrarung Marr 2015-01-01 05:00:00 2015-01-01     5    77 18000 secs
 7 Birrarung Marr 2015-01-01 06:00:00 2015-01-01     6    44 21600 secs
 8 Birrarung Marr 2015-01-01 07:00:00 2015-01-01     7    56 25200 secs
 9 Birrarung Marr 2015-01-01 08:00:00 2015-01-01     8   113 28800 secs
10 Birrarung Marr 2015-01-01 09:00:00 2015-01-01     9   166 32400 secs
# … with 66,027 more rows
> 
> # update key: drop the variable "State" from the key
> tourism %>%
+   update_tsibble(key = c(Purpose, Region))
# A tsibble: 24,320 x 5 [1Q]
# Key:       Purpose, Region [304]
   Quarter Region   State           Purpose  Trips
     <qtr> <chr>    <chr>           <chr>    <dbl>
 1 1998 Q1 Adelaide South Australia Business  135.
 2 1998 Q2 Adelaide South Australia Business  110.
 3 1998 Q3 Adelaide South Australia Business  166.
 4 1998 Q4 Adelaide South Australia Business  127.
 5 1999 Q1 Adelaide South Australia Business  137.
 6 1999 Q2 Adelaide South Australia Business  200.
 7 1999 Q3 Adelaide South Australia Business  169.
 8 1999 Q4 Adelaide South Australia Business  134.
 9 2000 Q1 Adelaide South Australia Business  154.
10 2000 Q2 Adelaide South Australia Business  169.
# … with 24,310 more rows
> 
> 
> 
> cleanEx()

detaching ‘package:dplyr’

> nameEx("year-month")
> ### * year-month
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yearmonth
> ### Title: Represent year-month
> ### Aliases: yearmonth is_yearmonth
> 
> ### ** Examples
> 
> # coerce POSIXct/Dates to yearmonth
> x <- seq(as.Date("2016-01-01"), as.Date("2016-12-31"), by = "1 month")
> yearmonth(x)
<yearmonth[12]>
 [1] "2016 Jan" "2016 Feb" "2016 Mar" "2016 Apr" "2016 May" "2016 Jun"
 [7] "2016 Jul" "2016 Aug" "2016 Sep" "2016 Oct" "2016 Nov" "2016 Dec"
> 
> # parse characters
> yearmonth(c("2018 Jan", "2018-01", "2018 January"))
<yearmonth[3]>
[1] "2018 Jan" "2018 Jan" "2018 Jan"
> 
> # seq() and arithmetic
> mth <- yearmonth("2017-11")
> seq(mth, length.out = 10, by = 1) # by 1 month
<yearmonth[10]>
 [1] "2017 Nov" "2017 Dec" "2018 Jan" "2018 Feb" "2018 Mar" "2018 Apr"
 [7] "2018 May" "2018 Jun" "2018 Jul" "2018 Aug"
> mth + 0:9
<yearmonth[10]>
 [1] "2017 Nov" "2017 Dec" "2018 Jan" "2018 Feb" "2018 Mar" "2018 Apr"
 [7] "2018 May" "2018 Jun" "2018 Jul" "2018 Aug"
> 
> # display formats
> format(mth, format = "%y %m")
[1] "17 11"
> 
> # units since 1970 Jan
> as.double(yearmonth("1969 Jan") + 0:24)
 [1] -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6
[20]   7   8   9  10  11  12
> 
> 
> 
> cleanEx()
> nameEx("year-quarter")
> ### * year-quarter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yearquarter
> ### Title: Represent year-quarter
> ### Aliases: yearquarter is_yearquarter fiscal_year
> 
> ### ** Examples
> 
> # coerce POSIXct/Dates to yearquarter
> x <- seq(as.Date("2016-01-01"), as.Date("2016-12-31"), by = "1 quarter")
> yearquarter(x)
<yearquarter[4]>
[1] "2016 Q1" "2016 Q2" "2016 Q3" "2016 Q4"
# Year starts on: January
> yearquarter(x, fiscal_start = 6)
<yearquarter[4]>
[1] "2016 Q3" "2016 Q4" "2017 Q1" "2017 Q2"
# Year starts on: June
> 
> # parse characters
> yearquarter(c("2018 Q1", "2018 Qtr1", "2018 Quarter 1"))
<yearquarter[3]>
[1] "2018 Q1" "2018 Q1" "2018 Q1"
# Year starts on: January
> 
> # seq() and arithmetic
> qtr <- yearquarter("2017 Q1")
> seq(qtr, length.out = 10, by = 1) # by 1 quarter
<yearquarter[10]>
 [1] "2017 Q1" "2017 Q2" "2017 Q3" "2017 Q4" "2018 Q1" "2018 Q2" "2018 Q3"
 [8] "2018 Q4" "2019 Q1" "2019 Q2"
# Year starts on: January
> qtr + 0:9
<yearquarter[10]>
 [1] "2017 Q1" "2017 Q2" "2017 Q3" "2017 Q4" "2018 Q1" "2018 Q2" "2018 Q3"
 [8] "2018 Q4" "2019 Q1" "2019 Q2"
# Year starts on: January
> 
> # display formats
> format(qtr, format = "%y Qtr%q")
[1] "17 Qtr1"
> 
> # `fiscal_year()` helps to extract fiscal year
> y <- yearquarter(as.Date("2020-06-01"), fiscal_start = 6)
> fiscal_year(y)
[1] 2021
> lubridate::year(y) # calendar years
[1] 2020
> 
> 
> 
> cleanEx()
> nameEx("year-week")
> ### * year-week
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: yearweek
> ### Title: Represent year-week based on the ISO 8601 standard (with
> ###   flexible start day)
> ### Aliases: yearweek is_yearweek is_53weeks
> 
> ### ** Examples
> 
> # coerce POSIXct/Dates to yearweek
> x <- seq(as.Date("2016-01-01"), as.Date("2016-12-31"), by = "1 week")
> yearweek(x)
<yearweek[53]>
 [1] "2015 W53" "2016 W01" "2016 W02" "2016 W03" "2016 W04" "2016 W05"
 [7] "2016 W06" "2016 W07" "2016 W08" "2016 W09" "2016 W10" "2016 W11"
[13] "2016 W12" "2016 W13" "2016 W14" "2016 W15" "2016 W16" "2016 W17"
[19] "2016 W18" "2016 W19" "2016 W20" "2016 W21" "2016 W22" "2016 W23"
[25] "2016 W24" "2016 W25" "2016 W26" "2016 W27" "2016 W28" "2016 W29"
[31] "2016 W30" "2016 W31" "2016 W32" "2016 W33" "2016 W34" "2016 W35"
[37] "2016 W36" "2016 W37" "2016 W38" "2016 W39" "2016 W40" "2016 W41"
[43] "2016 W42" "2016 W43" "2016 W44" "2016 W45" "2016 W46" "2016 W47"
[49] "2016 W48" "2016 W49" "2016 W50" "2016 W51" "2016 W52"
# Week starts on: Monday
> yearweek(x, week_start = 7)
<yearweek[53]>
 [1] "2015 W52" "2016 W01" "2016 W02" "2016 W03" "2016 W04" "2016 W05"
 [7] "2016 W06" "2016 W07" "2016 W08" "2016 W09" "2016 W10" "2016 W11"
[13] "2016 W12" "2016 W13" "2016 W14" "2016 W15" "2016 W16" "2016 W17"
[19] "2016 W18" "2016 W19" "2016 W20" "2016 W21" "2016 W22" "2016 W23"
[25] "2016 W24" "2016 W25" "2016 W26" "2016 W27" "2016 W28" "2016 W29"
[31] "2016 W30" "2016 W31" "2016 W32" "2016 W33" "2016 W34" "2016 W35"
[37] "2016 W36" "2016 W37" "2016 W38" "2016 W39" "2016 W40" "2016 W41"
[43] "2016 W42" "2016 W43" "2016 W44" "2016 W45" "2016 W46" "2016 W47"
[49] "2016 W48" "2016 W49" "2016 W50" "2016 W51" "2016 W52"
# Week starts on: Sunday
> 
> # parse characters
> yearweek(c("2018 W01", "2018 Wk01", "2018 Week 1"))
<yearweek[3]>
[1] "2018 W01" "2018 W01" "2018 W01"
# Week starts on: Monday
> 
> # seq() and arithmetic
> wk1 <- yearweek("2017 W50")
> wk2 <- yearweek("2018 W12")
> seq(from = wk1, to = wk2, by = 2)
<yearweek[8]>
[1] "2017 W50" "2017 W52" "2018 W02" "2018 W04" "2018 W06" "2018 W08" "2018 W10"
[8] "2018 W12"
# Week starts on: Monday
> wk1 + 0:9
<yearweek[10]>
 [1] "2017 W50" "2017 W51" "2017 W52" "2018 W01" "2018 W02" "2018 W03"
 [7] "2018 W04" "2018 W05" "2018 W06" "2018 W07"
# Week starts on: Monday
> 
> # display formats
> format(c(wk1, wk2), format = "%V/%Y")
[1] "50/2017" "12/2018"
> is_53weeks(2015:2016)
[1]  TRUE FALSE
> is_53weeks(1969)
[1] FALSE
> is_53weeks(1969, week_start = 7)
[1] TRUE
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  109.059 1.084 111.593 0.01 0.008 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
