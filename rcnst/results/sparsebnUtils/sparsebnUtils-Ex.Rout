
R Under development (unstable) (2017-08-15 r73096) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "sparsebnUtils"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('sparsebnUtils')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("coerce_discrete")
> ### * coerce_discrete
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: coerce_discrete
> ### Title: Recode discrete data
> ### Aliases: coerce_discrete coerce_discrete.factor coerce_discrete.numeric
> ###   coerce_discrete.integer coerce_discrete.character
> ###   coerce_discrete.data.frame coerce_discrete.sparsebnData
> 
> ### ** Examples
> 
> x <- 1:5
> coerce_discrete(x) # output: 0 1 2 3 4
[1] 0 1 2 3 4
> 
> x <- c("high", "normal", "high", "low")
> coerce_discrete(x) # output: 0 2 0 1
[1] 0 2 0 1
> 
> 
> 
> 
> cleanEx()
> nameEx("fit_multinom_dag")
> ### * fit_multinom_dag
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fit_multinom_dag
> ### Title: Inference in discrete Bayesian networks
> ### Aliases: fit_multinom_dag
> 
> ### ** Examples
> 
> 
> ### construct a random data set
> x <- c(0,1,0,1,0)
> y <- c(1,0,1,0,1)
> z <- c(0,1,2,1,0)
> a <- c(1,1,1,0,0)
> b <- c(0,0,1,1,1)
> dat <- data.frame(x, y, z, a, b)
> 
> ### randomly construct an edgelist of a graph
> nnode <- ncol(dat)
> li <- vector("list", length = nnode)
> li[[1]] <- c(2L,4L)
> li[[2]] <- c(3L,4L,5L)
> li[[3]] <- integer(0)
> li[[4]] <- integer(0)
> li[[5]] <- integer(0)
> edgeL <- edgeList(li)
> 
> ### run fit_multinom_dag
> fit.multinom <- fit_multinom_dag(edgeL, dat)
> 
> 
> 
> 
> cleanEx()
> nameEx("sparsebnData")
> ### * sparsebnData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sparsebnData
> ### Title: sparsebnData class
> ### Aliases: sparsebnData sparsebnData is.sparsebnData
> ###   sparsebnData.data.frame sparsebnData.matrix print.sparsebnData
> 
> ### ** Examples
> 
> 
> ### Generate a random continuous dataset
> mat <- matrix(rnorm(1000), nrow = 20)
> dat <- sparsebnData(mat, type = "continuous") # purely observational data with continuous variables
A list of interventions was not specified: Assuming data is purely observational.
> 
> ### Discrete data
> mat <- cbind(c(0,1,1,0),
+              c(2,1,0,1),
+              c(0,0,3,0))
> dat.levels <- list(c(0,1), c(0,1,2), c(0,1,2,3))
> dat <- sparsebnData(mat,
+                     type = "discrete",
+                     levels = dat.levels) # purely observational data with discrete variables
A list of interventions was not specified: Assuming data is purely observational.
> 
> dat.ivn <- list(c(1), c(1), c(2,3), c(2,3)) # add some interventions
> dat <- sparsebnData(mat,
+                     type = "discrete",
+                     levels = dat.levels,
+                     ivn = dat.ivn) # specify intervention rows
> 
> 
> 
> 
> cleanEx()
> nameEx("sparsebnFit")
> ### * sparsebnFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sparsebnFit
> ### Title: sparsebnFit class
> ### Aliases: sparsebnFit sparsebnFit is.sparsebnFit print.sparsebnFit
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D ### Learn the cytometry network
> ##D library(sparsebn)
> ##D data(cytometryContinuous) # from the sparsebn package
> ##D cyto.data <- sparsebnData(cytometryContinuous[["data"]], type = "continuous")
> ##D cyto.learn <- estimate.dag(cyto.data)
> ##D 
> ##D ### Inspect the output
> ##D class(cyto.learn[[1]])
> ##D print(cyto.learn[[2]])
> ##D show.parents(cyto.learn[[1]], c("raf", "mek", "plc"))
> ##D 
> ##D ### Manipulate a particular graph
> ##D cyto.fit <- cyto.learn[[7]]
> ##D num.nodes(cyto.fit)
> ##D num.edges(cyto.fit)
> ##D show.parents(cyto.fit, c("raf", "mek", "plc"))
> ##D plot(cyto.fit)
> ##D 
> ##D ### Use graph package instead of edgeLists
> ##D setGraphPackage("graph", coerce = TRUE) # set sparsebn to use graph package
> ##D cyto.edges <- cyto.fit$edges
> ##D degree(cyto.edges)       # only available with graph package
> ##D isConnected(cyto.edges)  # only available with graph package
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("sparsebnPath")
> ### * sparsebnPath
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sparsebnPath
> ### Title: sparsebnPath class
> ### Aliases: sparsebnPath sparsebnPath is.sparsebnPath print.sparsebnPath
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D ### Learn the cytometry network
> ##D library(sparsebn)
> ##D data(cytometryContinuous) # from the sparsebn package
> ##D cyto.data <- sparsebnData(cytometryContinuous[["data"]], type = "continuous")
> ##D cyto.learn <- estimate.dag(cyto.data)
> ##D 
> ##D ### Inspect the output
> ##D class(cyto.learn)
> ##D print(cyto.learn)
> ##D plot(cyto.learn)
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.736 0.012 0.744 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
