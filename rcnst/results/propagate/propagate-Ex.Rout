
R Under development (unstable) (2017-08-15 r73096) -- "Unsuffered Consequences"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "propagate"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('propagate')
Loading required package: MASS
Loading required package: tmvtnorm
Loading required package: mvtnorm
Loading required package: Matrix
Loading required package: stats4
Loading required package: gmm
Loading required package: sandwich
Loading required package: Rcpp
Loading required package: ff
Loading required package: bit
Attaching package bit
package:bit (c) 2008-2012 Jens Oehlschlaegel (GPL-2)
creators: bit bitwhich
coercion: as.logical as.integer as.bit as.bitwhich which
operator: ! & | xor != ==
querying: print length any all min max range sum summary
bit access: length<- [ [<- [[ [[<-
for more help type ?bit

Attaching package: ‘bit’

The following object is masked from ‘package:base’:

    xor

Attaching package ff
- getOption("fftempdir")=="/tmp/Rtmp6F4xwM"

- getOption("ffextension")=="ff"

- getOption("ffdrop")==TRUE

- getOption("fffinonexit")==TRUE

- getOption("ffpagesize")==65536

- getOption("ffcaching")=="mmnoflush"  -- consider "ffeachflush" if your system stalls on large writes

- getOption("ffbatchbytes")==16777216 -- consider a different value for tuning your system

- getOption("ffmaxbytes")==536870912 -- consider a different value for tuning your system


Attaching package: ‘ff’

The following objects are masked from ‘package:bit’:

    clone, clone.default, clone.list

The following objects are masked from ‘package:utils’:

    write.csv, write.csv2

The following objects are masked from ‘package:base’:

    is.factor, is.ordered

Loading required package: minpack.lm
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("WelchSatter")
> ### * WelchSatter
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: WelchSatter
> ### Title: Welch-Satterthwaite approximation to the 'effective degrees of
> ###   freedom'
> ### Aliases: WelchSatter
> ### Keywords: matrix multivariate algebra
> 
> ### ** Examples
> 
> ## Taken from GUM H.1.6, 4).
> WelchSatter(32, c(25, 9.7, 2.9, 16.6), c(18, 25.6, 50, 2), alpha = 0.01)
$ws.df
[1] 17.47182

$k
[1] 2.888581

[[3]]
[1] 92.4346

> 
> 
> 
> cleanEx()
> nameEx("bigcor")
> ### * bigcor
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bigcor
> ### Title: Creating very large correlation/covariance matrices
> ### Aliases: bigcor
> ### Keywords: matrix multivariate algebra
> 
> ### ** Examples
> 
> ## Small example to prove similarity
> ## to standard 'cor'. We create a matrix
> ## by subsetting the complete 'ff' matrix.
> MAT <- matrix(rnorm(70000), ncol = 700)
> COR <- bigcor(MAT, size= 2000, fun = "cor")
Warning in split.default(1:NCOL, GROUP) :
  data length is not a multiple of split variable
#1: Correlation of Block 1 and Block 1 (0 x 0) ... 0.005 s
#2: Correlation of Block 1 and Block 2 (0 x 700) ... 0.791 s
#3: Correlation of Block 2 and Block 2 (700 x 700) ... 1.864 s
> COR <- COR[1:nrow(COR), 1:ncol(COR)]
> all.equal(COR, cor(MAT)) # => TRUE
[1] TRUE
> 
> ## Not run: 
> ##D ## Create large matrix.
> ##D MAT <- matrix(rnorm(137500), ncol = 13750)
> ##D COR <- bigcor(MAT, size= 2000, fun = "cor")
> ##D 
> ##D ## Extract submatrix.
> ##D SUB <- COR[1:3000, 1:3000]
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("contribution")
> ### * contribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contribution
> ### Title: Contribution to propagated uncertainty for each variable
> ### Aliases: contribution
> ### Keywords: algebra
> 
> ### ** Examples
> 
> EXPR1 <- expression(x^y)
> x <- c(5, 0.2)
> y <- c(1, 0.1)
> DF1 <- cbind(x, y)
> RES1 <- propagate(expr = EXPR1, data = DF1, type = "stat", 
+                   do.sim = TRUE, verbose = TRUE)
> contribution(RES1)
        x         y 
0.1990606 0.8009394 
> 
> 
> 
> cleanEx()
> nameEx("cor2cov")
> ### * cor2cov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cor2cov
> ### Title: Converting a correlation matrix into a covariance matrix
> ### Aliases: cor2cov
> ### Keywords: matrix multivariate algebra
> 
> ### ** Examples
> 
> ## Example in Annex H.2 from the GUM 2008 manual
> ## (see 'References'), simultaneous resistance
> ## and reactance measurement.
> data(H.2)
> attach(H.2)
> 
> ## Original covariance matrix.
> COV <- cov(H.2)
> ## extract variances
> VAR <- diag(COV)
> 
> ## cor2cov covariance matrix.
> COV2 <- cor2cov(cor(H.2), VAR) 
> 
> ## Equal to original covariance matrix.
> all.equal(COV2, COV)
[1] TRUE
> 
> 
> 
> cleanEx()

detaching ‘H.2’

> nameEx("datasets")
> ### * datasets
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: datasets
> ### Title: Datasets from the GUM "Guide to the expression of uncertainties
> ###   in measurement" (2008)
> ### Aliases: H.2 H.3 H.4
> ### Keywords: datasets
> 
> ### ** Examples
> 
> ## See "Examples" in 'propagate'.
> 
> 
> 
> cleanEx()
> nameEx("fitDistr")
> ### * fitDistr
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitDistr
> ### Title: Fitting distributions to observations/Monte Carlo simulations
> ### Aliases: fitDistr
> ### Keywords: algebra univariate
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Linear example, small error
> ##D ## => family of normal distributions.
> ##D EXPR1 <- expression(x + 2 * y)
> ##D x <- c(5, 0.01)
> ##D y <- c(1, 0.01)
> ##D DF1 <- cbind(x, y)
> ##D RES1 <- propagate(expr = EXPR1, data = DF1, type = "stat", 
> ##D                   do.sim = TRUE, verbose = TRUE)
> ##D fitDistr(RES1)$aic
> ##D 
> ##D ## Ratio example, larger error
> ##D ## => family of skewed distributions.
> ##D EXPR2 <- expression(x/2 * y)
> ##D x <- c(5, 0.1)
> ##D y <- c(1, 0.02)
> ##D DF2 <- cbind(x, y)
> ##D RES2 <- propagate(expr = EXPR2, data = DF2, type = "stat", 
> ##D                   do.sim = TRUE, verbose = TRUE)
> ##D fitDistr(RES2)$aic
> ##D 
> ##D ## Exponential example, large error
> ##D ## => family of log-normal distributions.
> ##D EXPR3 <- expression(x^(2 * y))
> ##D x <- c(5, 0.1)
> ##D y <- c(1, 0.1)
> ##D DF3 <- cbind(x, y)
> ##D RES3 <- propagate(expr = EXPR3, data = DF3, type = "stat", 
> ##D                   do.sim = TRUE, verbose = TRUE)
> ##D fitDistr(RES3)$aic
> ##D 
> ##D ## Rectangular input distributions result
> ##D ## in trapezoidal output distribution.
> ##D A <- runif(100000, 20, 25)
> ##D B <- runif(100000, 3, 3.5)
> ##D DF4 <- cbind(A, B)
> ##D EXPR4 <- expression(A + B)
> ##D RES4 <- propagate(EXPR4, data = DF4, type = "sim", 
> ##D                  use.cov = FALSE, do.sim = TRUE)
> ##D fitDistr(RES4)$aic        
> ##D 
> ##D ## Fitting with 1/counts as weights.
> ##D EXPR5 <- expression(x + 2 * y)
> ##D x <- c(5, 0.05)
> ##D y <- c(1, 0.05)
> ##D DF5 <- cbind(x, y)
> ##D RES5 <- propagate(expr = EXPR5, data = DF5, type = "stat", 
> ##D                   do.sim = TRUE, verbose = TRUE, weights = TRUE)
> ##D fitDistr(RES5)$aic
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("interval")
> ### * interval
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: interval
> ### Title: Uncertainty propagation based on interval arithmetics
> ### Aliases: interval
> ### Keywords: matrix multivariate algebra
> 
> ### ** Examples
> 
> ## Example 1: even squaring of negative interval.
> EXPR1 <- expression(x^2)
> DAT1 <- data.frame(x = c(-1, 1))
> interval(DAT1, EXPR1)
[0, 1]> 
> ## Example 2: A complicated nonlinear model.
> ## Reduce sequence length to 2 => original interval
> ## for quicker evaluation.
> EXPR2 <- expression(C * sqrt((520 * H * P)/(M *(t + 460))))
> H <- c(64, 65)
> M <- c(16, 16.2)
> P <- c(361, 365)
> t <- c(165, 170)
> C <- c(38.4, 38.5)
> DAT2 <- makeDat(EXPR2)
> interval(DAT2, EXPR2, seq = 2)
[1317.494, 1352.277]> 
> ## Example 3: Body Mass Index taken from
> ## http://en.wikipedia.org/w/index.php?title=Interval_arithmetic
> EXPR3 <- expression(m/h^2)
> m <- c(79.5, 80.5)
> h <- c(1.795, 1.805)
> DAT3 <- makeDat(EXPR3)
> interval(DAT3, EXPR3)
[24.40129, 24.98429]> 
> ## Example 4: Linear model.
> EXPR4 <- expression(a * x + b)
> a <- c(1, 2)
> b <- c(5, 7)
> x <- c(2, 3)
> DAT4 <- makeDat(EXPR4)
> interval(DAT4, EXPR4)
[7, 13]> 
> ## Example 5: Overestimation from dependency problem.
> # Original interval with seq = 2 => [1, 7]
> EXPR5 <- expression(x^2 - x + 1)
> x <- c(-2, 1)
> DAT5 <- makeDat(EXPR5)
> interval(DAT5, EXPR5, seq = 2)
[1, 7]> 
> # Refine with large sequence => [0.75, 7]
> interval(DAT5, EXPR5, seq = 100)
[0.7502296, 7]> # Tallies with curve function.
> curve(x^2 - x + 1, -2, 1)
> 
> ## Example 6: Underestimation from dependency problem.
> # Original interval with seq = 2 => [0, 0]
> EXPR6 <- expression(x - x^2)
> x <- c(0, 1)
> DAT6 <- makeDat(EXPR6)
> interval(DAT6, EXPR6, seq = 2)
[0, 0]> 
> # Refine with large sequence => [0, 0.25]
> interval(DAT6, EXPR6, seq = 100)
[0, 0.2499745]> # Tallies with curve function.
> curve(x - x^2, 0, 1)
> 
> 
> 
> cleanEx()
> nameEx("makeDat")
> ### * makeDat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeDat
> ### Title: Create a dataframe from the variables defined in an expression
> ### Aliases: makeDat
> ### Keywords: algebra univariate
> 
> ### ** Examples
> 
> ## Simulating from uniform
> ## and normal distribution,
> ## run 'propagate'.
> EXPR1 <- expression(a + b^c)
> a <- rnorm(100000, 12, 1)
> b <- rnorm(100000, 5, 0.1)
> c <- runif(100000, 6, 7)
> 
> DAT1 <- makeDat(EXPR1)
> propagate(EXPR1, DAT1, type = "sim", cov = FALSE)
Results from error propagation:
  Mean.1   Mean.2     sd.1     sd.2     2.5%    97.5% 
34856.16 38854.01 16786.01 17756.77  3941.31 73733.19 

Results from Monte Carlo simulation:
    Mean       sd   Median      MAD     2.5%    97.5% 
39021.69 18694.42 34736.94 19635.57 15354.95 80642.76 
> 
> 
> 
> cleanEx()
> nameEx("makeDerivs")
> ### * makeDerivs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: makeDerivs
> ### Title: Utility functions for creating Gradient- and Hessian-like
> ###   matrices with symbolic derivatives and evaluating them in an
> ###   environment
> ### Aliases: makeGrad makeHess evalDerivs
> ### Keywords: array algebra multivariate
> 
> ### ** Examples
> 
> EXPR <- expression(a^b + sin(c))
> ENVIR <- list(a = 2, b = 3, c = 4)
> 
> ## First-order partial derivatives: Gradient.
> GRAD <- makeGrad(EXPR) 
> 
> ## This will evaluate the Gradient.
> evalDerivs(GRAD, ENVIR)
     [,1]     [,2]       [,3]
[1,]   12 5.545177 -0.6536436
> 
> ## Second-order partial derivatives: Hessian.
> HESS <- makeHess(EXPR) 
> 
> ## This will evaluate the Hessian.
> evalDerivs(HESS, ENVIR)
         [,1]      [,2]      [,3]
[1,] 12.00000 12.317766 0.0000000
[2,] 12.31777  3.843624 0.0000000
[3,]  0.00000  0.000000 0.7568025
> 
> ## Change derivatives order.
> GRAD <- makeGrad(EXPR, order = c(2,1,3)) 
> evalDerivs(GRAD, ENVIR)
         [,1] [,2]       [,3]
[1,] 5.545177   12 -0.6536436
> 
> 
> 
> cleanEx()
> nameEx("matrixStats")
> ### * matrixStats
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrixStats
> ### Title: Fast column- and row-wise versions of variance coded in C++
> ### Aliases: colVarsC rowVarsC
> ### Keywords: univar
> 
> ### ** Examples
> 
> ## Speed comparison on large matrix.
> ## ~ 110x speed increase!
> ## Not run: 
> ##D MAT <- matrix(rnorm(10 * 500000), ncol = 10)
> ##D system.time(RES1 <- apply(MAT, 1, var))
> ##D 
> ##D system.time(RES2 <- rowVarsC(MAT))
> ##D 
> ##D all.equal(RES1, RES2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("mixCov")
> ### * mixCov
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: mixCov
> ### Title: Mixing covariances matrices, raw data, summary data or error
> ###   values into a single covariance matrix
> ### Aliases: mixCov
> ### Keywords: array algebra multivariate
> 
> ### ** Examples
> 
> #######################################################
> ## Example in Annex H.4 from the GUM 2008 manual
> ## (see 'References'), measurement of activity.
> ## This will give exactly the same values as Table H.8.
> data(H.4)
> attach(H.4)
> T0 <- 60
> lambda <- 1.25894E-4
> Rx <- ((Cx - Cb)/60) * exp(lambda * tx)
> Rs <- ((Cs - Cb)/60) * exp(lambda * ts)
> 
> mRx <- mean(Rx)
> sRx <- sd(Rx)/sqrt(6)
> mRx
[1] 652.6007
> sRx
[1] 6.416466
> 
> mRs <- mean(Rs)
> sRs <- sd(Rs)/sqrt(6)
> mRs
[1] 206.0881
> sRs
[1] 3.792532
> 
> R <- Rx/Rs
> mR <- mean(R)
> sR <- sd(R)/sqrt(6)
> mR
[1] 3.170186
> sR
[1] 0.04563322
> 
> cor(Rx, Rs)
[1] 0.6459873
> 
> ## Definition as in H.4.3.
> As <- c(0.1368, 0.0018)
> ms <- c(5.0192, 0.005)
> mx <- c(5.0571, 0.001)
> 
> ## We have to scale Rs/Rx by sqrt(6) to get the 
> ## corresponding covariances.
> Rs <- Rs/sqrt(6)
> Rx <- Rx/sqrt(6)
> 
> ## Here we mix the raw data in matrix format 
> ## and the summary data of the variables.
> COV <- mixCov(cbind(Rs, Rx), As, ms, mx)
> COV
         Rs       Rx       As      ms    mx
Rs 14.38330 15.71988 0.00e+00 0.0e+00 0e+00
Rx 15.71988 41.17103 0.00e+00 0.0e+00 0e+00
As  0.00000  0.00000 3.24e-06 0.0e+00 0e+00
ms  0.00000  0.00000 0.00e+00 2.5e-05 0e+00
mx  0.00000  0.00000 0.00e+00 0.0e+00 1e-06
> 
> ## Prepare the data for 'propagate'.
> MEANS <- c(mRs, mRx, As[1], ms[1], mx[1])
> SDS <- c(sRs, sRx, As[2], ms[2], mx[2])
> DAT <- rbind(MEANS, SDS)
> colnames(DAT) <- c("Rs", "Rx", "As", "ms", "mx")
> 
> ## This will give exactly the same values as 
> ## in H.4.3/H.4.3.1.
> EXPR <- expression(As * (ms/mx) * (Rx/Rs))
> RES <- propagate(EXPR, data = DAT, type = "stat", 
+                  use.cov = COV, do.sim = TRUE)
> 
> RES$prop
     Mean.1      Mean.2        sd.1        sd.2        2.5%       97.5% 
0.429945823 0.430041188 0.008333849 0.008335543 0.413699803 0.446453451 
> RES$sim
       Mean          sd      Median         MAD        2.5%       97.5% 
0.430041271 0.008339475 0.429952163 0.008317271 0.413900418 0.446725443 
> 
> 
> 
> cleanEx()

detaching ‘H.4’

> nameEx("moments")
> ### * moments
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: moments
> ### Title: Skewness and (excess) Kurtosis of a vector of values
> ### Aliases: skewness kurtosis
> ### Keywords: array algebra multivariate
> 
> ### ** Examples
> 
> X <- rnorm(100, 20, 2)
> skewness(X)
[1] -0.0722319
> kurtosis(X)
[1] 0.007653206
> 
> 
> 
> cleanEx()
> nameEx("numDerivs")
> ### * numDerivs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: numDerivs
> ### Title: Functions for creating Gradient and Hessian matrices by
> ###   numerical differentiation (Richardson's method) of the partial
> ###   derivatives
> ### Aliases: numGrad numHess
> ### Keywords: array algebra multivariate
> 
> ### ** Examples
> 
> ## Check for equality of symbolic  
> ## and numerical derivatives.
> EXPR <- expression(2^x + sin(2 * y) - cos(z))
> x <- 5
> y <- 10
> z <- 20
> 
> symGRAD <- evalDerivs(makeGrad(EXPR))
> numGRAD <- numGrad(EXPR)
> all.equal(symGRAD, numGRAD)
[1] TRUE
> 
> symHESS <- evalDerivs(makeHess(EXPR))
> numHESS <- numHess(EXPR)
> all.equal(symHESS, numHESS)
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("plot.propagate")
> ### * plot.propagate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.propagate
> ### Title: Plotting function for 'propagate' objects
> ### Aliases: plot.propagate
> ### Keywords: models nonlinear
> 
> ### ** Examples
> 
> EXPR1 <- expression(x^2 * sin(y))
> x <- c(5, 0.01)
> y <- c(1, 0.01)
> DF1 <- cbind(x, y)
> RES1 <- propagate(expr = EXPR1, data = DF1, type = "stat", 
+                   do.sim = TRUE, verbose = TRUE)
> plot(RES1)
> 
> 
> 
> cleanEx()
> nameEx("predictNLS")
> ### * predictNLS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictNLS
> ### Title: Confidence intervals for nonlinear models based on uncertainty
> ###   propagation
> ### Aliases: predictNLS
> ### Keywords: array algebra multivariate
> 
> ### ** Examples
> 
> ## Example from ?nls.
> DNase1 <- subset(DNase, Run == 1)
> fm3DNase1 <- nls(density ~ Asym/(1 + exp((xmid - log(conc))/scal)),
+                  data = DNase1, start = list(Asym = 3, xmid = 0, scal = 1))
> 
> ## Using a single predictor value without error.
> PROP1 <- predictNLS(fm3DNase1, newdata = data.frame(conc = 2))
Propagating predictor value #1 ...
> PRED1 <- predict(fm3DNase1, newdata = data.frame(conc = 2))
> PROP1$summary
  Prop.Mean.1 Prop.Mean.2   Prop.sd.1   Prop.sd.2 Prop.2.5% Prop.97.5%
1   0.7480472   0.7481514 0.008042515 0.008052591 0.7307548  0.7655479
   Sim.Mean      Sim.sd Sim.Median     Sim.MAD  Sim.2.5% Sim.97.5%
1 0.7481505 0.008041165  0.7481565 0.008040288 0.7323719 0.7639674
> PRED1
[1] 0.7480472
> ## => Prop.Mean.1 equal to PRED1
> 
> ## Not run: 
> ##D ## Using a sequence of predictor values without error.
> ##D CONC <- seq(1, 12, by = 1)
> ##D PROP2 <- predictNLS(fm3DNase1, newdata = data.frame(conc = CONC))
> ##D PRED2 <- predict(fm3DNase1, newdata = data.frame(conc = CONC))
> ##D PROP2$summary
> ##D PRED2
> ##D ## => Prop.Mean.1 equal to PRED2
> ##D 
> ##D ## Using a sequence of predictor values with error.
> ##D DAT <- data.frame(conc = CONC, error = rnorm(12, 0, 0.1))
> ##D PROP3 <- predictNLS(fm3DNase1, newdata = DAT)
> ##D PRED3 <- predict(fm3DNase1, newdata = DAT)
> ##D PROP3$summary
> ##D PRED3
> ##D ## => Prop.Mean.1 equal to PRED3
> ##D 
> ##D ## Plot predicted and confidence values from 
> ##D ## first-/second-order Taylor expansion 
> ##D ## and Monte Carlo simulation.
> ##D plot(DNase1$conc, DNase1$density)
> ##D lines(DNase1$conc, fitted(fm3DNase1), lwd = 2, col = 1)
> ##D points(CONC, PROP2$summary[, 1], col = 2, pch = 16)
> ##D lines(CONC, PROP2$summary[, 5], col = 2)
> ##D lines(CONC, PROP2$summary[, 6], col = 2)
> ## End(Not run)
> 
> ## Using multiple predictor values
> ## 1: Setup of response values
> ## with gaussian error of 10%.
> x <- seq(1, 10, by = 0.01)
> y <- seq(10, 1, by = -0.01)
> a <- 2
> b <- 5
> c <- 10
> z <- a * exp(b * x)^sin(y/c)
> z <- z + sapply(z, function(x) rnorm(1, x, 0.10 * x))
> ## 2: Fit 'nls' model.
> MOD <- nls(z ~ a * exp(b * x)^sin(y/c), 
+              start = list(a = 2, b = 5, c = 10))
> ## 3: newdata without errors and prediction.
> DAT1 <- data.frame(x = 4, y = 3)
> PROP4 <- predictNLS(MOD, newdata = DAT1)
Propagating predictor value #1 ...
> PROP4$summary
  Prop.Mean.1 Prop.Mean.2 Prop.sd.1 Prop.sd.2 Prop.2.5% Prop.97.5% Sim.Mean
1    1444.777    1442.775  54.96645  55.04017  1334.753   1550.798 1442.775
    Sim.sd Sim.Median  Sim.MAD Sim.2.5% Sim.97.5%
1 55.09039   1444.558 54.91878 1329.912  1545.241
> ## 4: newdata with errors and prediction.
> DAT2 <- data.frame(x = 4, y = 3, error.x = 0.2, error.y = 0.1)
> PROP5 <- predictNLS(MOD, newdata = DAT2)
Propagating predictor value #1 ...
Error in `rownames<-`(`*tmp*`, value = make.unique(nameVEC)) : 
  attempt to set 'rownames' on an object with no dimensions
Calls: predictNLS -> mixCov -> makeCov -> rownames<-
Execution halted
