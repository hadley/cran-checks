
R Under development (unstable) (2018-01-02 r74022) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "lambda.r"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('lambda.r')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("UseFunction")
> ### * UseFunction
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: UseFunction
> ### Title: Primary dispatcher for functional programming
> ### Aliases: UseFunction NewObject
> ### Keywords: methods programming
> 
> ### ** Examples
> 
> # Note that these are trivial examples for pedagogical purposes. Due to their
> # trivial nature, most of these examples can be implemented more concisely
> # using built-in R features.
> 
> 
> reciprocal(x) %::% numeric : numeric
> reciprocal(x) %when% {
+   x != 0
+ } %as% {
+   1 / x
+ }
> 
> reciprocal(x) %::% character : numeric
> reciprocal(x) %as% {
+   reciprocal(as.numeric(x))
+ }
> 
> seal(reciprocal)
> 
> print(reciprocal)
<function>
[[1]]
reciprocal(x) %::% numeric:numeric 
reciprocal(x) %when% {
    x != 0
} %as% ...
[[2]]
reciprocal(x) %::% character:numeric 
reciprocal(x) %as% ...
> reciprocal(4)
[1] 0.25
> reciprocal("4")
[1] 0.25
> 
> 
> 
> 
> cleanEx()
> nameEx("duck")
> ### * duck
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: duck-typing
> ### Title: Functions for duck typing
> ### Aliases: %isa% %hasa% %hasall%
> ### Keywords: methods programming
> 
> ### ** Examples
> 
> 5 %isa% numeric
[1] TRUE
> 
> Point(r,theta, 'polar') %as% {
+   o <- list(r=r,theta=theta)
+   o@system <- 'polar'
+   o
+ }
> 
> p <- Point(5, pi/2, 'polar')
> p 
$r
[1] 5

$theta
[1] 1.570796

attr(,"system")
[1] "polar"
attr(,"class")
[1] "Point" "list" 
> 
> 
> 
> 
> cleanEx()
> nameEx("framework")
> ### * framework
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: %as%
> ### Title: Define functions and type constructors in lambda.r
> ### Aliases: %as% %:=% %::% EMPTY seal
> ### Keywords: methods programming
> 
> ### ** Examples
> 
> # Type constraints are optional and include the return type as the 
> # final type
> reciprocal(x) %::% numeric : numeric
> reciprocal(0) %as% stop("Division by 0 not allowed")
> 
> # The type constraint is still valid for this function clause
> reciprocal(x) %when% {
+   # Guard statements can be added in succession
+   x != 0
+   # Attributes can be accessed using '@' notation
+   is.null(x@dummy.attribute)
+ } %as% {
+   # This is the body of the function clause
+   1 / x
+ }
> 
> # This new type constraint applies from this point on
> reciprocal(x) %::% character : numeric
> reciprocal(x) %as% {
+   reciprocal(as.numeric(x))
+ }
> 
> # Seal the function so no new definitions are allowed
> seal(reciprocal)
> 
> print(reciprocal)
<function>
[[1]]
reciprocal(x) %::% numeric:numeric 
reciprocal(0) %as% ...
[[2]]
reciprocal(x) %::% numeric:numeric 
reciprocal(x) %when% {
    x != 0
    is.null(x@dummy.attribute)
} %as% ...
[[3]]
reciprocal(x) %::% character:numeric 
reciprocal(x) %as% ...
> reciprocal(4)
[1] 0.25
> reciprocal("4")
[1] 0.25
> 
> 
> 
> 
> cleanEx()
> nameEx("introspection")
> ### * introspection
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: introspection
> ### Title: Introspection for lambda.r
> ### Aliases: describe debug.lr undebug.lr undebug.all is.debug which.debug
> ###   print.lambdar.fun print.lambdar.type
> ### Keywords: methods programming
> 
> ### ** Examples
> 
> ## Not run: 
> ##D f(x) ##D 
> ##D debug.lr(f)
> ##D which.debug()
> ##D undebug.lr(f)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("lambda.r-package")
> ### * lambda.r-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: lambda.r-package
> ### Title: Modeling Data with Functional Programming
> ### Aliases: lambda.r-package lambda.r
> ### Keywords: package programming
> 
> ### ** Examples
> 
> is.wholenumber <-
+   function(x, tol = .Machine$double.eps^0.5)  abs(x - round(x)) < tol
> 
> ## Use built in types for type checking
> fib(n) %::% numeric : numeric
> fib(0) %as% 1
> fib(1) %as% 1
> fib(n) %when% {
+   is.wholenumber(n)
+ } %as% {
+   fib(n-1) + fib(n-2)
+ }
> 
> fib(5)
[1] 8
> 
> 
> ## Using custom types
> Integer(x) %when% { is.wholenumber(x) } %as% x
> 
> fib.a(n) %::% Integer : Integer
> fib.a(0) %as% Integer(1)
> fib.a(1) %as% Integer(1)
> fib.a(n) %as% { Integer(fib.a(n-1) + fib.a(n-2)) }
> 
> fib.a(Integer(5))
[1] 8
attr(,"class")
[1] "Integer" "numeric"
> 
> 
> ## Newton-Raphson optimization
> converged <- function(x1, x0, tolerance=1e-6) abs(x1 - x0) < tolerance
> minimize <- function(x0, algo, max.steps=100)
+ {
+   step <- 0
+   old.x <- x0
+   while (step < max.steps)
+   {
+     new.x <- iterate(old.x, algo)
+     if (converged(new.x, old.x)) break
+     old.x <- new.x
+   }
+   new.x
+ }
> 
> iterate(x, algo) %::% numeric : NewtonRaphson : numeric
> iterate(x, algo) %as% { x - algo$f1(x) / algo$f2(x) }
> 
> iterate(x, algo) %::% numeric : GradientDescent : numeric
> iterate(x, algo) %as% { x - algo$step * algo$f1(x) }
> 
> NewtonRaphson(f1, f2) %as% list(f1=f1, f2=f2)
> GradientDescent(f1, step=0.01) %as% list(f1=f1, step=step)
> 
> 
> fx <- function(x) x^2 - 4
> f1 <- function(x) 2*x
> f2 <- function(x) 2
> 
> algo <- NewtonRaphson(f1,f2)
> minimize(3, algo)
[1] 0
> 
> algo <- GradientDescent(f1, step=0.1)
> minimize(3, algo)
[1] 3.677989e-06
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.888 0.008 0.896 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
