
R Under development (unstable) (2019-02-10 r76083) -- "Unsuffered Consequences"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(testthat)
> test_check("SpaDES.core")
Loading required package: SpaDES.core
Loading required package: quickPlot
Loading required package: reproducible

Attaching package: 'SpaDES.core'

The following objects are masked from 'package:stats':

    end, start

The following object is masked from 'package:utils':

    citation


 *** caught segfault ***
address (nil), cause 'memory not mapped'

Traceback:
 1: RandomFieldsUtils::RFoptions()
 2: internal.rfoptions(xyz_notation = length(y) != 0, expected_number_simu = n,     ..., RELAX = isFormulaModel(model))
 3: RandomFields::RFsimulate(model, y = 1:ncSpeedup, x = 1:nrSpeedup,     grid = TRUE, ...)
 4: raster(RandomFields::RFsimulate(model, y = 1:ncSpeedup, x = 1:nrSpeedup,     grid = TRUE, ...))
 5: gaussMap(template, scale = 300, var = 0.03, speedup = speedup,     inMemory = inMemory)
 6: Init(sim)
 7: get(moduleCall, envir = fnEnv)(sim, cur[["eventTime"]], cur[["eventType"]])
 8: eval(fnCallAsExpr)
 9: eval(fnCallAsExpr)
10: .runEvent(sim, cacheIt, debug, moduleCall, fnEnv, cur, notOlderThan)
11: doEvent(sim, debug = debug, notOlderThan = notOlderThan)
12: FUN(...)
13: FUN(...)
14: Cache(FUN = FUN, ..., notOlderThan = notOlderThan, omitArgs = omitArgs)
15: eval(mc, env)
16: eval(mc, env)
17: standardGeneric("Cache")
18: (new("standardGeneric", .Data = function (FUN, ..., notOlderThan = NULL,     .objects = NULL, outputObjects = NULL, algo = "xxhash64",     cacheRepo = NULL, length = getOption("reproducible.length",         Inf), compareRasterFileLength, userTags = c(), digestPathContent,     omitArgs = NULL, classOptions = list(), debugCache = character(),     sideEffect = FALSE, makeCopy = FALSE, quick = getOption("reproducible.quick",         FALSE), verbose = getOption("reproducible.verbose", 0),     cacheId = NULL, useCache = getOption("reproducible.useCache",         TRUE), showSimilar = NULL) standardGeneric("Cache"), generic = "Cache", package = "reproducible",     group = list(), valueClass = character(0), signature = "...",     default = new("derivedDefaultMethod", .Data = function (FUN,         ..., notOlderThan = NULL, .objects = NULL, outputObjects = NULL,         algo = "xxhash64", cacheRepo = NULL, length = getOption("reproducible.length",             Inf), compareRasterFileLength, userTags = c(), digestPathContent,         omitArgs = NULL, classOptions = list(), debugCache = character(),         sideEffect = FALSE, makeCopy = FALSE, quick = getOption("reproducible.quick",             FALSE), verbose = getOption("reproducible.verbose",             0), cacheId = NULL, useCache = getOption("reproducible.useCache",             TRUE), showSimilar = NULL)     {        archivist::cache(cacheRepo, FUN, ..., notOlderThan, algo,             userTags = userTags)    }, target = new("signature", .Data = "ANY", names = "FUN",         package = "methods"), defined = new("signature", .Data = "ANY",         names = "FUN", package = "methods"), generic = "Cache"),     skeleton = (new("derivedDefaultMethod", .Data = function (FUN,         ..., notOlderThan = NULL, .objects = NULL, outputObjects = NULL,         algo = "xxhash64", cacheRepo = NULL, length = getOption("reproducible.length",             Inf), compareRasterFileLength, userTags = c(), digestPathContent,         omitArgs = NULL, classOptions = list(), debugCache = character(),         sideEffect = FALSE, makeCopy = FALSE, quick = getOption("reproducible.quick",             FALSE), verbose = getOption("reproducible.verbose",             0), cacheId = NULL, useCache = getOption("reproducible.useCache",             TRUE), showSimilar = NULL)     {        archivist::cache(cacheRepo, FUN, ..., notOlderThan, algo,             userTags = userTags)    }, target = new("signature", .Data = "ANY", names = "FUN",         package = "methods"), defined = new("signature", .Data = "ANY",         names = "FUN", package = "methods"), generic = "Cache"))(FUN,         ..., notOlderThan = notOlderThan, .objects = .objects,         outputObjects = outputObjects, algo = algo, cacheRepo = cacheRepo,         length = length, compareRasterFileLength = compareRasterFileLength,         userTags = userTags, digestPathContent = digestPathContent,         omitArgs = omitArgs, classOptions = classOptions, debugCache = debugCache,         sideEffect = sideEffect, makeCopy = makeCopy, quick = quick,         verbose = verbose, cacheId = cacheId, useCache = useCache,         showSimilar = showSimilar)))(base::quote(new("nonstandardGenericFunction",     .Data = function (sim, debug = getOption("spades.debug"),         progress = NA, cache, .plotInitialTime = NULL, .saveInitialTime = NULL,         notOlderThan = NULL, ...)     {        standardGeneric("spades")    }, generic = "spades", package = "SpaDES.core", group = list(),     valueClass = character(0), signature = c("sim", "debug",     "progress", "cache", ".plotInitialTime", ".saveInitialTime",     "notOlderThan"), default = NULL, skeleton = (function (sim,         debug = getOption("spades.debug"), progress = NA, cache,         .plotInitialTime = NULL, .saveInitialTime = NULL, notOlderThan = NULL,         ...)     stop("invalid call in method dispatch to 'spades' (no default method)",         domain = NA))(sim, debug, progress, cache, .plotInitialTime,         .saveInitialTime, notOlderThan, ...))), sim = base::quote(new("simList",     modules = list("checkpoint", "save", "progress", "load",         `/var/scratch2ro/tomas/cran/rlibro/lib/SpaDES.core/sampleModules/randomLandscapes` = "randomLandscapes",         `/var/scratch2ro/tomas/cran/rlibro/lib/SpaDES.core/sampleModules/fireSpread` = "fireSpread",         `/var/scratch2ro/tomas/cran/rlibro/lib/SpaDES.core/sampleModules/caribouMovement` = "caribouMovement"),     params = list(.checkpoint = list(file = NULL, interval = NA_real_),         .progress = list(interval = NA_real_, type = NA_character_),         .globals = list(burnStats = "nPixelsBurned", stackName = "landscape"),         randomLandscapes = list(.plotInitialTime = NA_real_,             .plotInterval = NA_real_, .saveInitialTime = NA_real_,             .saveInterval = NA_real_, .useCache = FALSE, inRAM = FALSE,             nx = 100L, ny = 100L, stackName = "landscape"), fireSpread = list(            .plotInitialTime = NA_real_, .plotInterval = 1, .saveInitialTime = NA_real_,             .saveInterval = NA_real_, its = 1e+06, nFires = 10L,             persistprob = 0, returnInterval = 1, spreadprob = 0.225,             stackName = "landscape", startTime = 1), caribouMovement = list(            .plotInitialTime = NA_real_, .plotInterval = 1, .saveInitialTime = NA_real_,             .saveInterval = NA_real_, N = 100L, moveInitialTime = 1,             moveInterval = 1, stackName = "landscape", torus = FALSE)),     events = list(list(eventTime = 0, moduleName = "checkpoint",         eventType = "init", eventPriority = 5), list(eventTime = 0,         moduleName = "save", eventType = "init", eventPriority = 5),         list(eventTime = 0, moduleName = "progress", eventType = "init",             eventPriority = 5), list(eventTime = 0, moduleName = "load",             eventType = "init", eventPriority = 5), list(eventTime = 0,             moduleName = "randomLandscapes", eventType = "init",             eventPriority = 5), list(eventTime = 0, moduleName = "fireSpread",             eventType = "init", eventPriority = 5), list(eventTime = 0,             moduleName = "caribouMovement", eventType = "init",             eventPriority = 5)), current = list(), completed = list(),     depends = new(".simDeps", dependencies = list(randomLandscapes = new(".moduleDeps",         name = "randomLandscapes", description = "Generate RasterStack of random maps representative of a forest landscape (DEM, forestAge, forestCover, habitatQuality, percentPine). Requires a global simulation parameter `stackName` be set.",         keywords = c("random map", "random landscape"), childModules = character(0),         authors = list(list(given = c("Alex", "M"), family = "Chubaty",             role = c("aut", "cre"), email = "alexander.chubaty@canada.ca",             comment = NULL), list(given = c("Eliot", "J", "B"        ), family = "McIntire", role = c("aut", "cre"), email = "eliot.mcintire@canada.ca",             comment = NULL)), version = list(c(1L, 6L, 0L)),         spatialExtent = new("Extent", xmin = NA_real_, xmax = NA_real_,             ymin = NA_real_, ymax = NA_real_), timeframe = list(            sec = c(NA_real_, NA_real_), min = c(NA_integer_,             NA_integer_), hour = c(NA_integer_, NA_integer_),             mday = c(NA_integer_, NA_integer_), mon = c(NA_integer_,             NA_integer_), year = c(NA_integer_, NA_integer_),             wday = c(NA_integer_, NA_integer_), yday = c(NA_integer_,             NA_integer_), isdst = c(-1L, -1L), zone = c("", ""            ), gmtoff = c(NA_integer_, NA_integer_)), timeunit = "year",         citation = list(), documentation = list(), reqdPkgs = list(            "raster", "RColorBrewer", "SpaDES.tools"), parameters = list(            paramName = c("inRAM", "nx", "ny", "stackName", ".plotInitialTime",             ".plotInterval", ".saveInitialTime", ".saveInterval",             ".useCache"), paramClass = c("logical", "numeric",             "numeric", "character", "numeric", "numeric", "numeric",             "numeric", "logical"), default = list(FALSE, 100L,                 100L, "landscape", 0, NA_real_, NA_real_, NA_real_,                 FALSE), min = list(TRUE, 10L, 10L, NA, 0, NA,                 NA, NA, c("init", "plot")), max = list(FALSE,                 500L, 500L, NA, NA, NA, NA, NA, NA), paramDesc = c("should the raster be stored in memory?",             "size of map (number of pixels) in the x dimension",             "size of map (number of pixels) in the y dimension",             "name of the RasterStack", "time to schedule first plot event",             "time interval between plot events", "time to schedule first save event",             "time interval between save events", "should the module result be cached for future use"            )), inputObjects = list(objectName = NA_character_,             objectClass = NA_character_, desc = NA_character_,             sourceURL = NA_character_, other = list(NA_character_)),         outputObjects = list(objectName = "landscape", objectClass = "RasterStack",             desc = NA_character_, other = list(NA_character_))),         fireSpread = new(".moduleDeps", name = "fireSpread",             description = "Simulate fire ignition and spread on a landscape, where spread probability varies according to percent pine. Fire size statistics are collected immediately after each burn event. Requires a global simulation parameter `stackName` be set.",             keywords = c("fire", "percolation model", "spread algorithm"            ), childModules = character(0), authors = list(list(                given = c("Alex", "M"), family = "Chubaty", role = c("aut",                 "cre"), email = "alexander.chubaty@canada.ca",                 comment = NULL), list(given = c("Eliot", "J",             "B"), family = "McIntire", role = c("aut", "cre"),                 email = "eliot.mcintire@canada.ca", comment = NULL),                 list(given = "Steve", family = "Cumming", role = "aut",                   email = "Steve.Cumming@sbf.ulaval.ca", comment = NULL)),             version = list(c(1L, 6L, 0L)), spatialExtent = new("Extent",                 xmin = NA_real_, xmax = NA_real_, ymin = NA_real_,                 ymax = NA_real_), timeframe = list(sec = c(NA_real_,             NA_real_), min = c(NA_integer_, NA_integer_), hour = c(NA_integer_,             NA_integer_), mday = c(NA_integer_, NA_integer_),                 mon = c(NA_integer_, NA_integer_), year = c(NA_integer_,                 NA_integer_), wday = c(NA_integer_, NA_integer_                ), yday = c(NA_integer_, NA_integer_), isdst = c(-1L,                 -1L), zone = c("", ""), gmtoff = c(NA_integer_,                 NA_integer_)), timeunit = "year", citation = list(),             documentation = list(), reqdPkgs = list("methods",                 "raster", "RColorBrewer", "SpaDES.tools"), parameters = list(                paramName = c("stackName", "nFires", "its", "persistprob",                 "returnInterval", "spreadprob", "startTime",                 ".plotInitialTime", ".plotInterval", ".saveInitialTime",                 ".saveInterval"), paramClass = c("character",                 "numeric", "numeric", "numeric", "numeric", "numeric",                 "numeric", "numeric", "numeric", "numeric", "numeric"                ), default = list("landscape", 10L, 1e+06, 0,                   1, 0.225, 1, 0, 1, NA_real_, NA_real_), min = list(                  NA, 1L, 1e+06, 0, 1, 0.05, 0, 0, 1, NA, NA),                 max = list(NA, 100L, 1e+06, 1, 1, 0.5, 1, 2,                   1, NA, NA), paramDesc = c("name of the RasterStack",                 "number of fires to initiate", "number of iterations for fire spread",                 "probability of fire persisting in a pixel",                 "fire return interval", "probability of fire spreading into a pixel",                 "time of initial fire ignition", "time to schedule first plot event",                 "time interval between plot events", "time to schedule first save event",                 "time interval between save events")), inputObjects = list(                objectName = c("landscape", "nPixelsBurned"),                 objectClass = c("RasterStack", "numeric"), desc = c(NA_character_,                 NA_character_), sourceURL = c(NA_character_,                 NA_character_)), outputObjects = list(objectName = c("landscape",             "nPixelsBurned"), objectClass = c("RasterStack",             "numeric"), desc = c(NA_character_, NA_character_            ), other = list(NA_character_, NA_character_))),         caribouMovement = new(".moduleDeps", name = "caribouMovement",             description = "Simulate caribou movement via correlated random walk.",             keywords = c("caribou", "individual based movement model",             "correlated random walk"), childModules = character(0),             authors = list(list(given = c("Eliot", "J", "B"),                 family = "McIntire", role = c("aut", "cre"),                 email = "eliot.mcintire@canada.ca", comment = NULL)),             version = list(c(1L, 6L, 0L)), spatialExtent = new("Extent",                 xmin = NA_real_, xmax = NA_real_, ymin = NA_real_,                 ymax = NA_real_), timeframe = list(sec = c(NA_real_,             NA_real_), min = c(NA_integer_, NA_integer_), hour = c(NA_integer_,             NA_integer_), mday = c(NA_integer_, NA_integer_),                 mon = c(NA_integer_, NA_integer_), year = c(NA_integer_,                 NA_integer_), wday = c(NA_integer_, NA_integer_                ), yday = c(NA_integer_, NA_integer_), isdst = c(-1L,                 -1L), zone = c("", ""), gmtoff = c(NA_integer_,                 NA_integer_)), timeunit = "month", citation = list(),             documentation = list(), reqdPkgs = list("grid", "raster",                 "sp", "stats", "SpaDES.tools"), parameters = list(                paramName = c("stackName", "moveInitialTime",                 "moveInterval", "N", "torus", ".plotInitialTime",                 ".plotInterval", ".saveInitialTime", ".saveInterval"                ), paramClass = c("character", "numeric", "numeric",                 "numeric", "logical", "numeric", "numeric", "numeric",                 "numeric"), default = list("landscape", 1, 1,                   100L, FALSE, 0, 1, NA_real_, NA_real_), min = list(                  NA, 1, 1, 10L, FALSE, -Inf, -Inf, -Inf, -Inf),                 max = list(NA, 1, 1, 1000L, TRUE, Inf, Inf, Inf,                   Inf), paramDesc = c("name of the RasterStack",                 "time to schedule first movement event", "time interval between movoment events",                 "initial number of caribou", "should the map wrap around like a torus?",                 "time to schedule first plot event", "time interval between plot events",                 "time to schedule first save event", "time interval between save events"                )), inputObjects = list(objectName = "landscape",                 objectClass = "RasterStack", desc = "layername = \"habitatQuality\"",                 sourceURL = NA_character_), outputObjects = list(                objectName = "caribou", objectClass = "SpatialPointsDataFrame",                 desc = NA_character_)))), simtimes = list(current = 0,         start = 0, end = 31557600, timeunit = "year"), inputs = list(        file = character(0), fun = character(0), package = character(0),         objectName = character(0), loadTime = numeric(0), loaded = logical(0),         arguments = list(), intervals = numeric(0)), outputs = list(        objectName = c("landscape", "caribou"), file = c("/var/scratch2/tomas/tmp/Rtmp9slTPs/D9P601/rep1/landscape_year1.rds",         "/var/scratch2/tomas/tmp/Rtmp9slTPs/D9P601/rep1/caribou_year1.rds"        ), fun = c("saveRDS", "saveRDS"), package = c("base",         "base"), saveTime = c(1, 1), saved = c(NA, NA), arguments = c(NA,         NA)), paths = list(cachePath = "/var/scratch2/tomas/tmp/Rtmp9slTPs/D9P601",         inputPath = "/var/scratch2/tomas/tmp/RtmpxaOcej/SpaDES/inputs",         modulePath = "/var/scratch2ro/tomas/cran/rlibro/lib/SpaDES.core/sampleModules",         outputPath = "/var/scratch2/tomas/tmp/Rtmp9slTPs/D9P601/rep1"),     .envir = <environment>, .xData = <environment>)), debug = base::quote(FALSE),     progress = base::quote(NA), .plotInitialTime = base::quote(NULL),     .saveInitialTime = base::quote(NULL), omitArgs = base::quote(c("progress",     "debug", ".plotInitialTime", ".saveInitialTime", "notOlderThan"    )), notOlderThan = base::quote(NULL), replicate = base::quote(1L))
19: do.call(quote = TRUE, Cache, args = append(list(spades, sim = sim,     debug = debug, progress = progress, .plotInitialTime = .plotInitialTime,     .saveInitialTime = .saveInitialTime, omitArgs = omitArgs,     notOlderThan = notOlderThan), dots))
20: spades(sim_, replicate = ind, ...)
21: spades(sim_, replicate = ind, ...)
22: FUN(X[[i]], ...)
23: (function (X, FUN, ...) {    FUN <- match.fun(FUN)    if (!is.vector(X) || is.object(X))         X <- as.list(X)    .Internal(lapply(X, FUN))})(X = 1:2, FUN = function (ind, ...) {    mod <- strsplit(names(factorialExp), split = "\\.") %>% sapply(function(x) x[1])    param <- strsplit(names(factorialExp), split = "\\.") %>%         sapply(function(x) x[2])    param[is.na(param)] <- ""    paramValues <- factorialExp[ind, ]    whNotExpLevel <- which(colnames(paramValues) != "expLevel")    if (length(whNotExpLevel) < length(paramValues)) {        mod <- mod[whNotExpLevel]        param <- param[whNotExpLevel]        paramValues <- paramValues[whNotExpLevel]    }    whNotRepl <- which(colnames(paramValues) != "replicate")    if (length(whNotRepl) < length(paramValues)) {        repl <- paramValues$replicate        mod <- mod[whNotRepl]        param <- param[whNotRepl]        paramValues <- paramValues[whNotRepl]    }    notNA <- which(!is.na(paramValues))    if (length(notNA) < length(mod)) {        mod <- mod[notNA]        param <- param[notNA]        paramValues <- paramValues[notNA]    }    sim_ <- Copy(sim)    experimentDF <- data.frame(module = character(0), param = character(0),         val = I(list()), modules = character(0), input = data.frame(),         object = character(0), expLevel = numeric(0), stringsAsFactors = FALSE)    for (x in seq_along(mod)) {        if (any(mod != "modules")) {            y <- factorialExp[ind, names(paramValues)[x]]            if (!is.na(y) & (mod[x] != "modules")) {                val <- params[[mod[x]]][[param[[x]]]][[y]]                params(sim_)[[mod[x]]][[param[[x]]]] <- val                experimentDF <- rbindlist(l = list(experimentDF,                   data.frame(module = if (!(mod[x] %in% c("input",                     "object"))) mod[x] else NA, param = if (!(mod[x] %in%                     c("input", "object"))) param[x] else NA,                     val = if (!(mod[x] %in% c("input", "object"))) I(list(val)) else list(NA),                     modules = paste0(unlist(modules[factorialExp[ind,                       "modules"]]), collapse = ","), input = if (mod[x] %in%                       c("input")) inputs[[factorialExp[ind, "input"]]] else NA,                     object = if (mod[x] %in% c("object")) names(objects)[[factorialExp[ind,                       "object"]]] else NA, expLevel = factorialExp[ind,                       "expLevel"], stringsAsFactors = FALSE)),                   use.names = TRUE, fill = TRUE)            }        }        else {            experimentDF <- rbindlist(l = list(experimentDF,                 data.frame(modules = paste0(unlist(modules[factorialExp[ind,                   "modules"]]), collapse = ","), expLevel = factorialExp[ind,                   "expLevel"], stringsAsFactors = FALSE)), use.names = TRUE,                 fill = TRUE)        }        if (!any(unlist(lapply(modules, is.null)))) {            if ("modules" %in% names(factorialExp)) {                if (!identical(sort(unlist(modules[factorialExp[ind,                   "modules"]])), sort(unlist(SpaDES.core::modules(sim))))) {                  sim_ <- simInit(params = params(sim_), modules = as.list(unlist(modules[factorialExp[ind,                     "modules"]])), times = append(lapply(times(sim_)[2:3],                     as.numeric), times(sim_)[4]), paths = paths(sim_),                     outputs = outputs(sim_))                }            }        }        else {            sim_ <- sim        }    }    if (any(dirPrefix == "simNum")) {        exptNum <- paddedFloatToChar(factorialExp$expLevel[ind],             ceiling(log10(numExpLevels + 1)))    }    dirPrefixTmp <- paste0(dirPrefix, collapse = "")    if ((numExpLevels > 1) & (substrLength > 0)) {        dirName <- paste(collapse = "-", substr(mod, 1, substrLength),             substr(param, 1, substrLength), paramValues, sep = "_")        dirName <- gsub(dirName, pattern = "__", replacement = "_")        if (any(dirPrefix == "simNum")) {            dirPrefix <- gsub(dirPrefixTmp, pattern = "simNum",                 replacement = exptNum)        }        if (any(dirPrefix != "")) {            dirName <- paste(paste(dirPrefix, collapse = ""),                 dirName, sep = "_")        }    }    else if (substrLength == 0) {        if (any(dirPrefix != "")) {            simplePrefix <- if (any(dirPrefix == "simNum"))                 exptNum            else ""            dirName <- gsub(dirPrefixTmp, pattern = "simNum",                 replacement = simplePrefix)        }    }    else {        if (any(dirPrefix != "")) {            dirName <- gsub(dirPrefixTmp, pattern = "simNum",                 replacement = "")        }    }    if (exists("repl", inherits = FALSE)) {        nn <- paste0("rep", paddedFloatToChar(repl, ceiling(log10(length(replicates) +             1))))        dirName <- if (!is.null(dirName)) {            file.path(dirName, nn)        }        else {            file.path(nn)        }    }    newOutputPath <- file.path(paths(sim_)$outputPath, dirName) %>%         gsub(pattern = "/$", replacement = "") %>% gsub(pattern = "//",         replacement = "/")    if (!dir.exists(newOutputPath))         dir.create(newOutputPath, recursive = TRUE)    paths(sim_)$outputPath <- newOutputPath    if (NROW(outputs(sim_))) {        outputs(sim_)$file <- file.path(newOutputPath, basename(outputs(sim_)$file))    }    if (length(inputs) > 0) {        SpaDES.core::inputs(sim_) <- inputs[[factorialExp[ind,             "input"]]]    }    if (length(objects) > 0) {        replaceObjName <- strsplit(names(objects)[[factorialExp[ind,             "object"]]], split = "\\.")[[1]][1]        sim_[[replaceObjName]] <- objects[[factorialExp[ind,             "object"]]]    }    dots <- list(...)    if (is.null(dots$cache))         dots$cache <- FALSE    sim3 <- spades(sim_, replicate = ind, ...)    return(list(sim3, experimentDF))}, cache = TRUE, debug = FALSE, omitArgs = c("progress", "debug", ".plotInitialTime", ".saveInitialTime"), notOlderThan = NULL)
24: do.call(get(parFun), args)
25: experiment(Copy(mySim), replicates = 2, cache = TRUE, debug = FALSE,     omitArgs = c("progress", "debug", ".plotInitialTime", ".saveInitialTime"))
26: experiment(Copy(mySim), replicates = 2, cache = TRUE, debug = FALSE,     omitArgs = c("progress", "debug", ".plotInitialTime", ".saveInitialTime"))
27: eval(expr)
28: eval(expr)
29: eval(code, test_env)
30: eval(code, test_env)
31: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)
32: doTryCatch(return(expr), name, parentenv, handler)
33: tryCatchOne(expr, names, parentenv, handlers[[1L]])
34: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
35: doTryCatch(return(expr), name, parentenv, handler)
36: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])
37: tryCatchList(expr, classes, parentenv, handlers)
38: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })
39: test_code(desc, code, env = parent.frame())
40: test_that("test cache", {    testInitOut <- testInit(opts = list(spades.moduleCodeChecks = FALSE,         spades.useRequire = FALSE), setPaths = FALSE)    on.exit({        testOnExit(testInitOut)    }, add = TRUE)    mySim <- simInit(times = list(start = 0, end = 1, timeunit = "year"),         params = list(.globals = list(stackName = "landscape",             burnStats = "nPixelsBurned"), fireSpread = list(.plotInitialTime = NA),             caribouMovement = list(.plotInitialTime = NA), randomLandscapes = list(.plotInitialTime = NA)),         modules = list("randomLandscapes", "fireSpread", "caribouMovement"),         paths = list(modulePath = system.file("sampleModules",             package = "SpaDES.core"), outputPath = tmpdir, cachePath = tmpdir),         outputs = data.frame(objectName = c("landscape", "caribou"),             stringsAsFactors = FALSE))    set.seed(1123)    expr <- quote(experiment(Copy(mySim), replicates = 2, cache = TRUE,         debug = FALSE, omitArgs = c("progress", "debug", ".plotInitialTime",             ".saveInitialTime")))    sims <- eval(expr)    out <- showCache(sims[[1]])    expect_true(NROW(out[tagValue == "spades"]) == 2)    expect_true(NROW(unique(out$artifact)) == 2)    expect_output(print(out), "cacheId")    expect_output(print(out), "simList")    expect_true(NROW(out[!tagKey %in% c("preDigest", "otherFunctions")]) ==         16)    expect_true(NROW(out[tagKey %in% "preDigest"]) == (length(slotNames(sims[[1]])) *         2 + 2 * length(modules(mySim)) + 2 * 2))    expect_message(sims <- eval(expr), "loading cached result from previous spades call")    out2 <- showCache(sims[[1]])    expect_true(NROW(out2[tagKey == "accessed"]) == 4)    expect_true(NROW(unique(out2$artifact)) == 2)    clearCache(sims[[1]], ask = FALSE)    out <- showCache(sims[[1]])    expect_true(NROW(out) == 0)})
41: eval(code, test_env)
42: eval(code, test_env)
43: withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)
44: doTryCatch(return(expr), name, parentenv, handler)
45: tryCatchOne(expr, names, parentenv, handlers[[1L]])
46: tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
47: doTryCatch(return(expr), name, parentenv, handler)
48: tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])
49: tryCatchList(expr, classes, parentenv, handlers)
50: tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })
51: test_code(NULL, exprs, env)
52: source_file(path, new.env(parent = env), chdir = TRUE, wrap = wrap)
53: force(code)
54: with_reporter(reporter = reporter, start_end_reporter = start_end_reporter,     {        lister$start_file(basename(path))        source_file(path, new.env(parent = env), chdir = TRUE,             wrap = wrap)        end_context()    })
55: FUN(X[[i]], ...)
56: lapply(paths, test_file, env = env, reporter = current_reporter,     start_end_reporter = FALSE, load_helpers = FALSE, wrap = wrap)
57: force(code)
58: with_reporter(reporter = current_reporter, results <- lapply(paths,     test_file, env = env, reporter = current_reporter, start_end_reporter = FALSE,     load_helpers = FALSE, wrap = wrap))
59: test_files(paths, reporter = reporter, env = env, stop_on_failure = stop_on_failure,     stop_on_warning = stop_on_warning, wrap = wrap)
60: test_dir(path = test_path, reporter = reporter, env = env, filter = filter,     ..., stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap)
61: test_package_dir(package = package, test_path = test_path, filter = filter,     reporter = reporter, ..., stop_on_failure = stop_on_failure,     stop_on_warning = stop_on_warning, wrap = wrap)
62: test_check("SpaDES.core")
An irrecoverable exception occurred. R is aborting now ...
