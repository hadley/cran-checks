
R Under development (unstable) (2018-01-02 r74022) -- "Unsuffered Consequences"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "kyotil"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('kyotil')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Deming")
> ### * Deming
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Deming
> ### Title: Fit Deming regression.
> ### Aliases: Deming coef.Deming vcov.Deming getFixedEf.Deming
> ###   predict.Deming summary.Deming
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D set.seed(1)
> ##D x=rnorm(100,0,1)
> ##D y=x+rnorm(100,0,.5)
> ##D x=x+rnorm(100,0,.5)
> ##D fit=Deming(x,y, boot=TRUE)
> ##D summary(fit)
> ##D plot(x,y)
> ##D abline(fit)
> ##D # compare with lm fit
> ##D fit.1=lm(y~x, data.frame(x,y))
> ##D summary(fit.1)
> ##D abline(fit.1, col=2)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("VEplot")
> ### * VEplot
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: VEplot
> ### Title: Vaccine Efficacy Plots
> ### Aliases: VEplot VEplot.cox.zph myplot.cox.zph
> 
> ### ** Examples
> 
> 
> library(survival)
> vfit <- coxph(Surv(time,status) ~ trt + factor(celltype) + 
+               karno + age, data=veteran, x=TRUE) 
> temp <- cox.zph(vfit) 
> 
> par(mfrow=c(2,2))
> for (v in c("trt","age")) {
+     VEplot(temp, var=v, resid=FALSE, main=v, ylab="VE", cex.axis=1.5)
+     plot(temp, var=v, resid=FALSE, main=v)
+ }
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()

detaching ‘package:survival’

> nameEx("age_calc")
> ### * age_calc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: age_calc
> ### Title: Age Calculation
> ### Aliases: age_calc
> 
> ### ** Examples
> 
> 
> age_calc (dob=strptime("29OCT2002", format="%d%b%Y"), 
+     enddate=strptime("30OCT2003", format="%d%b%Y"), units='years', precise=TRUE)
[1] 1.00274
> age_calc (dob=strptime("29OCT2002", format="%d%b%Y"), 
+     enddate=strptime("30DEC2003", format="%d%b%Y"), units='years', precise=FALSE)
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("base")
> ### * base
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: base.functions
> ### Title: Some Base Functions
> ### Aliases: cbinduneven binary binary2 f2c ftoi keepWarnings meanmed
> ###   methods4 myaggregate myreshapewide mysapply myscale mysystem mytapply
> ###   read.sv read.tsv table.prop unix table.cases table.cases.3
> ###   multi.outer myreshapelong
> 
> ### ** Examples
> 
> 
> binary(5) ###  101
[1] "101"
> binary2(5, 4)
[1] "0101"
> 
> a=data.frame("x"=1:2)
> b=data.frame("y"=3:5);#rownames(b)[3]=""
> cbinduneven(list(a,b))
      
1  1 3
2  2 4
3 NA 5
> 
> ## Not run: 
> ##D # the formula in myreshapewide can only have one variable in the right hand side
> ##D     myreshapewide(fi~week, dat, c("ptid","stim"))
> ##D 
> ##D     myaggregate(subset(dat.poc, select=c(HIV, trt)), list(dat.poc$f), function(x) 
> ##D       with(x, c(fisher.test(HIV, trt)$estimate, fisher.test(HIV, trt)$p.value)))
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cox.zph.2")
> ### * cox.zph.2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cox.zph.2
> ### Title: Test the Proportional Hazards Assumption of a Cox Regression (a
> ###   slightly modified version)
> ### Aliases: cox.zph.2
> 
> ### ** Examples
> 
> library(survival)
> fit <- coxph(Surv(futime, fustat) ~ age + ecog.ps,  
+              data=ovarian) 
> temp <- cox.zph(fit) 
> print(temp)        
           rho chisq     p
age     -0.243 0.856 0.355
ecog.ps  0.520 2.545 0.111
GLOBAL      NA 3.195 0.202
> temp.2 <- cox.zph.2(fit) 
> print(temp.2)        
           rho chisq     p
age     -0.243 0.698 0.404
ecog.ps  0.520 2.371 0.124
GLOBAL      NA 3.633 0.163
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("getK")
> ### * getK
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getK
> ### Title: getK
> ### Aliases: getK getK
> 
> ### ** Examples
> 
> 
> X = cbind(x1=rnorm(n=5), x2=rnorm(n=5))
> dim(X)
[1] 5 2
> X2 = cbind(x1=rnorm(n=3), x2=rnorm(n=3))
> dim(X2)
[1] 3 2
> 
> K = getK(X,"linear")
> dim(K)
[1] 5 5
> 
> K = getK(X,"linear",X2=X2)
> dim(K)
[1] 5 3
> K1 = getK(X2,"l",X2=X)
> dim(K1)
[1] 3 5
> all(K==t(K1))
[1] TRUE
> 
> 
> # RBF kernel
> K = getK(X,"rbf",para=1,X2=X2)
> K1 = getK(X2,"r",para=1,X2=X)
> all(K==t(K1))
[1] TRUE
> 
> 
> # IBS kernel for ternary data 
> X <- as.matrix(expand.grid(0:2,0:2))
> K = getK(X,kernel = 'ibs')
> 
> # add weight
> w = runif(ncol(X))
> K = getK(X,kernel = 'ibs',para = w) 
> 
> 
> # IBS kernel for binary data via option 'h' for 'hamming similarity measure'
> X <- as.matrix(expand.grid(0:1,0:1))
> K=getK(X,kernel = 'h')
> 
> 
> 
> 
> cleanEx()
> nameEx("make.timedep.dataset")
> ### * make.timedep.dataset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.timedep.dataset
> ### Title: Create Dataset for Time-dependent Covariate Proportional Hazard
> ###   Model Analaysi
> ### Aliases: make.timedep.dataset
> ### Keywords: time varying
> 
> ### ** Examples
> 
> 
> library(survival)
> 
> n=3000; followup.length=5; incidence.density=0.015; age.sim="continuous"
> 
> dat.0=sim.dat.tvarying.two(n, followup.length, incidence.density, age.sim, seed=1)
> dat=subset(dat.0, for.non.tvarying.ana, select=c(ptid, X, d, baseline.age, trt))
> dat.timedep = make.timedep.dataset (dat, "X", "d", "baseline.age", 6)
> coxph(Surv(tstart,tstop,d) ~ trt*.timedep.agegrp, dat.timedep)
Call:
coxph(formula = Surv(tstart, tstop, d) ~ trt * .timedep.agegrp, 
    data = dat.timedep)

                              coef exp(coef) se(coef)     z       p
trt                        -0.6274    0.5340   0.2419 -2.59  0.0095
.timedep.agegrp[6,100)     -0.7368    0.4786   0.1737 -4.24 2.2e-05
trt:.timedep.agegrp[6,100)  0.0347    1.0353   0.2804  0.12  0.9017

Likelihood ratio test=50  on 3 df, p=8.05e-11
n= 4071, number of events= 292 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("math")
> ### * math
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: math.functions
> ### Title: Math Functions
> ### Aliases: math.functions as.binary binom.coef expit logDiffExp logit
> ###   logMeanExp logSumExp logSumExpFor2 permn Stirling2 interpolate
> 
> ### ** Examples
> 
> H(rep(1/5,5))
[1] 1.609438
> H(rep(3,5))
[1] 1.609438
> 
> 
> 
> cleanEx()
> nameEx("matrix")
> ### * matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrix.array.functions
> ### Title: Matrix and Array Functions
> ### Aliases: matrix.array.functions matrix.functions array.functions AR1
> ###   concatList EXCH fill.jagged.array getMidPoints getUpperRight last mix
> ###   rep.data.frame rep.matrix rep.matrix.block shift.left shift.right
> ###   thin.rows ThinRows tr
> 
> ### ** Examples
> 
> 
> concatList(1:3,"_")
[1] "1_2_3"
> 
> 
> 
> cleanEx()
> nameEx("matrix2")
> ### * matrix2
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: matrix2
> ### Title: Matrix Functions that May Be Faster than
> ### Aliases: DXD tXDX symprod txSy .as.double
> 
> ### ** Examples
> 
> 
> d1=1:3
> d2=4:6
> X=matrix(1:9,3,3)
> all(DXD(d1, X, d2) == diag(d1) %*% X %*% diag(d2))
[1] TRUE
> 
> S=matrix(c(1,2,3,2,4,5,3,5,8),3,3)
> X=matrix(1:9,3,3)
> all( symprod(S, X) == S %*% X )
[1] TRUE
> 
> x=1:3
> y=4:6
> S=matrix(c(1,2,3,2,4,5,3,5,8),3,3)
> txSy(x, S, y) == drop(t(x)%*%S%*%y)
[1] TRUE
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("plotting")
> ### * plotting
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plotting
> ### Title: Plotting Functions
> ### Aliases: abline.pt.slope wtd.hist abline.pts abline.shade
> ###   abline.shade.2 butterfly.plot empty.plot getMfrow myforestplot
> ###   my.interaction.plot myboxplot myboxplot.formula myboxplot.data.frame
> ###   myboxplot.list mylegend mymatplot mypairs myhist mypdf mypng
> ###   mypostscript panel.cor panel.hist panel.nothing corplot
> ###   corplot.default corplot.formula VEplot.glm add.mtext.label mydev.off
> ###   myfigure mytiff
> 
> ### ** Examples
> 
> myfigure(mfrow=c(1,2))
>     plot(1:10)
>     plot(1:10)
> mydev.off(ext="png,pdf", file="tmp")
Saving figure to /home/tomas/cran/rlibro/check/kyotil.Rcheck/tmp.png
Saving figure to /home/tomas/cran/rlibro/check/kyotil.Rcheck/tmp.pdf
> 
> set.seed(1)
> x=1:50+rnorm(50,0,4)
> y=1:50+rnorm(50,0,4)
> dat=data.frame(x, y)
> corplot(y~x,dat,add.lm.fit=TRUE,add.deming.fit=TRUE,col.lm="red",col.deming="blue")
> 
> 
> 
> 
> cleanEx()
> nameEx("print")
> ### * print
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: print.functions
> ### Title: Print Functions
> ### Aliases: formatInt formatDouble make.latex.coef.table mytex mytex.begin
> ###   mytex.end mywrite mywrite.csv roundup
> 
> ### ** Examples
> 
> 
> roundup (3.1, 2) # 3.10
[1] "3.10"
> 
> formatInt(3, 2) # 03
[1] "03"
> 
> 
> ## Not run: 
> ##D  
> ##D 
> ##D # col.headers has to have the RIGHT number of columns in the next three examples!
> ##D 
> ##D # include.rownames=T, no duplicate rownames, align can have 4/5 elements, col.headers has 5 columns
> ##D tab=diag(1:4); rownames(tab)<-colnames(tab)<-1:4
> ##D mytex (tab, file="tmp", include.rownames = TRUE, 
> ##D     align=c("c","c","c|","c","c"), col.headers=
> ##D     "\hline\n & \multicolumn{2}{c|}{Vaccine} & \multicolumn{2}{c}{Control} \\ \n")
> ##D 
> ##D # include.rownames=T, duplicate rownames, align can have 4 or 5 elements, col.headers has 5 columns
> ##D tab=diag(1:4); rownames(tab)=rep(1,4); colnames(tab)<-1:4
> ##D mytex (tab, file="tmp", include.rownames = TRUE, 
> ##D     align=c("c","c|","c","c"), col.headers=
> ##D     "\hline\n & \multicolumn{2}{c|}{Vaccine} & \multicolumn{2}{c}{Control} \\ \n") 
> ##D 
> ##D # include.rownames=F, align can have 4 or 5 elements, col.headers has 4 columns!
> ##D tab=diag(1:4); rownames(tab)<-colnames(tab)<-1:4
> ##D mytex (tab, file="tmp", include.rownames = FALSE, 
> ##D     align=c("c","c","c|","c","c"), col.headers=
> ##D     "\hline\n     \multicolumn{2}{c|}{Vaccine} & \multicolumn{2}{c}{Control} \\ \n") 
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("random")
> ### * random
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: random.functions
> ### Title: Random Functions
> ### Aliases: dbern rbigamma rbilogistic dcorbern dmixnorm dnorm.norm.gamma
> ###   rbern rejective.sampling rnorm.cor rmixnorm rnorm.norm.gamma
> ###   rdoublexp ddoublexp qdoublexp pdoublexp rbidoublexp
> 
> ### ** Examples
> 
> 
> set.seed(1)
> rbern(n=10, p=1/2)
 [1] 0 0 1 1 0 1 1 1 1 0
> rbern(n=2, p=c(.999,.001))
[1] 1 0
> 
> 
> 
> 
> cleanEx()
> nameEx("regression.model.functions")
> ### * regression.model.functions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: regression.model.functions
> ### Title: Regression Model Functions
> ### Aliases: coef.geese coef.tps getFixedEf getFixedEf.coxph getFixedEf.gam
> ###   getFixedEf.tps getFixedEf.gee getFixedEf.geese getFixedEf.glm
> ###   getFixedEf.inla getFixedEf.lm getFixedEf.lme getFixedEf.lmerMod
> ###   getFixedEf.logistf getFixedEf.matrix getFixedEf.mer
> ###   getFixedEf.MIresult getFixedEf2 getFormattedSummary getVarComponent
> ###   getVarComponent.hyperpar.inla getVarComponent.matrix
> ###   getVarComponent.lmerMod interaction.table predict.geese predict.tps
> ###   residuals.geese vcov.geese vcov.tps vcov.logistf risk.cal
> 
> ### ** Examples
> 
> 
> ## Annette Dobson (1990) "An Introduction to Generalized Linear Models".
> ## Page 9: Plant Weight Data.
> ctl <- c(4.17,5.58,5.18,6.11,4.50,4.61,5.17,4.53,5.33,5.14)
> trt <- c(4.81,4.17,4.41,3.59,5.87,3.83,6.03,4.89,4.32,4.69)
> group <- gl(2, 10, 20, labels = c("Ctl","Trt"))
> weight <- c(ctl, trt)
> lm.D9 <- lm(weight ~ group)
> glm.D9 <- glm(weight ~ group)
> getFormattedSummary (list(lm.D9, glm.D9), robust=FALSE)
            [,1]             [,2]            
(Intercept) " 5.03 (0.22)**" " 5.03 (0.22)**"
groupTrt    "-0.37 (0.31)"   "-0.37 (0.31)"  
> 
> 
> 
> 
> cleanEx()
> nameEx("sim.dat.tvarying")
> ### * sim.dat.tvarying
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sim.dat.tvarying.two
> ### Title: Simulation Functions for Time-dependent Proportional Hazard
> ###   Model
> ### Aliases: sim.dat.tvarying.two sim.dat.tvarying.three
> 
> ### ** Examples
> 
> 
> library(survival)
> 
> dat=sim.dat.tvarying.three(n=6000,followup.length=3, incidence.density=0.05, 
+     age.sim="tvaryinggroup", seed=1)
> f.tvarying = Surv(tstart,tstop,d) ~ trt*agegrp 
> f =          Surv(X,d)            ~ trt*baseline.agegrp 
> fits=list()
> fits[["tvarying"]]=coxph(f.tvarying, dat)
> fits[["baseline"]]=coxph(f, subset(dat, for.non.tvarying.ana))
> fits
$tvarying
Call:
coxph(formula = f.tvarying, data = dat)

                      coef exp(coef) se(coef)      z      p
trt                -0.6687    0.5123   0.1080  -6.19  6e-10
agegrp[6,12)       -1.1900    0.3042   0.0988 -12.05 <2e-16
agegrp[12,100)     -1.5257    0.2175   0.1115 -13.69 <2e-16
trt:agegrp[6,12)   -0.1390    0.8703   0.1674  -0.83 0.4064
trt:agegrp[12,100) -0.6294    0.5329   0.2152  -2.92 0.0035

Likelihood ratio test=508  on 5 df, p=0
n= 8246, number of events= 817 

$baseline
Call:
coxph(formula = f, data = subset(dat, for.non.tvarying.ana))

                               coef exp(coef) se(coef)     z       p
trt                         -0.6926    0.5003   0.1009 -6.86 6.8e-12
baseline.agegrp[6,12)       -0.9153    0.4004   0.0959 -9.55 < 2e-16
baseline.agegrp[12,100)     -1.1420    0.3192   0.1166 -9.79 < 2e-16
trt:baseline.agegrp[6,12)   -0.1783    0.8367   0.1679 -1.06   0.288
trt:baseline.agegrp[12,100) -0.5545    0.5744   0.2336 -2.37   0.018

Likelihood ratio test=374  on 5 df, p=0
n= 6000, number of events= 817 

> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()

detaching ‘package:survival’

> nameEx("stat")
> ### * stat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stat.functions
> ### Title: Stat Functions
> ### Aliases: stat.functions mutual.info H cor.mixed cor.mixed.default
> ###   cor.mixed.vector cor.mixed.formula info.cor yule.y kappa.cor
> ###   l.measure skew
> 
> ### ** Examples
> 
> H(rep(1/5,5))
[1] 1.609438
> H(rep(3,5))
[1] 1.609438
> 
> 
> 
> cleanEx()
> nameEx("string")
> ### * string
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: string.functions
> ### Title: String Functions
> ### Aliases: string.functions %+% contain escapeUnderline fileStem
> ###   firstIndex getExt getFileStem getStem lastIndex myprint
> ###   myprint.default remove.prefix trim
> 
> ### ** Examples
> 
> 
> x=1
> x %+% "b" %+% "c"
[1] "1bc"
> 
> 
> 
> 
> cleanEx()
> nameEx("tests")
> ### * tests
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: testing.functions
> ### Title: Testing Functions
> ### Aliases: hosmerlem myfisher.test quick.t.test signtest tukey.mtest
> ###   vector.t.test
> 
> ### ** Examples
> 
> 
> signtest(runif(10))

	Exact binomial test

data:  sum(x > 0, na.rm = TRUE) and sum(x != 0, na.rm = TRUE)
number of successes = 10, number of trials = 10, p-value = 0.001953
alternative hypothesis: true probability of success is not equal to 0.5
95 percent confidence interval:
 0.6915029 1.0000000
sample estimates:
probability of success 
                     1 

> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  3.088 0.088 3.179 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
